{
  "version": 3,
  "sources": ["../../ionicons/node_modules/@stencil/core/internal/app-data/index.js", "../../ionicons/node_modules/@stencil/core/internal/client/index.js", "../../ionicons/components/utils.js", "../../ionicons/components/ion-icon.js", "../../@ionic/vue/dist-transpiled/vue-component-lib/utils.js", "../../@ionic/vue/dist-transpiled/proxies.js", "../../@ionic/vue/dist-transpiled/hooks/back-button.js", "../../@ionic/vue/dist-transpiled/hooks/keyboard.js", "../../@ionic/vue/dist-transpiled/utils.js", "../../@ionic/vue/dist-transpiled/hooks/lifecycle.js", "../../@ionic/vue/dist-transpiled/hooks/router.js", "../../@ionic/vue/dist-transpiled/ionic-vue.js", "../../@ionic/vue/dist-transpiled/components/IonBackButton.js", "../../@ionic/vue/dist-transpiled/components/IonPage.js", "../../@ionic/vue/dist-transpiled/components/IonRouterOutlet.js", "../../@ionic/vue/dist-transpiled/components/IonTabButton.js", "../../@ionic/vue/dist-transpiled/components/IonTabs.js", "../../@ionic/vue/dist-transpiled/components/IonTabBar.js", "../../@ionic/vue/dist-transpiled/components/IonApp.js", "../../@ionic/vue/dist-transpiled/framework-delegate.js", "../../@ionic/vue/dist-transpiled/components/IonNav.js", "../../@ionic/vue/dist-transpiled/components/IonIcon.js", "../../@ionic/vue/dist-transpiled/vue-component-lib/overlays.js", "../../@ionic/vue/dist-transpiled/components/Overlays.js", "../../@ionic/vue/dist-transpiled/controllers.js"],
  "sourcesContent": ["const BUILD = {\n    allRenderFn: false,\n    cmpDidLoad: true,\n    cmpDidUnload: false,\n    cmpDidUpdate: true,\n    cmpDidRender: true,\n    cmpWillLoad: true,\n    cmpWillUpdate: true,\n    cmpWillRender: true,\n    connectedCallback: true,\n    disconnectedCallback: true,\n    element: true,\n    event: true,\n    hasRenderFn: true,\n    lifecycle: true,\n    hostListener: true,\n    hostListenerTargetWindow: true,\n    hostListenerTargetDocument: true,\n    hostListenerTargetBody: true,\n    hostListenerTargetParent: false,\n    hostListenerTarget: true,\n    member: true,\n    method: true,\n    mode: true,\n    observeAttribute: true,\n    prop: true,\n    propMutable: true,\n    reflect: true,\n    scoped: true,\n    shadowDom: true,\n    slot: true,\n    cssAnnotations: true,\n    state: true,\n    style: true,\n    svg: true,\n    updatable: true,\n    vdomAttribute: true,\n    vdomXlink: true,\n    vdomClass: true,\n    vdomFunctional: true,\n    vdomKey: true,\n    vdomListener: true,\n    vdomRef: true,\n    vdomPropOrAttr: true,\n    vdomRender: true,\n    vdomStyle: true,\n    vdomText: true,\n    watchCallback: true,\n    taskQueue: true,\n    hotModuleReplacement: false,\n    isDebug: false,\n    isDev: false,\n    isTesting: false,\n    hydrateServerSide: false,\n    hydrateClientSide: false,\n    lifecycleDOMEvents: false,\n    lazyLoad: false,\n    profile: false,\n    slotRelocation: true,\n    appendChildSlotFix: false,\n    cloneNodeFix: false,\n    hydratedAttribute: false,\n    hydratedClass: true,\n    safari10: false,\n    scriptDataOpts: false,\n    scopedSlotTextContentFix: false,\n    shadowDomShim: false,\n    slotChildNodesFix: false,\n    invisiblePrehydration: true,\n    propBoolean: true,\n    propNumber: true,\n    propString: true,\n    cssVarShim: false,\n    constructableCSS: true,\n    cmpShouldUpdate: true,\n    devTools: false,\n    dynamicImportShim: false,\n    shadowDelegatesFocus: true,\n    initializeNextTick: false,\n    asyncLoading: false,\n    asyncQueue: false,\n    transformTagName: false,\n    attachStyles: true,\n};\nconst Env = {};\nconst NAMESPACE = /* default */ 'app';\n\nexport { BUILD, Env, NAMESPACE };\n", "let scopeId;\nlet contentRef;\nlet hostTagName;\nlet customError;\nlet i = 0;\nlet useNativeShadowDom = false;\nlet checkSlotFallbackVisibility = false;\nlet checkSlotRelocate = false;\nlet isSvgMode = false;\nlet renderingRef = null;\nlet queueCongestion = 0;\nlet queuePending = false;\n/*\n Stencil Client Platform v2.16.1 | MIT Licensed | https://stenciljs.com\n */\nimport { BUILD, NAMESPACE } from '@stencil/core/internal/app-data';\nconst win = typeof window !== 'undefined' ? window : {};\nconst CSS = BUILD.cssVarShim ? win.CSS : null;\nconst doc = win.document || { head: {} };\nconst H = (win.HTMLElement || class {\n});\nconst plt = {\n    $flags$: 0,\n    $resourcesUrl$: '',\n    jmp: (h) => h(),\n    raf: (h) => requestAnimationFrame(h),\n    ael: (el, eventName, listener, opts) => el.addEventListener(eventName, listener, opts),\n    rel: (el, eventName, listener, opts) => el.removeEventListener(eventName, listener, opts),\n    ce: (eventName, opts) => new CustomEvent(eventName, opts),\n};\nconst setPlatformHelpers = (helpers) => {\n    Object.assign(plt, helpers);\n};\nconst supportsShadow = BUILD.shadowDomShim && BUILD.shadowDom\n    ? /*@__PURE__*/ (() => (doc.head.attachShadow + '').indexOf('[native') > -1)()\n    : true;\nconst supportsListenerOptions = /*@__PURE__*/ (() => {\n    let supportsListenerOptions = false;\n    try {\n        doc.addEventListener('e', null, Object.defineProperty({}, 'passive', {\n            get() {\n                supportsListenerOptions = true;\n            },\n        }));\n    }\n    catch (e) { }\n    return supportsListenerOptions;\n})();\nconst promiseResolve = (v) => Promise.resolve(v);\nconst supportsConstructibleStylesheets = BUILD.constructableCSS\n    ? /*@__PURE__*/ (() => {\n        try {\n            new CSSStyleSheet();\n            return typeof new CSSStyleSheet().replace === 'function';\n        }\n        catch (e) { }\n        return false;\n    })()\n    : false;\nconst Context = {};\nconst addHostEventListeners = (elm, hostRef, listeners, attachParentListeners) => {\n    if (BUILD.hostListener && listeners) {\n        // this is called immediately within the element's constructor\n        // initialize our event listeners on the host element\n        // we do this now so that we can listen to events that may\n        // have fired even before the instance is ready\n        if (BUILD.hostListenerTargetParent) {\n            // this component may have event listeners that should be attached to the parent\n            if (attachParentListeners) {\n                // this is being ran from within the connectedCallback\n                // which is important so that we know the host element actually has a parent element\n                // filter out the listeners to only have the ones that ARE being attached to the parent\n                listeners = listeners.filter(([flags]) => flags & 32 /* TargetParent */);\n            }\n            else {\n                // this is being ran from within the component constructor\n                // everything BUT the parent element listeners should be attached at this time\n                // filter out the listeners that are NOT being attached to the parent\n                listeners = listeners.filter(([flags]) => !(flags & 32 /* TargetParent */));\n            }\n        }\n        listeners.map(([flags, name, method]) => {\n            const target = BUILD.hostListenerTarget ? getHostListenerTarget(elm, flags) : elm;\n            const handler = hostListenerProxy(hostRef, method);\n            const opts = hostListenerOpts(flags);\n            plt.ael(target, name, handler, opts);\n            (hostRef.$rmListeners$ = hostRef.$rmListeners$ || []).push(() => plt.rel(target, name, handler, opts));\n        });\n    }\n};\nconst hostListenerProxy = (hostRef, methodName) => (ev) => {\n    try {\n        if (BUILD.lazyLoad) {\n            if (hostRef.$flags$ & 256 /* isListenReady */) {\n                // instance is ready, let's call it's member method for this event\n                hostRef.$lazyInstance$[methodName](ev);\n            }\n            else {\n                (hostRef.$queuedListeners$ = hostRef.$queuedListeners$ || []).push([methodName, ev]);\n            }\n        }\n        else {\n            hostRef.$hostElement$[methodName](ev);\n        }\n    }\n    catch (e) {\n        consoleError(e);\n    }\n};\nconst getHostListenerTarget = (elm, flags) => {\n    if (BUILD.hostListenerTargetDocument && flags & 4 /* TargetDocument */)\n        return doc;\n    if (BUILD.hostListenerTargetWindow && flags & 8 /* TargetWindow */)\n        return win;\n    if (BUILD.hostListenerTargetBody && flags & 16 /* TargetBody */)\n        return doc.body;\n    if (BUILD.hostListenerTargetParent && flags & 32 /* TargetParent */)\n        return elm.parentElement;\n    return elm;\n};\n// prettier-ignore\nconst hostListenerOpts = (flags) => supportsListenerOptions\n    ? ({\n        passive: (flags & 1 /* Passive */) !== 0,\n        capture: (flags & 2 /* Capture */) !== 0,\n    })\n    : (flags & 2 /* Capture */) !== 0;\nconst CONTENT_REF_ID = 'r';\nconst ORG_LOCATION_ID = 'o';\nconst SLOT_NODE_ID = 's';\nconst TEXT_NODE_ID = 't';\nconst HYDRATE_ID = 's-id';\nconst HYDRATED_STYLE_ID = 'sty-id';\nconst HYDRATE_CHILD_ID = 'c-id';\nconst HYDRATED_CSS = '{visibility:hidden}.hydrated{visibility:inherit}';\nconst XLINK_NS = 'http://www.w3.org/1999/xlink';\nconst createTime = (fnName, tagName = '') => {\n    if (BUILD.profile && performance.mark) {\n        const key = `st:${fnName}:${tagName}:${i++}`;\n        // Start\n        performance.mark(key);\n        // End\n        return () => performance.measure(`[Stencil] ${fnName}() <${tagName}>`, key);\n    }\n    else {\n        return () => {\n            return;\n        };\n    }\n};\nconst uniqueTime = (key, measureText) => {\n    if (BUILD.profile && performance.mark) {\n        if (performance.getEntriesByName(key).length === 0) {\n            performance.mark(key);\n        }\n        return () => {\n            if (performance.getEntriesByName(measureText).length === 0) {\n                performance.measure(measureText, key);\n            }\n        };\n    }\n    else {\n        return () => {\n            return;\n        };\n    }\n};\nconst inspect = (ref) => {\n    const hostRef = getHostRef(ref);\n    if (!hostRef) {\n        return undefined;\n    }\n    const flags = hostRef.$flags$;\n    const hostElement = hostRef.$hostElement$;\n    return {\n        renderCount: hostRef.$renderCount$,\n        flags: {\n            hasRendered: !!(flags & 2 /* hasRendered */),\n            hasConnected: !!(flags & 1 /* hasConnected */),\n            isWaitingForChildren: !!(flags & 4 /* isWaitingForChildren */),\n            isConstructingInstance: !!(flags & 8 /* isConstructingInstance */),\n            isQueuedForUpdate: !!(flags & 16 /* isQueuedForUpdate */),\n            hasInitializedComponent: !!(flags & 32 /* hasInitializedComponent */),\n            hasLoadedComponent: !!(flags & 64 /* hasLoadedComponent */),\n            isWatchReady: !!(flags & 128 /* isWatchReady */),\n            isListenReady: !!(flags & 256 /* isListenReady */),\n            needsRerender: !!(flags & 512 /* needsRerender */),\n        },\n        instanceValues: hostRef.$instanceValues$,\n        ancestorComponent: hostRef.$ancestorComponent$,\n        hostElement,\n        lazyInstance: hostRef.$lazyInstance$,\n        vnode: hostRef.$vnode$,\n        modeName: hostRef.$modeName$,\n        onReadyPromise: hostRef.$onReadyPromise$,\n        onReadyResolve: hostRef.$onReadyResolve$,\n        onInstancePromise: hostRef.$onInstancePromise$,\n        onInstanceResolve: hostRef.$onInstanceResolve$,\n        onRenderResolve: hostRef.$onRenderResolve$,\n        queuedListeners: hostRef.$queuedListeners$,\n        rmListeners: hostRef.$rmListeners$,\n        ['s-id']: hostElement['s-id'],\n        ['s-cr']: hostElement['s-cr'],\n        ['s-lr']: hostElement['s-lr'],\n        ['s-p']: hostElement['s-p'],\n        ['s-rc']: hostElement['s-rc'],\n        ['s-sc']: hostElement['s-sc'],\n    };\n};\nconst installDevTools = () => {\n    if (BUILD.devTools) {\n        const stencil = (win.stencil = win.stencil || {});\n        const originalInspect = stencil.inspect;\n        stencil.inspect = (ref) => {\n            let result = inspect(ref);\n            if (!result && typeof originalInspect === 'function') {\n                result = originalInspect(ref);\n            }\n            return result;\n        };\n    }\n};\nconst rootAppliedStyles = new WeakMap();\nconst registerStyle = (scopeId, cssText, allowCS) => {\n    let style = styles.get(scopeId);\n    if (supportsConstructibleStylesheets && allowCS) {\n        style = (style || new CSSStyleSheet());\n        style.replace(cssText);\n    }\n    else {\n        style = cssText;\n    }\n    styles.set(scopeId, style);\n};\nconst addStyle = (styleContainerNode, cmpMeta, mode, hostElm) => {\n    let scopeId = getScopeId(cmpMeta, mode);\n    const style = styles.get(scopeId);\n    if (!BUILD.attachStyles) {\n        return scopeId;\n    }\n    // if an element is NOT connected then getRootNode() will return the wrong root node\n    // so the fallback is to always use the document for the root node in those cases\n    styleContainerNode = styleContainerNode.nodeType === 11 /* DocumentFragment */ ? styleContainerNode : doc;\n    if (style) {\n        if (typeof style === 'string') {\n            styleContainerNode = styleContainerNode.head || styleContainerNode;\n            let appliedStyles = rootAppliedStyles.get(styleContainerNode);\n            let styleElm;\n            if (!appliedStyles) {\n                rootAppliedStyles.set(styleContainerNode, (appliedStyles = new Set()));\n            }\n            if (!appliedStyles.has(scopeId)) {\n                if (BUILD.hydrateClientSide &&\n                    styleContainerNode.host &&\n                    (styleElm = styleContainerNode.querySelector(`[${HYDRATED_STYLE_ID}=\"${scopeId}\"]`))) {\n                    // This is only happening on native shadow-dom, do not needs CSS var shim\n                    styleElm.innerHTML = style;\n                }\n                else {\n                    if (BUILD.cssVarShim && plt.$cssShim$) {\n                        styleElm = plt.$cssShim$.createHostStyle(hostElm, scopeId, style, !!(cmpMeta.$flags$ & 10 /* needsScopedEncapsulation */));\n                        const newScopeId = styleElm['s-sc'];\n                        if (newScopeId) {\n                            scopeId = newScopeId;\n                            // we don't want to add this styleID to the appliedStyles Set\n                            // since the cssVarShim might need to apply several different\n                            // stylesheets for the same component\n                            appliedStyles = null;\n                        }\n                    }\n                    else {\n                        styleElm = doc.createElement('style');\n                        styleElm.innerHTML = style;\n                    }\n                    if (BUILD.hydrateServerSide || BUILD.hotModuleReplacement) {\n                        styleElm.setAttribute(HYDRATED_STYLE_ID, scopeId);\n                    }\n                    styleContainerNode.insertBefore(styleElm, styleContainerNode.querySelector('link'));\n                }\n                if (appliedStyles) {\n                    appliedStyles.add(scopeId);\n                }\n            }\n        }\n        else if (BUILD.constructableCSS && !styleContainerNode.adoptedStyleSheets.includes(style)) {\n            styleContainerNode.adoptedStyleSheets = [...styleContainerNode.adoptedStyleSheets, style];\n        }\n    }\n    return scopeId;\n};\nconst attachStyles = (hostRef) => {\n    const cmpMeta = hostRef.$cmpMeta$;\n    const elm = hostRef.$hostElement$;\n    const flags = cmpMeta.$flags$;\n    const endAttachStyles = createTime('attachStyles', cmpMeta.$tagName$);\n    const scopeId = addStyle(BUILD.shadowDom && supportsShadow && elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(), cmpMeta, hostRef.$modeName$, elm);\n    if ((BUILD.shadowDom || BUILD.scoped) && BUILD.cssAnnotations && flags & 10 /* needsScopedEncapsulation */) {\n        // only required when we're NOT using native shadow dom (slot)\n        // or this browser doesn't support native shadow dom\n        // and this host element was NOT created with SSR\n        // let's pick out the inner content for slot projection\n        // create a node to represent where the original\n        // content was first placed, which is useful later on\n        // DOM WRITE!!\n        elm['s-sc'] = scopeId;\n        elm.classList.add(scopeId + '-h');\n        if (BUILD.scoped && flags & 2 /* scopedCssEncapsulation */) {\n            elm.classList.add(scopeId + '-s');\n        }\n    }\n    endAttachStyles();\n};\nconst getScopeId = (cmp, mode) => 'sc-' + (BUILD.mode && mode && cmp.$flags$ & 32 /* hasMode */ ? cmp.$tagName$ + '-' + mode : cmp.$tagName$);\nconst convertScopedToShadow = (css) => css.replace(/\\/\\*!@([^\\/]+)\\*\\/[^\\{]+\\{/g, '$1{');\n// Private\nconst computeMode = (elm) => modeResolutionChain.map((h) => h(elm)).find((m) => !!m);\n// Public\nconst setMode = (handler) => modeResolutionChain.push(handler);\nconst getMode = (ref) => getHostRef(ref).$modeName$;\n/**\n * Default style mode id\n */\n/**\n * Reusable empty obj/array\n * Don't add values to these!!\n */\nconst EMPTY_OBJ = {};\n/**\n * Namespaces\n */\nconst SVG_NS = 'http://www.w3.org/2000/svg';\nconst HTML_NS = 'http://www.w3.org/1999/xhtml';\nconst isDef = (v) => v != null;\nconst isComplexType = (o) => {\n    // https://jsperf.com/typeof-fn-object/5\n    o = typeof o;\n    return o === 'object' || o === 'function';\n};\n/**\n * Production h() function based on Preact by\n * Jason Miller (@developit)\n * Licensed under the MIT License\n * https://github.com/developit/preact/blob/master/LICENSE\n *\n * Modified for Stencil's compiler and vdom\n */\n// const stack: any[] = [];\n// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, child?: d.ChildType): d.VNode;\n// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, ...children: d.ChildType[]): d.VNode;\nconst h = (nodeName, vnodeData, ...children) => {\n    let child = null;\n    let key = null;\n    let slotName = null;\n    let simple = false;\n    let lastSimple = false;\n    const vNodeChildren = [];\n    const walk = (c) => {\n        for (let i = 0; i < c.length; i++) {\n            child = c[i];\n            if (Array.isArray(child)) {\n                walk(child);\n            }\n            else if (child != null && typeof child !== 'boolean') {\n                if ((simple = typeof nodeName !== 'function' && !isComplexType(child))) {\n                    child = String(child);\n                }\n                else if (BUILD.isDev && typeof nodeName !== 'function' && child.$flags$ === undefined) {\n                    consoleDevError(`vNode passed as children has unexpected type.\nMake sure it's using the correct h() function.\nEmpty objects can also be the cause, look for JSX comments that became objects.`);\n                }\n                if (simple && lastSimple) {\n                    // If the previous child was simple (string), we merge both\n                    vNodeChildren[vNodeChildren.length - 1].$text$ += child;\n                }\n                else {\n                    // Append a new vNode, if it's text, we create a text vNode\n                    vNodeChildren.push(simple ? newVNode(null, child) : child);\n                }\n                lastSimple = simple;\n            }\n        }\n    };\n    walk(children);\n    if (vnodeData) {\n        if (BUILD.isDev && nodeName === 'input') {\n            validateInputProperties(vnodeData);\n        }\n        // normalize class / classname attributes\n        if (BUILD.vdomKey && vnodeData.key) {\n            key = vnodeData.key;\n        }\n        if (BUILD.slotRelocation && vnodeData.name) {\n            slotName = vnodeData.name;\n        }\n        if (BUILD.vdomClass) {\n            const classData = vnodeData.className || vnodeData.class;\n            if (classData) {\n                vnodeData.class =\n                    typeof classData !== 'object'\n                        ? classData\n                        : Object.keys(classData)\n                            .filter((k) => classData[k])\n                            .join(' ');\n            }\n        }\n    }\n    if (BUILD.isDev && vNodeChildren.some(isHost)) {\n        consoleDevError(`The <Host> must be the single root component. Make sure:\n- You are NOT using hostData() and <Host> in the same component.\n- <Host> is used once, and it's the single root component of the render() function.`);\n    }\n    if (BUILD.vdomFunctional && typeof nodeName === 'function') {\n        // nodeName is a functional component\n        return nodeName(vnodeData === null ? {} : vnodeData, vNodeChildren, vdomFnUtils);\n    }\n    const vnode = newVNode(nodeName, null);\n    vnode.$attrs$ = vnodeData;\n    if (vNodeChildren.length > 0) {\n        vnode.$children$ = vNodeChildren;\n    }\n    if (BUILD.vdomKey) {\n        vnode.$key$ = key;\n    }\n    if (BUILD.slotRelocation) {\n        vnode.$name$ = slotName;\n    }\n    return vnode;\n};\nconst newVNode = (tag, text) => {\n    const vnode = {\n        $flags$: 0,\n        $tag$: tag,\n        $text$: text,\n        $elm$: null,\n        $children$: null,\n    };\n    if (BUILD.vdomAttribute) {\n        vnode.$attrs$ = null;\n    }\n    if (BUILD.vdomKey) {\n        vnode.$key$ = null;\n    }\n    if (BUILD.slotRelocation) {\n        vnode.$name$ = null;\n    }\n    return vnode;\n};\nconst Host = {};\nconst isHost = (node) => node && node.$tag$ === Host;\nconst vdomFnUtils = {\n    forEach: (children, cb) => children.map(convertToPublic).forEach(cb),\n    map: (children, cb) => children.map(convertToPublic).map(cb).map(convertToPrivate),\n};\nconst convertToPublic = (node) => ({\n    vattrs: node.$attrs$,\n    vchildren: node.$children$,\n    vkey: node.$key$,\n    vname: node.$name$,\n    vtag: node.$tag$,\n    vtext: node.$text$,\n});\nconst convertToPrivate = (node) => {\n    if (typeof node.vtag === 'function') {\n        const vnodeData = Object.assign({}, node.vattrs);\n        if (node.vkey) {\n            vnodeData.key = node.vkey;\n        }\n        if (node.vname) {\n            vnodeData.name = node.vname;\n        }\n        return h(node.vtag, vnodeData, ...(node.vchildren || []));\n    }\n    const vnode = newVNode(node.vtag, node.vtext);\n    vnode.$attrs$ = node.vattrs;\n    vnode.$children$ = node.vchildren;\n    vnode.$key$ = node.vkey;\n    vnode.$name$ = node.vname;\n    return vnode;\n};\n/**\n * Validates the ordering of attributes on an input element\n * @param inputElm the element to validate\n */\nconst validateInputProperties = (inputElm) => {\n    const props = Object.keys(inputElm);\n    const value = props.indexOf('value');\n    if (value === -1) {\n        return;\n    }\n    const typeIndex = props.indexOf('type');\n    const minIndex = props.indexOf('min');\n    const maxIndex = props.indexOf('max');\n    const stepIndex = props.indexOf('step');\n    if (value < typeIndex || value < minIndex || value < maxIndex || value < stepIndex) {\n        consoleDevWarn(`The \"value\" prop of <input> should be set after \"min\", \"max\", \"type\" and \"step\"`);\n    }\n};\n/**\n * Production setAccessor() function based on Preact by\n * Jason Miller (@developit)\n * Licensed under the MIT License\n * https://github.com/developit/preact/blob/master/LICENSE\n *\n * Modified for Stencil's compiler and vdom\n */\nconst setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags) => {\n    if (oldValue !== newValue) {\n        let isProp = isMemberInElement(elm, memberName);\n        let ln = memberName.toLowerCase();\n        if (BUILD.vdomClass && memberName === 'class') {\n            const classList = elm.classList;\n            const oldClasses = parseClassList(oldValue);\n            const newClasses = parseClassList(newValue);\n            classList.remove(...oldClasses.filter((c) => c && !newClasses.includes(c)));\n            classList.add(...newClasses.filter((c) => c && !oldClasses.includes(c)));\n        }\n        else if (BUILD.vdomStyle && memberName === 'style') {\n            // update style attribute, css properties and values\n            if (BUILD.updatable) {\n                for (const prop in oldValue) {\n                    if (!newValue || newValue[prop] == null) {\n                        if (!BUILD.hydrateServerSide && prop.includes('-')) {\n                            elm.style.removeProperty(prop);\n                        }\n                        else {\n                            elm.style[prop] = '';\n                        }\n                    }\n                }\n            }\n            for (const prop in newValue) {\n                if (!oldValue || newValue[prop] !== oldValue[prop]) {\n                    if (!BUILD.hydrateServerSide && prop.includes('-')) {\n                        elm.style.setProperty(prop, newValue[prop]);\n                    }\n                    else {\n                        elm.style[prop] = newValue[prop];\n                    }\n                }\n            }\n        }\n        else if (BUILD.vdomKey && memberName === 'key')\n            ;\n        else if (BUILD.vdomRef && memberName === 'ref') {\n            // minifier will clean this up\n            if (newValue) {\n                newValue(elm);\n            }\n        }\n        else if (BUILD.vdomListener &&\n            (BUILD.lazyLoad ? !isProp : !elm.__lookupSetter__(memberName)) &&\n            memberName[0] === 'o' &&\n            memberName[1] === 'n') {\n            // Event Handlers\n            // so if the member name starts with \"on\" and the 3rd characters is\n            // a capital letter, and it's not already a member on the element,\n            // then we're assuming it's an event listener\n            if (memberName[2] === '-') {\n                // on- prefixed events\n                // allows to be explicit about the dom event to listen without any magic\n                // under the hood:\n                // <my-cmp on-click> // listens for \"click\"\n                // <my-cmp on-Click> // listens for \"Click\"\n                // <my-cmp on-ionChange> // listens for \"ionChange\"\n                // <my-cmp on-EVENTS> // listens for \"EVENTS\"\n                memberName = memberName.slice(3);\n            }\n            else if (isMemberInElement(win, ln)) {\n                // standard event\n                // the JSX attribute could have been \"onMouseOver\" and the\n                // member name \"onmouseover\" is on the window's prototype\n                // so let's add the listener \"mouseover\", which is all lowercased\n                memberName = ln.slice(2);\n            }\n            else {\n                // custom event\n                // the JSX attribute could have been \"onMyCustomEvent\"\n                // so let's trim off the \"on\" prefix and lowercase the first character\n                // and add the listener \"myCustomEvent\"\n                // except for the first character, we keep the event name case\n                memberName = ln[2] + memberName.slice(3);\n            }\n            if (oldValue) {\n                plt.rel(elm, memberName, oldValue, false);\n            }\n            if (newValue) {\n                plt.ael(elm, memberName, newValue, false);\n            }\n        }\n        else if (BUILD.vdomPropOrAttr) {\n            // Set property if it exists and it's not a SVG\n            const isComplex = isComplexType(newValue);\n            if ((isProp || (isComplex && newValue !== null)) && !isSvg) {\n                try {\n                    if (!elm.tagName.includes('-')) {\n                        const n = newValue == null ? '' : newValue;\n                        // Workaround for Safari, moving the <input> caret when re-assigning the same valued\n                        if (memberName === 'list') {\n                            isProp = false;\n                        }\n                        else if (oldValue == null || elm[memberName] != n) {\n                            elm[memberName] = n;\n                        }\n                    }\n                    else {\n                        elm[memberName] = newValue;\n                    }\n                }\n                catch (e) { }\n            }\n            /**\n             * Need to manually update attribute if:\n             * - memberName is not an attribute\n             * - if we are rendering the host element in order to reflect attribute\n             * - if it's a SVG, since properties might not work in <svg>\n             * - if the newValue is null/undefined or 'false'.\n             */\n            let xlink = false;\n            if (BUILD.vdomXlink) {\n                if (ln !== (ln = ln.replace(/^xlink\\:?/, ''))) {\n                    memberName = ln;\n                    xlink = true;\n                }\n            }\n            if (newValue == null || newValue === false) {\n                if (newValue !== false || elm.getAttribute(memberName) === '') {\n                    if (BUILD.vdomXlink && xlink) {\n                        elm.removeAttributeNS(XLINK_NS, memberName);\n                    }\n                    else {\n                        elm.removeAttribute(memberName);\n                    }\n                }\n            }\n            else if ((!isProp || flags & 4 /* isHost */ || isSvg) && !isComplex) {\n                newValue = newValue === true ? '' : newValue;\n                if (BUILD.vdomXlink && xlink) {\n                    elm.setAttributeNS(XLINK_NS, memberName, newValue);\n                }\n                else {\n                    elm.setAttribute(memberName, newValue);\n                }\n            }\n        }\n    }\n};\nconst parseClassListRegex = /\\s/;\nconst parseClassList = (value) => (!value ? [] : value.split(parseClassListRegex));\nconst updateElement = (oldVnode, newVnode, isSvgMode, memberName) => {\n    // if the element passed in is a shadow root, which is a document fragment\n    // then we want to be adding attrs/props to the shadow root's \"host\" element\n    // if it's not a shadow root, then we add attrs/props to the same element\n    const elm = newVnode.$elm$.nodeType === 11 /* DocumentFragment */ && newVnode.$elm$.host\n        ? newVnode.$elm$.host\n        : newVnode.$elm$;\n    const oldVnodeAttrs = (oldVnode && oldVnode.$attrs$) || EMPTY_OBJ;\n    const newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;\n    if (BUILD.updatable) {\n        // remove attributes no longer present on the vnode by setting them to undefined\n        for (memberName in oldVnodeAttrs) {\n            if (!(memberName in newVnodeAttrs)) {\n                setAccessor(elm, memberName, oldVnodeAttrs[memberName], undefined, isSvgMode, newVnode.$flags$);\n            }\n        }\n    }\n    // add new & update changed attributes\n    for (memberName in newVnodeAttrs) {\n        setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode, newVnode.$flags$);\n    }\n};\nconst createElm = (oldParentVNode, newParentVNode, childIndex, parentElm) => {\n    // tslint:disable-next-line: prefer-const\n    const newVNode = newParentVNode.$children$[childIndex];\n    let i = 0;\n    let elm;\n    let childNode;\n    let oldVNode;\n    if (BUILD.slotRelocation && !useNativeShadowDom) {\n        // remember for later we need to check to relocate nodes\n        checkSlotRelocate = true;\n        if (newVNode.$tag$ === 'slot') {\n            if (scopeId) {\n                // scoped css needs to add its scoped id to the parent element\n                parentElm.classList.add(scopeId + '-s');\n            }\n            newVNode.$flags$ |= newVNode.$children$\n                ? // slot element has fallback content\n                    2 /* isSlotFallback */\n                : // slot element does not have fallback content\n                    1 /* isSlotReference */;\n        }\n    }\n    if (BUILD.isDev && newVNode.$elm$) {\n        consoleDevError(`The JSX ${newVNode.$text$ !== null ? `\"${newVNode.$text$}\" text` : `\"${newVNode.$tag$}\" element`} node should not be shared within the same renderer. The renderer caches element lookups in order to improve performance. However, a side effect from this is that the exact same JSX node should not be reused. For more information please see https://stenciljs.com/docs/templating-jsx#avoid-shared-jsx-nodes`);\n    }\n    if (BUILD.vdomText && newVNode.$text$ !== null) {\n        // create text node\n        elm = newVNode.$elm$ = doc.createTextNode(newVNode.$text$);\n    }\n    else if (BUILD.slotRelocation && newVNode.$flags$ & 1 /* isSlotReference */) {\n        // create a slot reference node\n        elm = newVNode.$elm$ =\n            BUILD.isDebug || BUILD.hydrateServerSide ? slotReferenceDebugNode(newVNode) : doc.createTextNode('');\n    }\n    else {\n        if (BUILD.svg && !isSvgMode) {\n            isSvgMode = newVNode.$tag$ === 'svg';\n        }\n        // create element\n        elm = newVNode.$elm$ = (BUILD.svg\n            ? doc.createElementNS(isSvgMode ? SVG_NS : HTML_NS, BUILD.slotRelocation && newVNode.$flags$ & 2 /* isSlotFallback */\n                ? 'slot-fb'\n                : newVNode.$tag$)\n            : doc.createElement(BUILD.slotRelocation && newVNode.$flags$ & 2 /* isSlotFallback */\n                ? 'slot-fb'\n                : newVNode.$tag$));\n        if (BUILD.svg && isSvgMode && newVNode.$tag$ === 'foreignObject') {\n            isSvgMode = false;\n        }\n        // add css classes, attrs, props, listeners, etc.\n        if (BUILD.vdomAttribute) {\n            updateElement(null, newVNode, isSvgMode);\n        }\n        if ((BUILD.shadowDom || BUILD.scoped) && isDef(scopeId) && elm['s-si'] !== scopeId) {\n            // if there is a scopeId and this is the initial render\n            // then let's add the scopeId as a css class\n            elm.classList.add((elm['s-si'] = scopeId));\n        }\n        if (newVNode.$children$) {\n            for (i = 0; i < newVNode.$children$.length; ++i) {\n                // create the node\n                childNode = createElm(oldParentVNode, newVNode, i, elm);\n                // return node could have been null\n                if (childNode) {\n                    // append our new node\n                    elm.appendChild(childNode);\n                }\n            }\n        }\n        if (BUILD.svg) {\n            if (newVNode.$tag$ === 'svg') {\n                // Only reset the SVG context when we're exiting <svg> element\n                isSvgMode = false;\n            }\n            else if (elm.tagName === 'foreignObject') {\n                // Reenter SVG context when we're exiting <foreignObject> element\n                isSvgMode = true;\n            }\n        }\n    }\n    if (BUILD.slotRelocation) {\n        elm['s-hn'] = hostTagName;\n        if (newVNode.$flags$ & (2 /* isSlotFallback */ | 1 /* isSlotReference */)) {\n            // remember the content reference comment\n            elm['s-sr'] = true;\n            // remember the content reference comment\n            elm['s-cr'] = contentRef;\n            // remember the slot name, or empty string for default slot\n            elm['s-sn'] = newVNode.$name$ || '';\n            // check if we've got an old vnode for this slot\n            oldVNode = oldParentVNode && oldParentVNode.$children$ && oldParentVNode.$children$[childIndex];\n            if (oldVNode && oldVNode.$tag$ === newVNode.$tag$ && oldParentVNode.$elm$) {\n                // we've got an old slot vnode and the wrapper is being replaced\n                // so let's move the old slot content back to it's original location\n                putBackInOriginalLocation(oldParentVNode.$elm$, false);\n            }\n        }\n    }\n    return elm;\n};\nconst putBackInOriginalLocation = (parentElm, recursive) => {\n    plt.$flags$ |= 1 /* isTmpDisconnected */;\n    const oldSlotChildNodes = parentElm.childNodes;\n    for (let i = oldSlotChildNodes.length - 1; i >= 0; i--) {\n        const childNode = oldSlotChildNodes[i];\n        if (childNode['s-hn'] !== hostTagName && childNode['s-ol']) {\n            // // this child node in the old element is from another component\n            // // remove this node from the old slot's parent\n            // childNode.remove();\n            // and relocate it back to it's original location\n            parentReferenceNode(childNode).insertBefore(childNode, referenceNode(childNode));\n            // remove the old original location comment entirely\n            // later on the patch function will know what to do\n            // and move this to the correct spot in need be\n            childNode['s-ol'].remove();\n            childNode['s-ol'] = undefined;\n            checkSlotRelocate = true;\n        }\n        if (recursive) {\n            putBackInOriginalLocation(childNode, recursive);\n        }\n    }\n    plt.$flags$ &= ~1 /* isTmpDisconnected */;\n};\nconst addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {\n    let containerElm = ((BUILD.slotRelocation && parentElm['s-cr'] && parentElm['s-cr'].parentNode) || parentElm);\n    let childNode;\n    if (BUILD.shadowDom && containerElm.shadowRoot && containerElm.tagName === hostTagName) {\n        containerElm = containerElm.shadowRoot;\n    }\n    for (; startIdx <= endIdx; ++startIdx) {\n        if (vnodes[startIdx]) {\n            childNode = createElm(null, parentVNode, startIdx, parentElm);\n            if (childNode) {\n                vnodes[startIdx].$elm$ = childNode;\n                containerElm.insertBefore(childNode, BUILD.slotRelocation ? referenceNode(before) : before);\n            }\n        }\n    }\n};\nconst removeVnodes = (vnodes, startIdx, endIdx, vnode, elm) => {\n    for (; startIdx <= endIdx; ++startIdx) {\n        if ((vnode = vnodes[startIdx])) {\n            elm = vnode.$elm$;\n            callNodeRefs(vnode);\n            if (BUILD.slotRelocation) {\n                // we're removing this element\n                // so it's possible we need to show slot fallback content now\n                checkSlotFallbackVisibility = true;\n                if (elm['s-ol']) {\n                    // remove the original location comment\n                    elm['s-ol'].remove();\n                }\n                else {\n                    // it's possible that child nodes of the node\n                    // that's being removed are slot nodes\n                    putBackInOriginalLocation(elm, true);\n                }\n            }\n            // remove the vnode's element from the dom\n            elm.remove();\n        }\n    }\n};\nconst updateChildren = (parentElm, oldCh, newVNode, newCh) => {\n    let oldStartIdx = 0;\n    let newStartIdx = 0;\n    let idxInOld = 0;\n    let i = 0;\n    let oldEndIdx = oldCh.length - 1;\n    let oldStartVnode = oldCh[0];\n    let oldEndVnode = oldCh[oldEndIdx];\n    let newEndIdx = newCh.length - 1;\n    let newStartVnode = newCh[0];\n    let newEndVnode = newCh[newEndIdx];\n    let node;\n    let elmToMove;\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n        if (oldStartVnode == null) {\n            // Vnode might have been moved left\n            oldStartVnode = oldCh[++oldStartIdx];\n        }\n        else if (oldEndVnode == null) {\n            oldEndVnode = oldCh[--oldEndIdx];\n        }\n        else if (newStartVnode == null) {\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else if (newEndVnode == null) {\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (isSameVnode(oldStartVnode, newStartVnode)) {\n            patch(oldStartVnode, newStartVnode);\n            oldStartVnode = oldCh[++oldStartIdx];\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else if (isSameVnode(oldEndVnode, newEndVnode)) {\n            patch(oldEndVnode, newEndVnode);\n            oldEndVnode = oldCh[--oldEndIdx];\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (isSameVnode(oldStartVnode, newEndVnode)) {\n            // Vnode moved right\n            if (BUILD.slotRelocation && (oldStartVnode.$tag$ === 'slot' || newEndVnode.$tag$ === 'slot')) {\n                putBackInOriginalLocation(oldStartVnode.$elm$.parentNode, false);\n            }\n            patch(oldStartVnode, newEndVnode);\n            parentElm.insertBefore(oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);\n            oldStartVnode = oldCh[++oldStartIdx];\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (isSameVnode(oldEndVnode, newStartVnode)) {\n            // Vnode moved left\n            if (BUILD.slotRelocation && (oldStartVnode.$tag$ === 'slot' || newEndVnode.$tag$ === 'slot')) {\n                putBackInOriginalLocation(oldEndVnode.$elm$.parentNode, false);\n            }\n            patch(oldEndVnode, newStartVnode);\n            parentElm.insertBefore(oldEndVnode.$elm$, oldStartVnode.$elm$);\n            oldEndVnode = oldCh[--oldEndIdx];\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else {\n            // createKeyToOldIdx\n            idxInOld = -1;\n            if (BUILD.vdomKey) {\n                for (i = oldStartIdx; i <= oldEndIdx; ++i) {\n                    if (oldCh[i] && oldCh[i].$key$ !== null && oldCh[i].$key$ === newStartVnode.$key$) {\n                        idxInOld = i;\n                        break;\n                    }\n                }\n            }\n            if (BUILD.vdomKey && idxInOld >= 0) {\n                elmToMove = oldCh[idxInOld];\n                if (elmToMove.$tag$ !== newStartVnode.$tag$) {\n                    node = createElm(oldCh && oldCh[newStartIdx], newVNode, idxInOld, parentElm);\n                }\n                else {\n                    patch(elmToMove, newStartVnode);\n                    oldCh[idxInOld] = undefined;\n                    node = elmToMove.$elm$;\n                }\n                newStartVnode = newCh[++newStartIdx];\n            }\n            else {\n                // new element\n                node = createElm(oldCh && oldCh[newStartIdx], newVNode, newStartIdx, parentElm);\n                newStartVnode = newCh[++newStartIdx];\n            }\n            if (node) {\n                if (BUILD.slotRelocation) {\n                    parentReferenceNode(oldStartVnode.$elm$).insertBefore(node, referenceNode(oldStartVnode.$elm$));\n                }\n                else {\n                    oldStartVnode.$elm$.parentNode.insertBefore(node, oldStartVnode.$elm$);\n                }\n            }\n        }\n    }\n    if (oldStartIdx > oldEndIdx) {\n        addVnodes(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode, newCh, newStartIdx, newEndIdx);\n    }\n    else if (BUILD.updatable && newStartIdx > newEndIdx) {\n        removeVnodes(oldCh, oldStartIdx, oldEndIdx);\n    }\n};\nconst isSameVnode = (vnode1, vnode2) => {\n    // compare if two vnode to see if they're \"technically\" the same\n    // need to have the same element tag, and same key to be the same\n    if (vnode1.$tag$ === vnode2.$tag$) {\n        if (BUILD.slotRelocation && vnode1.$tag$ === 'slot') {\n            return vnode1.$name$ === vnode2.$name$;\n        }\n        if (BUILD.vdomKey) {\n            return vnode1.$key$ === vnode2.$key$;\n        }\n        return true;\n    }\n    return false;\n};\nconst referenceNode = (node) => {\n    // this node was relocated to a new location in the dom\n    // because of some other component's slot\n    // but we still have an html comment in place of where\n    // it's original location was according to it's original vdom\n    return (node && node['s-ol']) || node;\n};\nconst parentReferenceNode = (node) => (node['s-ol'] ? node['s-ol'] : node).parentNode;\nconst patch = (oldVNode, newVNode) => {\n    const elm = (newVNode.$elm$ = oldVNode.$elm$);\n    const oldChildren = oldVNode.$children$;\n    const newChildren = newVNode.$children$;\n    const tag = newVNode.$tag$;\n    const text = newVNode.$text$;\n    let defaultHolder;\n    if (!BUILD.vdomText || text === null) {\n        if (BUILD.svg) {\n            // test if we're rendering an svg element, or still rendering nodes inside of one\n            // only add this to the when the compiler sees we're using an svg somewhere\n            isSvgMode = tag === 'svg' ? true : tag === 'foreignObject' ? false : isSvgMode;\n        }\n        // element node\n        if (BUILD.vdomAttribute || BUILD.reflect) {\n            if (BUILD.slot && tag === 'slot')\n                ;\n            else {\n                // either this is the first render of an element OR it's an update\n                // AND we already know it's possible it could have changed\n                // this updates the element's css classes, attrs, props, listeners, etc.\n                updateElement(oldVNode, newVNode, isSvgMode);\n            }\n        }\n        if (BUILD.updatable && oldChildren !== null && newChildren !== null) {\n            // looks like there's child vnodes for both the old and new vnodes\n            updateChildren(elm, oldChildren, newVNode, newChildren);\n        }\n        else if (newChildren !== null) {\n            // no old child vnodes, but there are new child vnodes to add\n            if (BUILD.updatable && BUILD.vdomText && oldVNode.$text$ !== null) {\n                // the old vnode was text, so be sure to clear it out\n                elm.textContent = '';\n            }\n            // add the new vnode children\n            addVnodes(elm, null, newVNode, newChildren, 0, newChildren.length - 1);\n        }\n        else if (BUILD.updatable && oldChildren !== null) {\n            // no new child vnodes, but there are old child vnodes to remove\n            removeVnodes(oldChildren, 0, oldChildren.length - 1);\n        }\n        if (BUILD.svg && isSvgMode && tag === 'svg') {\n            isSvgMode = false;\n        }\n    }\n    else if (BUILD.vdomText && BUILD.slotRelocation && (defaultHolder = elm['s-cr'])) {\n        // this element has slotted content\n        defaultHolder.parentNode.textContent = text;\n    }\n    else if (BUILD.vdomText && oldVNode.$text$ !== text) {\n        // update the text content for the text only vnode\n        // and also only if the text is different than before\n        elm.data = text;\n    }\n};\nconst updateFallbackSlotVisibility = (elm) => {\n    // tslint:disable-next-line: prefer-const\n    const childNodes = elm.childNodes;\n    let childNode;\n    let i;\n    let ilen;\n    let j;\n    let slotNameAttr;\n    let nodeType;\n    for (i = 0, ilen = childNodes.length; i < ilen; i++) {\n        childNode = childNodes[i];\n        if (childNode.nodeType === 1 /* ElementNode */) {\n            if (childNode['s-sr']) {\n                // this is a slot fallback node\n                // get the slot name for this slot reference node\n                slotNameAttr = childNode['s-sn'];\n                // by default always show a fallback slot node\n                // then hide it if there are other slots in the light dom\n                childNode.hidden = false;\n                for (j = 0; j < ilen; j++) {\n                    nodeType = childNodes[j].nodeType;\n                    if (childNodes[j]['s-hn'] !== childNode['s-hn'] || slotNameAttr !== '') {\n                        // this sibling node is from a different component OR is a named fallback slot node\n                        if (nodeType === 1 /* ElementNode */ && slotNameAttr === childNodes[j].getAttribute('slot')) {\n                            childNode.hidden = true;\n                            break;\n                        }\n                    }\n                    else {\n                        // this is a default fallback slot node\n                        // any element or text node (with content)\n                        // should hide the default fallback slot node\n                        if (nodeType === 1 /* ElementNode */ ||\n                            (nodeType === 3 /* TextNode */ && childNodes[j].textContent.trim() !== '')) {\n                            childNode.hidden = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            // keep drilling down\n            updateFallbackSlotVisibility(childNode);\n        }\n    }\n};\nconst relocateNodes = [];\nconst relocateSlotContent = (elm) => {\n    // tslint:disable-next-line: prefer-const\n    let childNode;\n    let node;\n    let hostContentNodes;\n    let slotNameAttr;\n    let relocateNodeData;\n    let j;\n    let i = 0;\n    const childNodes = elm.childNodes;\n    const ilen = childNodes.length;\n    for (; i < ilen; i++) {\n        childNode = childNodes[i];\n        if (childNode['s-sr'] && (node = childNode['s-cr']) && node.parentNode) {\n            // first got the content reference comment node\n            // then we got it's parent, which is where all the host content is in now\n            hostContentNodes = node.parentNode.childNodes;\n            slotNameAttr = childNode['s-sn'];\n            for (j = hostContentNodes.length - 1; j >= 0; j--) {\n                node = hostContentNodes[j];\n                if (!node['s-cn'] && !node['s-nr'] && node['s-hn'] !== childNode['s-hn']) {\n                    // let's do some relocating to its new home\n                    // but never relocate a content reference node\n                    // that is suppose to always represent the original content location\n                    if (isNodeLocatedInSlot(node, slotNameAttr)) {\n                        // it's possible we've already decided to relocate this node\n                        relocateNodeData = relocateNodes.find((r) => r.$nodeToRelocate$ === node);\n                        // made some changes to slots\n                        // let's make sure we also double check\n                        // fallbacks are correctly hidden or shown\n                        checkSlotFallbackVisibility = true;\n                        node['s-sn'] = node['s-sn'] || slotNameAttr;\n                        if (relocateNodeData) {\n                            // previously we never found a slot home for this node\n                            // but turns out we did, so let's remember it now\n                            relocateNodeData.$slotRefNode$ = childNode;\n                        }\n                        else {\n                            // add to our list of nodes to relocate\n                            relocateNodes.push({\n                                $slotRefNode$: childNode,\n                                $nodeToRelocate$: node,\n                            });\n                        }\n                        if (node['s-sr']) {\n                            relocateNodes.map((relocateNode) => {\n                                if (isNodeLocatedInSlot(relocateNode.$nodeToRelocate$, node['s-sn'])) {\n                                    relocateNodeData = relocateNodes.find((r) => r.$nodeToRelocate$ === node);\n                                    if (relocateNodeData && !relocateNode.$slotRefNode$) {\n                                        relocateNode.$slotRefNode$ = relocateNodeData.$slotRefNode$;\n                                    }\n                                }\n                            });\n                        }\n                    }\n                    else if (!relocateNodes.some((r) => r.$nodeToRelocate$ === node)) {\n                        // so far this element does not have a slot home, not setting slotRefNode on purpose\n                        // if we never find a home for this element then we'll need to hide it\n                        relocateNodes.push({\n                            $nodeToRelocate$: node,\n                        });\n                    }\n                }\n            }\n        }\n        if (childNode.nodeType === 1 /* ElementNode */) {\n            relocateSlotContent(childNode);\n        }\n    }\n};\nconst isNodeLocatedInSlot = (nodeToRelocate, slotNameAttr) => {\n    if (nodeToRelocate.nodeType === 1 /* ElementNode */) {\n        if (nodeToRelocate.getAttribute('slot') === null && slotNameAttr === '') {\n            return true;\n        }\n        if (nodeToRelocate.getAttribute('slot') === slotNameAttr) {\n            return true;\n        }\n        return false;\n    }\n    if (nodeToRelocate['s-sn'] === slotNameAttr) {\n        return true;\n    }\n    return slotNameAttr === '';\n};\nconst callNodeRefs = (vNode) => {\n    if (BUILD.vdomRef) {\n        vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);\n        vNode.$children$ && vNode.$children$.map(callNodeRefs);\n    }\n};\nconst renderVdom = (hostRef, renderFnResults) => {\n    const hostElm = hostRef.$hostElement$;\n    const cmpMeta = hostRef.$cmpMeta$;\n    const oldVNode = hostRef.$vnode$ || newVNode(null, null);\n    const rootVnode = isHost(renderFnResults) ? renderFnResults : h(null, null, renderFnResults);\n    hostTagName = hostElm.tagName;\n    // <Host> runtime check\n    if (BUILD.isDev && Array.isArray(renderFnResults) && renderFnResults.some(isHost)) {\n        throw new Error(`The <Host> must be the single root component.\nLooks like the render() function of \"${hostTagName.toLowerCase()}\" is returning an array that contains the <Host>.\n\nThe render() function should look like this instead:\n\nrender() {\n  // Do not return an array\n  return (\n    <Host>{content}</Host>\n  );\n}\n  `);\n    }\n    if (BUILD.reflect && cmpMeta.$attrsToReflect$) {\n        rootVnode.$attrs$ = rootVnode.$attrs$ || {};\n        cmpMeta.$attrsToReflect$.map(([propName, attribute]) => (rootVnode.$attrs$[attribute] = hostElm[propName]));\n    }\n    rootVnode.$tag$ = null;\n    rootVnode.$flags$ |= 4 /* isHost */;\n    hostRef.$vnode$ = rootVnode;\n    rootVnode.$elm$ = oldVNode.$elm$ = (BUILD.shadowDom ? hostElm.shadowRoot || hostElm : hostElm);\n    if (BUILD.scoped || BUILD.shadowDom) {\n        scopeId = hostElm['s-sc'];\n    }\n    if (BUILD.slotRelocation) {\n        contentRef = hostElm['s-cr'];\n        useNativeShadowDom = supportsShadow && (cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) !== 0;\n        // always reset\n        checkSlotFallbackVisibility = false;\n    }\n    // synchronous patch\n    patch(oldVNode, rootVnode);\n    if (BUILD.slotRelocation) {\n        // while we're moving nodes around existing nodes, temporarily disable\n        // the disconnectCallback from working\n        plt.$flags$ |= 1 /* isTmpDisconnected */;\n        if (checkSlotRelocate) {\n            relocateSlotContent(rootVnode.$elm$);\n            let relocateData;\n            let nodeToRelocate;\n            let orgLocationNode;\n            let parentNodeRef;\n            let insertBeforeNode;\n            let refNode;\n            let i = 0;\n            for (; i < relocateNodes.length; i++) {\n                relocateData = relocateNodes[i];\n                nodeToRelocate = relocateData.$nodeToRelocate$;\n                if (!nodeToRelocate['s-ol']) {\n                    // add a reference node marking this node's original location\n                    // keep a reference to this node for later lookups\n                    orgLocationNode =\n                        BUILD.isDebug || BUILD.hydrateServerSide\n                            ? originalLocationDebugNode(nodeToRelocate)\n                            : doc.createTextNode('');\n                    orgLocationNode['s-nr'] = nodeToRelocate;\n                    nodeToRelocate.parentNode.insertBefore((nodeToRelocate['s-ol'] = orgLocationNode), nodeToRelocate);\n                }\n            }\n            for (i = 0; i < relocateNodes.length; i++) {\n                relocateData = relocateNodes[i];\n                nodeToRelocate = relocateData.$nodeToRelocate$;\n                if (relocateData.$slotRefNode$) {\n                    // by default we're just going to insert it directly\n                    // after the slot reference node\n                    parentNodeRef = relocateData.$slotRefNode$.parentNode;\n                    insertBeforeNode = relocateData.$slotRefNode$.nextSibling;\n                    orgLocationNode = nodeToRelocate['s-ol'];\n                    while ((orgLocationNode = orgLocationNode.previousSibling)) {\n                        refNode = orgLocationNode['s-nr'];\n                        if (refNode && refNode['s-sn'] === nodeToRelocate['s-sn'] && parentNodeRef === refNode.parentNode) {\n                            refNode = refNode.nextSibling;\n                            if (!refNode || !refNode['s-nr']) {\n                                insertBeforeNode = refNode;\n                                break;\n                            }\n                        }\n                    }\n                    if ((!insertBeforeNode && parentNodeRef !== nodeToRelocate.parentNode) ||\n                        nodeToRelocate.nextSibling !== insertBeforeNode) {\n                        // we've checked that it's worth while to relocate\n                        // since that the node to relocate\n                        // has a different next sibling or parent relocated\n                        if (nodeToRelocate !== insertBeforeNode) {\n                            if (!nodeToRelocate['s-hn'] && nodeToRelocate['s-ol']) {\n                                // probably a component in the index.html that doesn't have it's hostname set\n                                nodeToRelocate['s-hn'] = nodeToRelocate['s-ol'].parentNode.nodeName;\n                            }\n                            // add it back to the dom but in its new home\n                            parentNodeRef.insertBefore(nodeToRelocate, insertBeforeNode);\n                        }\n                    }\n                }\n                else {\n                    // this node doesn't have a slot home to go to, so let's hide it\n                    if (nodeToRelocate.nodeType === 1 /* ElementNode */) {\n                        nodeToRelocate.hidden = true;\n                    }\n                }\n            }\n        }\n        if (checkSlotFallbackVisibility) {\n            updateFallbackSlotVisibility(rootVnode.$elm$);\n        }\n        // done moving nodes around\n        // allow the disconnect callback to work again\n        plt.$flags$ &= ~1 /* isTmpDisconnected */;\n        // always reset\n        relocateNodes.length = 0;\n    }\n};\n// slot comment debug nodes only created with the `--debug` flag\n// otherwise these nodes are text nodes w/out content\nconst slotReferenceDebugNode = (slotVNode) => doc.createComment(`<slot${slotVNode.$name$ ? ' name=\"' + slotVNode.$name$ + '\"' : ''}> (host=${hostTagName.toLowerCase()})`);\nconst originalLocationDebugNode = (nodeToRelocate) => doc.createComment(`org-location for ` +\n    (nodeToRelocate.localName\n        ? `<${nodeToRelocate.localName}> (host=${nodeToRelocate['s-hn']})`\n        : `[${nodeToRelocate.textContent}]`));\nconst getElement = (ref) => (BUILD.lazyLoad ? getHostRef(ref).$hostElement$ : ref);\nconst createEvent = (ref, name, flags) => {\n    const elm = getElement(ref);\n    return {\n        emit: (detail) => {\n            if (BUILD.isDev && !elm.isConnected) {\n                consoleDevWarn(`The \"${name}\" event was emitted, but the dispatcher node is no longer connected to the dom.`);\n            }\n            return emitEvent(elm, name, {\n                bubbles: !!(flags & 4 /* Bubbles */),\n                composed: !!(flags & 2 /* Composed */),\n                cancelable: !!(flags & 1 /* Cancellable */),\n                detail,\n            });\n        },\n    };\n};\n/**\n * Helper function to create & dispatch a custom Event on a provided target\n * @param elm the target of the Event\n * @param name the name to give the custom Event\n * @param opts options for configuring a custom Event\n * @returns the custom Event\n */\nconst emitEvent = (elm, name, opts) => {\n    const ev = plt.ce(name, opts);\n    elm.dispatchEvent(ev);\n    return ev;\n};\nconst attachToAncestor = (hostRef, ancestorComponent) => {\n    if (BUILD.asyncLoading && ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent['s-p']) {\n        ancestorComponent['s-p'].push(new Promise((r) => (hostRef.$onRenderResolve$ = r)));\n    }\n};\nconst scheduleUpdate = (hostRef, isInitialLoad) => {\n    if (BUILD.taskQueue && BUILD.updatable) {\n        hostRef.$flags$ |= 16 /* isQueuedForUpdate */;\n    }\n    if (BUILD.asyncLoading && hostRef.$flags$ & 4 /* isWaitingForChildren */) {\n        hostRef.$flags$ |= 512 /* needsRerender */;\n        return;\n    }\n    attachToAncestor(hostRef, hostRef.$ancestorComponent$);\n    // there is no ancestor component or the ancestor component\n    // has already fired off its lifecycle update then\n    // fire off the initial update\n    const dispatch = () => dispatchHooks(hostRef, isInitialLoad);\n    return BUILD.taskQueue ? writeTask(dispatch) : dispatch();\n};\nconst dispatchHooks = (hostRef, isInitialLoad) => {\n    const elm = hostRef.$hostElement$;\n    const endSchedule = createTime('scheduleUpdate', hostRef.$cmpMeta$.$tagName$);\n    const instance = BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\n    let promise;\n    if (isInitialLoad) {\n        if (BUILD.lazyLoad && BUILD.hostListener) {\n            hostRef.$flags$ |= 256 /* isListenReady */;\n            if (hostRef.$queuedListeners$) {\n                hostRef.$queuedListeners$.map(([methodName, event]) => safeCall(instance, methodName, event));\n                hostRef.$queuedListeners$ = null;\n            }\n        }\n        emitLifecycleEvent(elm, 'componentWillLoad');\n        if (BUILD.cmpWillLoad) {\n            promise = safeCall(instance, 'componentWillLoad');\n        }\n    }\n    else {\n        emitLifecycleEvent(elm, 'componentWillUpdate');\n        if (BUILD.cmpWillUpdate) {\n            promise = safeCall(instance, 'componentWillUpdate');\n        }\n    }\n    emitLifecycleEvent(elm, 'componentWillRender');\n    if (BUILD.cmpWillRender) {\n        promise = then(promise, () => safeCall(instance, 'componentWillRender'));\n    }\n    endSchedule();\n    return then(promise, () => updateComponent(hostRef, instance, isInitialLoad));\n};\nconst updateComponent = async (hostRef, instance, isInitialLoad) => {\n    // updateComponent\n    const elm = hostRef.$hostElement$;\n    const endUpdate = createTime('update', hostRef.$cmpMeta$.$tagName$);\n    const rc = elm['s-rc'];\n    if (BUILD.style && isInitialLoad) {\n        // DOM WRITE!\n        attachStyles(hostRef);\n    }\n    const endRender = createTime('render', hostRef.$cmpMeta$.$tagName$);\n    if (BUILD.isDev) {\n        hostRef.$flags$ |= 1024 /* devOnRender */;\n    }\n    if (BUILD.hydrateServerSide) {\n        await callRender(hostRef, instance, elm);\n    }\n    else {\n        callRender(hostRef, instance, elm);\n    }\n    if (BUILD.cssVarShim && plt.$cssShim$) {\n        plt.$cssShim$.updateHost(elm);\n    }\n    if (BUILD.isDev) {\n        hostRef.$renderCount$++;\n        hostRef.$flags$ &= ~1024 /* devOnRender */;\n    }\n    if (BUILD.hydrateServerSide) {\n        try {\n            // manually connected child components during server-side hydrate\n            serverSideConnected(elm);\n            if (isInitialLoad) {\n                // using only during server-side hydrate\n                if (hostRef.$cmpMeta$.$flags$ & 1 /* shadowDomEncapsulation */) {\n                    elm['s-en'] = '';\n                }\n                else if (hostRef.$cmpMeta$.$flags$ & 2 /* scopedCssEncapsulation */) {\n                    elm['s-en'] = 'c';\n                }\n            }\n        }\n        catch (e) {\n            consoleError(e, elm);\n        }\n    }\n    if (BUILD.asyncLoading && rc) {\n        // ok, so turns out there are some child host elements\n        // waiting on this parent element to load\n        // let's fire off all update callbacks waiting\n        rc.map((cb) => cb());\n        elm['s-rc'] = undefined;\n    }\n    endRender();\n    endUpdate();\n    if (BUILD.asyncLoading) {\n        const childrenPromises = elm['s-p'];\n        const postUpdate = () => postUpdateComponent(hostRef);\n        if (childrenPromises.length === 0) {\n            postUpdate();\n        }\n        else {\n            Promise.all(childrenPromises).then(postUpdate);\n            hostRef.$flags$ |= 4 /* isWaitingForChildren */;\n            childrenPromises.length = 0;\n        }\n    }\n    else {\n        postUpdateComponent(hostRef);\n    }\n};\nconst callRender = (hostRef, instance, elm) => {\n    // in order for bundlers to correctly treeshake the BUILD object\n    // we need to ensure BUILD is not deoptimized within a try/catch\n    // https://rollupjs.org/guide/en/#treeshake tryCatchDeoptimization\n    const allRenderFn = BUILD.allRenderFn ? true : false;\n    const lazyLoad = BUILD.lazyLoad ? true : false;\n    const taskQueue = BUILD.taskQueue ? true : false;\n    const updatable = BUILD.updatable ? true : false;\n    try {\n        renderingRef = instance;\n        instance = allRenderFn ? instance.render() : instance.render && instance.render();\n        if (updatable && taskQueue) {\n            hostRef.$flags$ &= ~16 /* isQueuedForUpdate */;\n        }\n        if (updatable || lazyLoad) {\n            hostRef.$flags$ |= 2 /* hasRendered */;\n        }\n        if (BUILD.hasRenderFn || BUILD.reflect) {\n            if (BUILD.vdomRender || BUILD.reflect) {\n                // looks like we've got child nodes to render into this host element\n                // or we need to update the css class/attrs on the host element\n                // DOM WRITE!\n                if (BUILD.hydrateServerSide) {\n                    return Promise.resolve(instance).then((value) => renderVdom(hostRef, value));\n                }\n                else {\n                    renderVdom(hostRef, instance);\n                }\n            }\n            else {\n                elm.textContent = instance;\n            }\n        }\n    }\n    catch (e) {\n        consoleError(e, hostRef.$hostElement$);\n    }\n    renderingRef = null;\n    return null;\n};\nconst getRenderingRef = () => renderingRef;\nconst postUpdateComponent = (hostRef) => {\n    const tagName = hostRef.$cmpMeta$.$tagName$;\n    const elm = hostRef.$hostElement$;\n    const endPostUpdate = createTime('postUpdate', tagName);\n    const instance = BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\n    const ancestorComponent = hostRef.$ancestorComponent$;\n    if (BUILD.cmpDidRender) {\n        if (BUILD.isDev) {\n            hostRef.$flags$ |= 1024 /* devOnRender */;\n        }\n        safeCall(instance, 'componentDidRender');\n        if (BUILD.isDev) {\n            hostRef.$flags$ &= ~1024 /* devOnRender */;\n        }\n    }\n    emitLifecycleEvent(elm, 'componentDidRender');\n    if (!(hostRef.$flags$ & 64 /* hasLoadedComponent */)) {\n        hostRef.$flags$ |= 64 /* hasLoadedComponent */;\n        if (BUILD.asyncLoading && BUILD.cssAnnotations) {\n            // DOM WRITE!\n            addHydratedFlag(elm);\n        }\n        if (BUILD.cmpDidLoad) {\n            if (BUILD.isDev) {\n                hostRef.$flags$ |= 2048 /* devOnDidLoad */;\n            }\n            safeCall(instance, 'componentDidLoad');\n            if (BUILD.isDev) {\n                hostRef.$flags$ &= ~2048 /* devOnDidLoad */;\n            }\n        }\n        emitLifecycleEvent(elm, 'componentDidLoad');\n        endPostUpdate();\n        if (BUILD.asyncLoading) {\n            hostRef.$onReadyResolve$(elm);\n            if (!ancestorComponent) {\n                appDidLoad(tagName);\n            }\n        }\n    }\n    else {\n        if (BUILD.cmpDidUpdate) {\n            // we've already loaded this component\n            // fire off the user's componentDidUpdate method (if one was provided)\n            // componentDidUpdate runs AFTER render() has been called\n            // and all child components have finished updating\n            if (BUILD.isDev) {\n                hostRef.$flags$ |= 1024 /* devOnRender */;\n            }\n            safeCall(instance, 'componentDidUpdate');\n            if (BUILD.isDev) {\n                hostRef.$flags$ &= ~1024 /* devOnRender */;\n            }\n        }\n        emitLifecycleEvent(elm, 'componentDidUpdate');\n        endPostUpdate();\n    }\n    if (BUILD.hotModuleReplacement) {\n        elm['s-hmr-load'] && elm['s-hmr-load']();\n    }\n    if (BUILD.method && BUILD.lazyLoad) {\n        hostRef.$onInstanceResolve$(elm);\n    }\n    // load events fire from bottom to top\n    // the deepest elements load first then bubbles up\n    if (BUILD.asyncLoading) {\n        if (hostRef.$onRenderResolve$) {\n            hostRef.$onRenderResolve$();\n            hostRef.$onRenderResolve$ = undefined;\n        }\n        if (hostRef.$flags$ & 512 /* needsRerender */) {\n            nextTick(() => scheduleUpdate(hostRef, false));\n        }\n        hostRef.$flags$ &= ~(4 /* isWaitingForChildren */ | 512 /* needsRerender */);\n    }\n    // ( _)\n    // ( _)>-\n    // (_)\n};\nconst forceUpdate = (ref) => {\n    if (BUILD.updatable) {\n        const hostRef = getHostRef(ref);\n        const isConnected = hostRef.$hostElement$.isConnected;\n        if (isConnected &&\n            (hostRef.$flags$ & (2 /* hasRendered */ | 16 /* isQueuedForUpdate */)) === 2 /* hasRendered */) {\n            scheduleUpdate(hostRef, false);\n        }\n        // Returns \"true\" when the forced update was successfully scheduled\n        return isConnected;\n    }\n    return false;\n};\nconst appDidLoad = (who) => {\n    // on appload\n    // we have finish the first big initial render\n    if (BUILD.cssAnnotations) {\n        addHydratedFlag(doc.documentElement);\n    }\n    if (BUILD.asyncQueue) {\n        plt.$flags$ |= 2 /* appLoaded */;\n    }\n    nextTick(() => emitEvent(win, 'appload', { detail: { namespace: NAMESPACE } }));\n    if (BUILD.profile && performance.measure) {\n        performance.measure(`[Stencil] ${NAMESPACE} initial load (by ${who})`, 'st:app:start');\n    }\n};\nconst safeCall = (instance, method, arg) => {\n    if (instance && instance[method]) {\n        try {\n            return instance[method](arg);\n        }\n        catch (e) {\n            consoleError(e);\n        }\n    }\n    return undefined;\n};\nconst then = (promise, thenFn) => {\n    return promise && promise.then ? promise.then(thenFn) : thenFn();\n};\nconst emitLifecycleEvent = (elm, lifecycleName) => {\n    if (BUILD.lifecycleDOMEvents) {\n        emitEvent(elm, 'stencil_' + lifecycleName, {\n            bubbles: true,\n            composed: true,\n            detail: {\n                namespace: NAMESPACE,\n            },\n        });\n    }\n};\nconst addHydratedFlag = (elm) => BUILD.hydratedClass\n    ? elm.classList.add('hydrated')\n    : BUILD.hydratedAttribute\n        ? elm.setAttribute('hydrated', '')\n        : undefined;\nconst serverSideConnected = (elm) => {\n    const children = elm.children;\n    if (children != null) {\n        for (let i = 0, ii = children.length; i < ii; i++) {\n            const childElm = children[i];\n            if (typeof childElm.connectedCallback === 'function') {\n                childElm.connectedCallback();\n            }\n            serverSideConnected(childElm);\n        }\n    }\n};\nconst initializeClientHydrate = (hostElm, tagName, hostId, hostRef) => {\n    const endHydrate = createTime('hydrateClient', tagName);\n    const shadowRoot = hostElm.shadowRoot;\n    const childRenderNodes = [];\n    const slotNodes = [];\n    const shadowRootNodes = BUILD.shadowDom && shadowRoot ? [] : null;\n    const vnode = (hostRef.$vnode$ = newVNode(tagName, null));\n    if (!plt.$orgLocNodes$) {\n        initializeDocumentHydrate(doc.body, (plt.$orgLocNodes$ = new Map()));\n    }\n    hostElm[HYDRATE_ID] = hostId;\n    hostElm.removeAttribute(HYDRATE_ID);\n    clientHydrate(vnode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, hostElm, hostId);\n    childRenderNodes.map((c) => {\n        const orgLocationId = c.$hostId$ + '.' + c.$nodeId$;\n        const orgLocationNode = plt.$orgLocNodes$.get(orgLocationId);\n        const node = c.$elm$;\n        if (orgLocationNode && supportsShadow && orgLocationNode['s-en'] === '') {\n            orgLocationNode.parentNode.insertBefore(node, orgLocationNode.nextSibling);\n        }\n        if (!shadowRoot) {\n            node['s-hn'] = tagName;\n            if (orgLocationNode) {\n                node['s-ol'] = orgLocationNode;\n                node['s-ol']['s-nr'] = node;\n            }\n        }\n        plt.$orgLocNodes$.delete(orgLocationId);\n    });\n    if (BUILD.shadowDom && shadowRoot) {\n        shadowRootNodes.map((shadowRootNode) => {\n            if (shadowRootNode) {\n                shadowRoot.appendChild(shadowRootNode);\n            }\n        });\n    }\n    endHydrate();\n};\nconst clientHydrate = (parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node, hostId) => {\n    let childNodeType;\n    let childIdSplt;\n    let childVNode;\n    let i;\n    if (node.nodeType === 1 /* ElementNode */) {\n        childNodeType = node.getAttribute(HYDRATE_CHILD_ID);\n        if (childNodeType) {\n            // got the node data from the element's attribute\n            // `${hostId}.${nodeId}.${depth}.${index}`\n            childIdSplt = childNodeType.split('.');\n            if (childIdSplt[0] === hostId || childIdSplt[0] === '0') {\n                childVNode = {\n                    $flags$: 0,\n                    $hostId$: childIdSplt[0],\n                    $nodeId$: childIdSplt[1],\n                    $depth$: childIdSplt[2],\n                    $index$: childIdSplt[3],\n                    $tag$: node.tagName.toLowerCase(),\n                    $elm$: node,\n                    $attrs$: null,\n                    $children$: null,\n                    $key$: null,\n                    $name$: null,\n                    $text$: null,\n                };\n                childRenderNodes.push(childVNode);\n                node.removeAttribute(HYDRATE_CHILD_ID);\n                // this is a new child vnode\n                // so ensure its parent vnode has the vchildren array\n                if (!parentVNode.$children$) {\n                    parentVNode.$children$ = [];\n                }\n                // add our child vnode to a specific index of the vnode's children\n                parentVNode.$children$[childVNode.$index$] = childVNode;\n                // this is now the new parent vnode for all the next child checks\n                parentVNode = childVNode;\n                if (shadowRootNodes && childVNode.$depth$ === '0') {\n                    shadowRootNodes[childVNode.$index$] = childVNode.$elm$;\n                }\n            }\n        }\n        // recursively drill down, end to start so we can remove nodes\n        for (i = node.childNodes.length - 1; i >= 0; i--) {\n            clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node.childNodes[i], hostId);\n        }\n        if (node.shadowRoot) {\n            // keep drilling down through the shadow root nodes\n            for (i = node.shadowRoot.childNodes.length - 1; i >= 0; i--) {\n                clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node.shadowRoot.childNodes[i], hostId);\n            }\n        }\n    }\n    else if (node.nodeType === 8 /* CommentNode */) {\n        // `${COMMENT_TYPE}.${hostId}.${nodeId}.${depth}.${index}`\n        childIdSplt = node.nodeValue.split('.');\n        if (childIdSplt[1] === hostId || childIdSplt[1] === '0') {\n            // comment node for either the host id or a 0 host id\n            childNodeType = childIdSplt[0];\n            childVNode = {\n                $flags$: 0,\n                $hostId$: childIdSplt[1],\n                $nodeId$: childIdSplt[2],\n                $depth$: childIdSplt[3],\n                $index$: childIdSplt[4],\n                $elm$: node,\n                $attrs$: null,\n                $children$: null,\n                $key$: null,\n                $name$: null,\n                $tag$: null,\n                $text$: null,\n            };\n            if (childNodeType === TEXT_NODE_ID) {\n                childVNode.$elm$ = node.nextSibling;\n                if (childVNode.$elm$ && childVNode.$elm$.nodeType === 3 /* TextNode */) {\n                    childVNode.$text$ = childVNode.$elm$.textContent;\n                    childRenderNodes.push(childVNode);\n                    // remove the text comment since it's no longer needed\n                    node.remove();\n                    if (!parentVNode.$children$) {\n                        parentVNode.$children$ = [];\n                    }\n                    parentVNode.$children$[childVNode.$index$] = childVNode;\n                    if (shadowRootNodes && childVNode.$depth$ === '0') {\n                        shadowRootNodes[childVNode.$index$] = childVNode.$elm$;\n                    }\n                }\n            }\n            else if (childVNode.$hostId$ === hostId) {\n                // this comment node is specifcally for this host id\n                if (childNodeType === SLOT_NODE_ID) {\n                    // `${SLOT_NODE_ID}.${hostId}.${nodeId}.${depth}.${index}.${slotName}`;\n                    childVNode.$tag$ = 'slot';\n                    if (childIdSplt[5]) {\n                        node['s-sn'] = childVNode.$name$ = childIdSplt[5];\n                    }\n                    else {\n                        node['s-sn'] = '';\n                    }\n                    node['s-sr'] = true;\n                    if (BUILD.shadowDom && shadowRootNodes) {\n                        // browser support shadowRoot and this is a shadow dom component\n                        // create an actual slot element\n                        childVNode.$elm$ = doc.createElement(childVNode.$tag$);\n                        if (childVNode.$name$) {\n                            // add the slot name attribute\n                            childVNode.$elm$.setAttribute('name', childVNode.$name$);\n                        }\n                        // insert the new slot element before the slot comment\n                        node.parentNode.insertBefore(childVNode.$elm$, node);\n                        // remove the slot comment since it's not needed for shadow\n                        node.remove();\n                        if (childVNode.$depth$ === '0') {\n                            shadowRootNodes[childVNode.$index$] = childVNode.$elm$;\n                        }\n                    }\n                    slotNodes.push(childVNode);\n                    if (!parentVNode.$children$) {\n                        parentVNode.$children$ = [];\n                    }\n                    parentVNode.$children$[childVNode.$index$] = childVNode;\n                }\n                else if (childNodeType === CONTENT_REF_ID) {\n                    // `${CONTENT_REF_ID}.${hostId}`;\n                    if (BUILD.shadowDom && shadowRootNodes) {\n                        // remove the content ref comment since it's not needed for shadow\n                        node.remove();\n                    }\n                    else if (BUILD.slotRelocation) {\n                        hostElm['s-cr'] = node;\n                        node['s-cn'] = true;\n                    }\n                }\n            }\n        }\n    }\n    else if (parentVNode && parentVNode.$tag$ === 'style') {\n        const vnode = newVNode(null, node.textContent);\n        vnode.$elm$ = node;\n        vnode.$index$ = '0';\n        parentVNode.$children$ = [vnode];\n    }\n};\nconst initializeDocumentHydrate = (node, orgLocNodes) => {\n    if (node.nodeType === 1 /* ElementNode */) {\n        let i = 0;\n        for (; i < node.childNodes.length; i++) {\n            initializeDocumentHydrate(node.childNodes[i], orgLocNodes);\n        }\n        if (node.shadowRoot) {\n            for (i = 0; i < node.shadowRoot.childNodes.length; i++) {\n                initializeDocumentHydrate(node.shadowRoot.childNodes[i], orgLocNodes);\n            }\n        }\n    }\n    else if (node.nodeType === 8 /* CommentNode */) {\n        const childIdSplt = node.nodeValue.split('.');\n        if (childIdSplt[0] === ORG_LOCATION_ID) {\n            orgLocNodes.set(childIdSplt[1] + '.' + childIdSplt[2], node);\n            node.nodeValue = '';\n            // useful to know if the original location is\n            // the root light-dom of a shadow dom component\n            node['s-en'] = childIdSplt[3];\n        }\n    }\n};\n/**\n * Parse a new property value for a given property type.\n *\n * While the prop value can reasonably be expected to be of `any` type as far as TypeScript's type checker is concerned,\n * it is not safe to assume that the string returned by evaluating `typeof propValue` matches:\n *   1. `any`, the type given to `propValue` in the function signature\n *   2. the type stored from `propType`.\n *\n * This function provides the capability to parse/coerce a property's value to potentially any other JavaScript type.\n *\n * Property values represented in TSX preserve their type information. In the example below, the number 0 is passed to\n * a component. This `propValue` will preserve its type information (`typeof propValue === 'number'`). Note that is\n * based on the type of the value being passed in, not the type declared of the class member decorated with `@Prop`.\n * ```tsx\n * <my-cmp prop-val={0}></my-cmp>\n * ```\n *\n * HTML prop values on the other hand, will always a string\n *\n * @param propValue the new value to coerce to some type\n * @param propType the type of the prop, expressed as a binary number\n * @returns the parsed/coerced value\n */\nconst parsePropertyValue = (propValue, propType) => {\n    // ensure this value is of the correct prop type\n    if (propValue != null && !isComplexType(propValue)) {\n        if (BUILD.propBoolean && propType & 4 /* Boolean */) {\n            // per the HTML spec, any string value means it is a boolean true value\n            // but we'll cheat here and say that the string \"false\" is the boolean false\n            return propValue === 'false' ? false : propValue === '' || !!propValue;\n        }\n        if (BUILD.propNumber && propType & 2 /* Number */) {\n            // force it to be a number\n            return parseFloat(propValue);\n        }\n        if (BUILD.propString && propType & 1 /* String */) {\n            // could have been passed as a number or boolean\n            // but we still want it as a string\n            return String(propValue);\n        }\n        // redundant return here for better minification\n        return propValue;\n    }\n    // not sure exactly what type we want\n    // so no need to change to a different type\n    return propValue;\n};\nconst getValue = (ref, propName) => getHostRef(ref).$instanceValues$.get(propName);\nconst setValue = (ref, propName, newVal, cmpMeta) => {\n    // check our new property value against our internal value\n    const hostRef = getHostRef(ref);\n    const elm = BUILD.lazyLoad ? hostRef.$hostElement$ : ref;\n    const oldVal = hostRef.$instanceValues$.get(propName);\n    const flags = hostRef.$flags$;\n    const instance = BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\n    newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);\n    // explicitly check for NaN on both sides, as `NaN === NaN` is always false\n    const areBothNaN = Number.isNaN(oldVal) && Number.isNaN(newVal);\n    const didValueChange = newVal !== oldVal && !areBothNaN;\n    if ((!BUILD.lazyLoad || !(flags & 8 /* isConstructingInstance */) || oldVal === undefined) && didValueChange) {\n        // gadzooks! the property's value has changed!!\n        // set our new value!\n        hostRef.$instanceValues$.set(propName, newVal);\n        if (BUILD.isDev) {\n            if (hostRef.$flags$ & 1024 /* devOnRender */) {\n                consoleDevWarn(`The state/prop \"${propName}\" changed during rendering. This can potentially lead to infinite-loops and other bugs.`, '\\nElement', elm, '\\nNew value', newVal, '\\nOld value', oldVal);\n            }\n            else if (hostRef.$flags$ & 2048 /* devOnDidLoad */) {\n                consoleDevWarn(`The state/prop \"${propName}\" changed during \"componentDidLoad()\", this triggers extra re-renders, try to setup on \"componentWillLoad()\"`, '\\nElement', elm, '\\nNew value', newVal, '\\nOld value', oldVal);\n            }\n        }\n        if (!BUILD.lazyLoad || instance) {\n            // get an array of method names of watch functions to call\n            if (BUILD.watchCallback && cmpMeta.$watchers$ && flags & 128 /* isWatchReady */) {\n                const watchMethods = cmpMeta.$watchers$[propName];\n                if (watchMethods) {\n                    // this instance is watching for when this property changed\n                    watchMethods.map((watchMethodName) => {\n                        try {\n                            // fire off each of the watch methods that are watching this property\n                            instance[watchMethodName](newVal, oldVal, propName);\n                        }\n                        catch (e) {\n                            consoleError(e, elm);\n                        }\n                    });\n                }\n            }\n            if (BUILD.updatable &&\n                (flags & (2 /* hasRendered */ | 16 /* isQueuedForUpdate */)) === 2 /* hasRendered */) {\n                if (BUILD.cmpShouldUpdate && instance.componentShouldUpdate) {\n                    if (instance.componentShouldUpdate(newVal, oldVal, propName) === false) {\n                        return;\n                    }\n                }\n                // looks like this value actually changed, so we've got work to do!\n                // but only if we've already rendered, otherwise just chill out\n                // queue that we need to do an update, but don't worry about queuing\n                // up millions cuz this function ensures it only runs once\n                scheduleUpdate(hostRef, false);\n            }\n        }\n    }\n};\nconst proxyComponent = (Cstr, cmpMeta, flags) => {\n    if (BUILD.member && cmpMeta.$members$) {\n        if (BUILD.watchCallback && Cstr.watchers) {\n            cmpMeta.$watchers$ = Cstr.watchers;\n        }\n        // It's better to have a const than two Object.entries()\n        const members = Object.entries(cmpMeta.$members$);\n        const prototype = Cstr.prototype;\n        members.map(([memberName, [memberFlags]]) => {\n            if ((BUILD.prop || BUILD.state) &&\n                (memberFlags & 31 /* Prop */ ||\n                    ((!BUILD.lazyLoad || flags & 2 /* proxyState */) && memberFlags & 32 /* State */))) {\n                // proxyComponent - prop\n                Object.defineProperty(prototype, memberName, {\n                    get() {\n                        // proxyComponent, get value\n                        return getValue(this, memberName);\n                    },\n                    set(newValue) {\n                        // only during dev time\n                        if (BUILD.isDev) {\n                            const ref = getHostRef(this);\n                            if (\n                            // we are proxying the instance (not element)\n                            (flags & 1 /* isElementConstructor */) === 0 &&\n                                // the element is not constructing\n                                (ref.$flags$ & 8 /* isConstructingInstance */) === 0 &&\n                                // the member is a prop\n                                (memberFlags & 31 /* Prop */) !== 0 &&\n                                // the member is not mutable\n                                (memberFlags & 1024 /* Mutable */) === 0) {\n                                consoleDevWarn(`@Prop() \"${memberName}\" on <${cmpMeta.$tagName$}> is immutable but was modified from within the component.\\nMore information: https://stenciljs.com/docs/properties#prop-mutability`);\n                            }\n                        }\n                        // proxyComponent, set value\n                        setValue(this, memberName, newValue, cmpMeta);\n                    },\n                    configurable: true,\n                    enumerable: true,\n                });\n            }\n            else if (BUILD.lazyLoad &&\n                BUILD.method &&\n                flags & 1 /* isElementConstructor */ &&\n                memberFlags & 64 /* Method */) {\n                // proxyComponent - method\n                Object.defineProperty(prototype, memberName, {\n                    value(...args) {\n                        const ref = getHostRef(this);\n                        return ref.$onInstancePromise$.then(() => ref.$lazyInstance$[memberName](...args));\n                    },\n                });\n            }\n        });\n        if (BUILD.observeAttribute && (!BUILD.lazyLoad || flags & 1 /* isElementConstructor */)) {\n            const attrNameToPropName = new Map();\n            prototype.attributeChangedCallback = function (attrName, _oldValue, newValue) {\n                plt.jmp(() => {\n                    const propName = attrNameToPropName.get(attrName);\n                    //  In a web component lifecycle the attributeChangedCallback runs prior to connectedCallback\n                    //  in the case where an attribute was set inline.\n                    //  ```html\n                    //    <my-component some-attribute=\"some-value\"></my-component>\n                    //  ```\n                    //\n                    //  There is an edge case where a developer sets the attribute inline on a custom element and then\n                    //  programmatically changes it before it has been upgraded as shown below:\n                    //\n                    //  ```html\n                    //    <!-- this component has _not_ been upgraded yet -->\n                    //    <my-component id=\"test\" some-attribute=\"some-value\"></my-component>\n                    //    <script>\n                    //      // grab non-upgraded component\n                    //      el = document.querySelector(\"#test\");\n                    //      el.someAttribute = \"another-value\";\n                    //      // upgrade component\n                    //      customElements.define('my-component', MyComponent);\n                    //    </script>\n                    //  ```\n                    //  In this case if we do not unshadow here and use the value of the shadowing property, attributeChangedCallback\n                    //  will be called with `newValue = \"some-value\"` and will set the shadowed property (this.someAttribute = \"another-value\")\n                    //  to the value that was set inline i.e. \"some-value\" from above example. When\n                    //  the connectedCallback attempts to unshadow it will use \"some-value\" as the initial value rather than \"another-value\"\n                    //\n                    //  The case where the attribute was NOT set inline but was not set programmatically shall be handled/unshadowed\n                    //  by connectedCallback as this attributeChangedCallback will not fire.\n                    //\n                    //  https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties\n                    //\n                    //  TODO(STENCIL-16) we should think about whether or not we actually want to be reflecting the attributes to\n                    //  properties here given that this goes against best practices outlined here\n                    //  https://developers.google.com/web/fundamentals/web-components/best-practices#avoid-reentrancy\n                    if (this.hasOwnProperty(propName)) {\n                        newValue = this[propName];\n                        delete this[propName];\n                    }\n                    else if (prototype.hasOwnProperty(propName) &&\n                        typeof this[propName] === 'number' &&\n                        this[propName] == newValue) {\n                        // if the propName exists on the prototype of `Cstr`, this update may be a result of Stencil using native\n                        // APIs to reflect props as attributes. Calls to `setAttribute(someElement, propName)` will result in\n                        // `propName` to be converted to a `DOMString`, which may not be what we want for other primitive props.\n                        return;\n                    }\n                    this[propName] = newValue === null && typeof this[propName] === 'boolean' ? false : newValue;\n                });\n            };\n            // create an array of attributes to observe\n            // and also create a map of html attribute name to js property name\n            Cstr.observedAttributes = members\n                .filter(([_, m]) => m[0] & 15 /* HasAttribute */) // filter to only keep props that should match attributes\n                .map(([propName, m]) => {\n                const attrName = m[1] || propName;\n                attrNameToPropName.set(attrName, propName);\n                if (BUILD.reflect && m[0] & 512 /* ReflectAttr */) {\n                    cmpMeta.$attrsToReflect$.push([propName, attrName]);\n                }\n                return attrName;\n            });\n        }\n    }\n    return Cstr;\n};\nconst initializeComponent = async (elm, hostRef, cmpMeta, hmrVersionId, Cstr) => {\n    // initializeComponent\n    if ((BUILD.lazyLoad || BUILD.hydrateServerSide || BUILD.style) &&\n        (hostRef.$flags$ & 32 /* hasInitializedComponent */) === 0) {\n        if (BUILD.lazyLoad || BUILD.hydrateClientSide) {\n            // we haven't initialized this element yet\n            hostRef.$flags$ |= 32 /* hasInitializedComponent */;\n            // lazy loaded components\n            // request the component's implementation to be\n            // wired up with the host element\n            Cstr = loadModule(cmpMeta, hostRef, hmrVersionId);\n            if (Cstr.then) {\n                // Await creates a micro-task avoid if possible\n                const endLoad = uniqueTime(`st:load:${cmpMeta.$tagName$}:${hostRef.$modeName$}`, `[Stencil] Load module for <${cmpMeta.$tagName$}>`);\n                Cstr = await Cstr;\n                endLoad();\n            }\n            if ((BUILD.isDev || BUILD.isDebug) && !Cstr) {\n                throw new Error(`Constructor for \"${cmpMeta.$tagName$}#${hostRef.$modeName$}\" was not found`);\n            }\n            if (BUILD.member && !Cstr.isProxied) {\n                // we've never proxied this Constructor before\n                // let's add the getters/setters to its prototype before\n                // the first time we create an instance of the implementation\n                if (BUILD.watchCallback) {\n                    cmpMeta.$watchers$ = Cstr.watchers;\n                }\n                proxyComponent(Cstr, cmpMeta, 2 /* proxyState */);\n                Cstr.isProxied = true;\n            }\n            const endNewInstance = createTime('createInstance', cmpMeta.$tagName$);\n            // ok, time to construct the instance\n            // but let's keep track of when we start and stop\n            // so that the getters/setters don't incorrectly step on data\n            if (BUILD.member) {\n                hostRef.$flags$ |= 8 /* isConstructingInstance */;\n            }\n            // construct the lazy-loaded component implementation\n            // passing the hostRef is very important during\n            // construction in order to directly wire together the\n            // host element and the lazy-loaded instance\n            try {\n                new Cstr(hostRef);\n            }\n            catch (e) {\n                consoleError(e);\n            }\n            if (BUILD.member) {\n                hostRef.$flags$ &= ~8 /* isConstructingInstance */;\n            }\n            if (BUILD.watchCallback) {\n                hostRef.$flags$ |= 128 /* isWatchReady */;\n            }\n            endNewInstance();\n            fireConnectedCallback(hostRef.$lazyInstance$);\n        }\n        else {\n            // sync constructor component\n            Cstr = elm.constructor;\n            hostRef.$flags$ |= 32 /* hasInitializedComponent */;\n            // wait for the CustomElementRegistry to mark the component as ready before setting `isWatchReady`. Otherwise,\n            // watchers may fire prematurely if `customElements.get()`/`customElements.whenDefined()` resolves _before_\n            // Stencil has completed instantiating the component.\n            customElements.whenDefined(cmpMeta.$tagName$).then(() => (hostRef.$flags$ |= 128 /* isWatchReady */));\n        }\n        if (BUILD.style && Cstr.style) {\n            // this component has styles but we haven't registered them yet\n            let style = Cstr.style;\n            if (BUILD.mode && typeof style !== 'string') {\n                style = style[(hostRef.$modeName$ = computeMode(elm))];\n                if (BUILD.hydrateServerSide && hostRef.$modeName$) {\n                    elm.setAttribute('s-mode', hostRef.$modeName$);\n                }\n            }\n            const scopeId = getScopeId(cmpMeta, hostRef.$modeName$);\n            if (!styles.has(scopeId)) {\n                const endRegisterStyles = createTime('registerStyles', cmpMeta.$tagName$);\n                if (!BUILD.hydrateServerSide &&\n                    BUILD.shadowDom &&\n                    BUILD.shadowDomShim &&\n                    cmpMeta.$flags$ & 8 /* needsShadowDomShim */) {\n                    style = await import('./shadow-css.js').then((m) => m.scopeCss(style, scopeId, false));\n                }\n                registerStyle(scopeId, style, !!(cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */));\n                endRegisterStyles();\n            }\n        }\n    }\n    // we've successfully created a lazy instance\n    const ancestorComponent = hostRef.$ancestorComponent$;\n    const schedule = () => scheduleUpdate(hostRef, true);\n    if (BUILD.asyncLoading && ancestorComponent && ancestorComponent['s-rc']) {\n        // this is the initial load and this component it has an ancestor component\n        // but the ancestor component has NOT fired its will update lifecycle yet\n        // so let's just cool our jets and wait for the ancestor to continue first\n        // this will get fired off when the ancestor component\n        // finally gets around to rendering its lazy self\n        // fire off the initial update\n        ancestorComponent['s-rc'].push(schedule);\n    }\n    else {\n        schedule();\n    }\n};\nconst fireConnectedCallback = (instance) => {\n    if (BUILD.lazyLoad && BUILD.connectedCallback) {\n        safeCall(instance, 'connectedCallback');\n    }\n};\nconst connectedCallback = (elm) => {\n    if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {\n        const hostRef = getHostRef(elm);\n        const cmpMeta = hostRef.$cmpMeta$;\n        const endConnected = createTime('connectedCallback', cmpMeta.$tagName$);\n        if (BUILD.hostListenerTargetParent) {\n            // only run if we have listeners being attached to a parent\n            addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, true);\n        }\n        if (!(hostRef.$flags$ & 1 /* hasConnected */)) {\n            // first time this component has connected\n            hostRef.$flags$ |= 1 /* hasConnected */;\n            let hostId;\n            if (BUILD.hydrateClientSide) {\n                hostId = elm.getAttribute(HYDRATE_ID);\n                if (hostId) {\n                    if (BUILD.shadowDom && supportsShadow && cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {\n                        const scopeId = BUILD.mode\n                            ? addStyle(elm.shadowRoot, cmpMeta, elm.getAttribute('s-mode'))\n                            : addStyle(elm.shadowRoot, cmpMeta);\n                        elm.classList.remove(scopeId + '-h', scopeId + '-s');\n                    }\n                    initializeClientHydrate(elm, cmpMeta.$tagName$, hostId, hostRef);\n                }\n            }\n            if (BUILD.slotRelocation && !hostId) {\n                // initUpdate\n                // if the slot polyfill is required we'll need to put some nodes\n                // in here to act as original content anchors as we move nodes around\n                // host element has been connected to the DOM\n                if (BUILD.hydrateServerSide ||\n                    ((BUILD.slot || BUILD.shadowDom) &&\n                        cmpMeta.$flags$ & (4 /* hasSlotRelocation */ | 8 /* needsShadowDomShim */))) {\n                    setContentReference(elm);\n                }\n            }\n            if (BUILD.asyncLoading) {\n                // find the first ancestor component (if there is one) and register\n                // this component as one of the actively loading child components for its ancestor\n                let ancestorComponent = elm;\n                while ((ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host)) {\n                    // climb up the ancestors looking for the first\n                    // component that hasn't finished its lifecycle update yet\n                    if ((BUILD.hydrateClientSide &&\n                        ancestorComponent.nodeType === 1 /* ElementNode */ &&\n                        ancestorComponent.hasAttribute('s-id') &&\n                        ancestorComponent['s-p']) ||\n                        ancestorComponent['s-p']) {\n                        // we found this components first ancestor component\n                        // keep a reference to this component's ancestor component\n                        attachToAncestor(hostRef, (hostRef.$ancestorComponent$ = ancestorComponent));\n                        break;\n                    }\n                }\n            }\n            // Lazy properties\n            // https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties\n            if (BUILD.prop && !BUILD.hydrateServerSide && cmpMeta.$members$) {\n                Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]]) => {\n                    if (memberFlags & 31 /* Prop */ && elm.hasOwnProperty(memberName)) {\n                        const value = elm[memberName];\n                        delete elm[memberName];\n                        elm[memberName] = value;\n                    }\n                });\n            }\n            if (BUILD.initializeNextTick) {\n                // connectedCallback, taskQueue, initialLoad\n                // angular sets attribute AFTER connectCallback\n                // https://github.com/angular/angular/issues/18909\n                // https://github.com/angular/angular/issues/19940\n                nextTick(() => initializeComponent(elm, hostRef, cmpMeta));\n            }\n            else {\n                initializeComponent(elm, hostRef, cmpMeta);\n            }\n        }\n        else {\n            // not the first time this has connected\n            // reattach any event listeners to the host\n            // since they would have been removed when disconnected\n            addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, false);\n            // fire off connectedCallback() on component instance\n            fireConnectedCallback(hostRef.$lazyInstance$);\n        }\n        endConnected();\n    }\n};\nconst setContentReference = (elm) => {\n    // only required when we're NOT using native shadow dom (slot)\n    // or this browser doesn't support native shadow dom\n    // and this host element was NOT created with SSR\n    // let's pick out the inner content for slot projection\n    // create a node to represent where the original\n    // content was first placed, which is useful later on\n    const contentRefElm = (elm['s-cr'] = doc.createComment(BUILD.isDebug ? `content-ref (host=${elm.localName})` : ''));\n    contentRefElm['s-cn'] = true;\n    elm.insertBefore(contentRefElm, elm.firstChild);\n};\nconst disconnectedCallback = (elm) => {\n    if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {\n        const hostRef = getHostRef(elm);\n        const instance = BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\n        if (BUILD.hostListener) {\n            if (hostRef.$rmListeners$) {\n                hostRef.$rmListeners$.map((rmListener) => rmListener());\n                hostRef.$rmListeners$ = undefined;\n            }\n        }\n        // clear CSS var-shim tracking\n        if (BUILD.cssVarShim && plt.$cssShim$) {\n            plt.$cssShim$.removeHost(elm);\n        }\n        if (BUILD.lazyLoad && BUILD.disconnectedCallback) {\n            safeCall(instance, 'disconnectedCallback');\n        }\n        if (BUILD.cmpDidUnload) {\n            safeCall(instance, 'componentDidUnload');\n        }\n    }\n};\nconst defineCustomElement = (Cstr, compactMeta) => {\n    customElements.define(compactMeta[1], proxyCustomElement(Cstr, compactMeta));\n};\nconst proxyCustomElement = (Cstr, compactMeta) => {\n    const cmpMeta = {\n        $flags$: compactMeta[0],\n        $tagName$: compactMeta[1],\n    };\n    if (BUILD.member) {\n        cmpMeta.$members$ = compactMeta[2];\n    }\n    if (BUILD.hostListener) {\n        cmpMeta.$listeners$ = compactMeta[3];\n    }\n    if (BUILD.watchCallback) {\n        cmpMeta.$watchers$ = Cstr.$watchers$;\n    }\n    if (BUILD.reflect) {\n        cmpMeta.$attrsToReflect$ = [];\n    }\n    if (BUILD.shadowDom && !supportsShadow && cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {\n        cmpMeta.$flags$ |= 8 /* needsShadowDomShim */;\n    }\n    const originalConnectedCallback = Cstr.prototype.connectedCallback;\n    const originalDisconnectedCallback = Cstr.prototype.disconnectedCallback;\n    Object.assign(Cstr.prototype, {\n        __registerHost() {\n            registerHost(this, cmpMeta);\n        },\n        connectedCallback() {\n            connectedCallback(this);\n            if (BUILD.connectedCallback && originalConnectedCallback) {\n                originalConnectedCallback.call(this);\n            }\n        },\n        disconnectedCallback() {\n            disconnectedCallback(this);\n            if (BUILD.disconnectedCallback && originalDisconnectedCallback) {\n                originalDisconnectedCallback.call(this);\n            }\n        },\n        __attachShadow() {\n            if (supportsShadow) {\n                if (BUILD.shadowDelegatesFocus) {\n                    this.attachShadow({\n                        mode: 'open',\n                        delegatesFocus: !!(cmpMeta.$flags$ & 16 /* shadowDelegatesFocus */),\n                    });\n                }\n                else {\n                    this.attachShadow({ mode: 'open' });\n                }\n            }\n            else {\n                this.shadowRoot = this;\n            }\n        },\n    });\n    Cstr.is = cmpMeta.$tagName$;\n    return proxyComponent(Cstr, cmpMeta, 1 /* isElementConstructor */ | 2 /* proxyState */);\n};\nconst forceModeUpdate = (elm) => {\n    if (BUILD.style && BUILD.mode && !BUILD.lazyLoad) {\n        const mode = computeMode(elm);\n        const hostRef = getHostRef(elm);\n        if (hostRef.$modeName$ !== mode) {\n            const cmpMeta = hostRef.$cmpMeta$;\n            const oldScopeId = elm['s-sc'];\n            const scopeId = getScopeId(cmpMeta, mode);\n            const style = elm.constructor.style[mode];\n            const flags = cmpMeta.$flags$;\n            if (style) {\n                if (!styles.has(scopeId)) {\n                    registerStyle(scopeId, style, !!(flags & 1 /* shadowDomEncapsulation */));\n                }\n                hostRef.$modeName$ = mode;\n                elm.classList.remove(oldScopeId + '-h', oldScopeId + '-s');\n                attachStyles(hostRef);\n                forceUpdate(elm);\n            }\n        }\n    }\n};\nconst hmrStart = (elm, cmpMeta, hmrVersionId) => {\n    // \\_()_/\n    const hostRef = getHostRef(elm);\n    // reset state flags to only have been connected\n    hostRef.$flags$ = 1 /* hasConnected */;\n    // TODO\n    // detatch any event listeners that may have been added\n    // because we're not passing an exact event name it'll\n    // remove all of this element's event, which is good\n    // create a callback for when this component finishes hmr\n    elm['s-hmr-load'] = () => {\n        // finished hmr for this element\n        delete elm['s-hmr-load'];\n    };\n    // re-initialize the component\n    initializeComponent(elm, hostRef, cmpMeta, hmrVersionId);\n};\nconst patchCloneNode = (HostElementPrototype) => {\n    const orgCloneNode = HostElementPrototype.cloneNode;\n    HostElementPrototype.cloneNode = function (deep) {\n        const srcNode = this;\n        const isShadowDom = BUILD.shadowDom ? srcNode.shadowRoot && supportsShadow : false;\n        const clonedNode = orgCloneNode.call(srcNode, isShadowDom ? deep : false);\n        if (BUILD.slot && !isShadowDom && deep) {\n            let i = 0;\n            let slotted, nonStencilNode;\n            const stencilPrivates = [\n                's-id',\n                's-cr',\n                's-lr',\n                's-rc',\n                's-sc',\n                's-p',\n                's-cn',\n                's-sr',\n                's-sn',\n                's-hn',\n                's-ol',\n                's-nr',\n                's-si',\n            ];\n            for (; i < srcNode.childNodes.length; i++) {\n                slotted = srcNode.childNodes[i]['s-nr'];\n                nonStencilNode = stencilPrivates.every((privateField) => !srcNode.childNodes[i][privateField]);\n                if (slotted) {\n                    if (BUILD.appendChildSlotFix && clonedNode.__appendChild) {\n                        clonedNode.__appendChild(slotted.cloneNode(true));\n                    }\n                    else {\n                        clonedNode.appendChild(slotted.cloneNode(true));\n                    }\n                }\n                if (nonStencilNode) {\n                    clonedNode.appendChild(srcNode.childNodes[i].cloneNode(true));\n                }\n            }\n        }\n        return clonedNode;\n    };\n};\nconst patchSlotAppendChild = (HostElementPrototype) => {\n    HostElementPrototype.__appendChild = HostElementPrototype.appendChild;\n    HostElementPrototype.appendChild = function (newChild) {\n        const slotName = (newChild['s-sn'] = getSlotName(newChild));\n        const slotNode = getHostSlotNode(this.childNodes, slotName);\n        if (slotNode) {\n            const slotChildNodes = getHostSlotChildNodes(slotNode, slotName);\n            const appendAfter = slotChildNodes[slotChildNodes.length - 1];\n            return appendAfter.parentNode.insertBefore(newChild, appendAfter.nextSibling);\n        }\n        return this.__appendChild(newChild);\n    };\n};\n/**\n * Patches the text content of an unnamed slotted node inside a scoped component\n * @param hostElementPrototype the `Element` to be patched\n * @param cmpMeta component runtime metadata used to determine if the component should be patched or not\n */\nconst patchTextContent = (hostElementPrototype, cmpMeta) => {\n    if (BUILD.scoped && cmpMeta.$flags$ & 2 /* scopedCssEncapsulation */) {\n        const descriptor = Object.getOwnPropertyDescriptor(Node.prototype, 'textContent');\n        Object.defineProperty(hostElementPrototype, '__textContent', descriptor);\n        Object.defineProperty(hostElementPrototype, 'textContent', {\n            get() {\n                var _a;\n                // get the 'default slot', which would be the first slot in a shadow tree (if we were using one), whose name is\n                // the empty string\n                const slotNode = getHostSlotNode(this.childNodes, '');\n                // when a slot node is found, the textContent _may_ be found in the next sibling (text) node, depending on how\n                // nodes were reordered during the vdom render. first try to get the text content from the sibling.\n                if (((_a = slotNode === null || slotNode === void 0 ? void 0 : slotNode.nextSibling) === null || _a === void 0 ? void 0 : _a.nodeType) === 3 /* TEXT_NODE */) {\n                    return slotNode.nextSibling.textContent;\n                }\n                else if (slotNode) {\n                    return slotNode.textContent;\n                }\n                else {\n                    // fallback to the original implementation\n                    return this.__textContent;\n                }\n            },\n            set(value) {\n                var _a;\n                // get the 'default slot', which would be the first slot in a shadow tree (if we were using one), whose name is\n                // the empty string\n                const slotNode = getHostSlotNode(this.childNodes, '');\n                // when a slot node is found, the textContent _may_ need to be placed in the next sibling (text) node,\n                // depending on how nodes were reordered during the vdom render. first try to set the text content on the\n                // sibling.\n                if (((_a = slotNode === null || slotNode === void 0 ? void 0 : slotNode.nextSibling) === null || _a === void 0 ? void 0 : _a.nodeType) === 3 /* TEXT_NODE */) {\n                    slotNode.nextSibling.textContent = value;\n                }\n                else if (slotNode) {\n                    slotNode.textContent = value;\n                }\n                else {\n                    // we couldn't find a slot, but that doesn't mean that there isn't one. if this check ran before the DOM\n                    // loaded, we could have missed it. check for a content reference element on the scoped component and insert\n                    // it there\n                    this.__textContent = value;\n                    const contentRefElm = this['s-cr'];\n                    if (contentRefElm) {\n                        this.insertBefore(contentRefElm, this.firstChild);\n                    }\n                }\n            },\n        });\n    }\n};\nconst patchChildSlotNodes = (elm, cmpMeta) => {\n    class FakeNodeList extends Array {\n        item(n) {\n            return this[n];\n        }\n    }\n    if (cmpMeta.$flags$ & 8 /* needsShadowDomShim */) {\n        const childNodesFn = elm.__lookupGetter__('childNodes');\n        Object.defineProperty(elm, 'children', {\n            get() {\n                return this.childNodes.map((n) => n.nodeType === 1);\n            },\n        });\n        Object.defineProperty(elm, 'childElementCount', {\n            get() {\n                return elm.children.length;\n            },\n        });\n        Object.defineProperty(elm, 'childNodes', {\n            get() {\n                const childNodes = childNodesFn.call(this);\n                if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0 &&\n                    getHostRef(this).$flags$ & 2 /* hasRendered */) {\n                    const result = new FakeNodeList();\n                    for (let i = 0; i < childNodes.length; i++) {\n                        const slot = childNodes[i]['s-nr'];\n                        if (slot) {\n                            result.push(slot);\n                        }\n                    }\n                    return result;\n                }\n                return FakeNodeList.from(childNodes);\n            },\n        });\n    }\n};\nconst getSlotName = (node) => node['s-sn'] || (node.nodeType === 1 && node.getAttribute('slot')) || '';\n/**\n * Recursively searches a series of child nodes for a slot with the provided name.\n * @param childNodes the nodes to search for a slot with a specific name.\n * @param slotName the name of the slot to match on.\n * @returns a reference to the slot node that matches the provided name, `null` otherwise\n */\nconst getHostSlotNode = (childNodes, slotName) => {\n    let i = 0;\n    let childNode;\n    for (; i < childNodes.length; i++) {\n        childNode = childNodes[i];\n        if (childNode['s-sr'] && childNode['s-sn'] === slotName) {\n            return childNode;\n        }\n        childNode = getHostSlotNode(childNode.childNodes, slotName);\n        if (childNode) {\n            return childNode;\n        }\n    }\n    return null;\n};\nconst getHostSlotChildNodes = (n, slotName) => {\n    const childNodes = [n];\n    while ((n = n.nextSibling) && n['s-sn'] === slotName) {\n        childNodes.push(n);\n    }\n    return childNodes;\n};\nconst bootstrapLazy = (lazyBundles, options = {}) => {\n    if (BUILD.profile && performance.mark) {\n        performance.mark('st:app:start');\n    }\n    installDevTools();\n    const endBootstrap = createTime('bootstrapLazy');\n    const cmpTags = [];\n    const exclude = options.exclude || [];\n    const customElements = win.customElements;\n    const head = doc.head;\n    const metaCharset = /*@__PURE__*/ head.querySelector('meta[charset]');\n    const visibilityStyle = /*@__PURE__*/ doc.createElement('style');\n    const deferredConnectedCallbacks = [];\n    const styles = /*@__PURE__*/ doc.querySelectorAll(`[${HYDRATED_STYLE_ID}]`);\n    let appLoadFallback;\n    let isBootstrapping = true;\n    let i = 0;\n    Object.assign(plt, options);\n    plt.$resourcesUrl$ = new URL(options.resourcesUrl || './', doc.baseURI).href;\n    if (BUILD.asyncQueue) {\n        if (options.syncQueue) {\n            plt.$flags$ |= 4 /* queueSync */;\n        }\n    }\n    if (BUILD.hydrateClientSide) {\n        // If the app is already hydrated there is not point to disable the\n        // async queue. This will improve the first input delay\n        plt.$flags$ |= 2 /* appLoaded */;\n    }\n    if (BUILD.hydrateClientSide && BUILD.shadowDom) {\n        for (; i < styles.length; i++) {\n            registerStyle(styles[i].getAttribute(HYDRATED_STYLE_ID), convertScopedToShadow(styles[i].innerHTML), true);\n        }\n    }\n    lazyBundles.map((lazyBundle) => {\n        lazyBundle[1].map((compactMeta) => {\n            const cmpMeta = {\n                $flags$: compactMeta[0],\n                $tagName$: compactMeta[1],\n                $members$: compactMeta[2],\n                $listeners$: compactMeta[3],\n            };\n            if (BUILD.member) {\n                cmpMeta.$members$ = compactMeta[2];\n            }\n            if (BUILD.hostListener) {\n                cmpMeta.$listeners$ = compactMeta[3];\n            }\n            if (BUILD.reflect) {\n                cmpMeta.$attrsToReflect$ = [];\n            }\n            if (BUILD.watchCallback) {\n                cmpMeta.$watchers$ = {};\n            }\n            if (BUILD.shadowDom && !supportsShadow && cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {\n                cmpMeta.$flags$ |= 8 /* needsShadowDomShim */;\n            }\n            const tagName = BUILD.transformTagName && options.transformTagName\n                ? options.transformTagName(cmpMeta.$tagName$)\n                : cmpMeta.$tagName$;\n            const HostElement = class extends HTMLElement {\n                // StencilLazyHost\n                constructor(self) {\n                    // @ts-ignore\n                    super(self);\n                    self = this;\n                    registerHost(self, cmpMeta);\n                    if (BUILD.shadowDom && cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {\n                        // this component is using shadow dom\n                        // and this browser supports shadow dom\n                        // add the read-only property \"shadowRoot\" to the host element\n                        // adding the shadow root build conditionals to minimize runtime\n                        if (supportsShadow) {\n                            if (BUILD.shadowDelegatesFocus) {\n                                self.attachShadow({\n                                    mode: 'open',\n                                    delegatesFocus: !!(cmpMeta.$flags$ & 16 /* shadowDelegatesFocus */),\n                                });\n                            }\n                            else {\n                                self.attachShadow({ mode: 'open' });\n                            }\n                        }\n                        else if (!BUILD.hydrateServerSide && !('shadowRoot' in self)) {\n                            self.shadowRoot = self;\n                        }\n                    }\n                    if (BUILD.slotChildNodesFix) {\n                        patchChildSlotNodes(self, cmpMeta);\n                    }\n                }\n                connectedCallback() {\n                    if (appLoadFallback) {\n                        clearTimeout(appLoadFallback);\n                        appLoadFallback = null;\n                    }\n                    if (isBootstrapping) {\n                        // connectedCallback will be processed once all components have been registered\n                        deferredConnectedCallbacks.push(this);\n                    }\n                    else {\n                        plt.jmp(() => connectedCallback(this));\n                    }\n                }\n                disconnectedCallback() {\n                    plt.jmp(() => disconnectedCallback(this));\n                }\n                componentOnReady() {\n                    return getHostRef(this).$onReadyPromise$;\n                }\n            };\n            if (BUILD.cloneNodeFix) {\n                patchCloneNode(HostElement.prototype);\n            }\n            if (BUILD.appendChildSlotFix) {\n                patchSlotAppendChild(HostElement.prototype);\n            }\n            if (BUILD.hotModuleReplacement) {\n                HostElement.prototype['s-hmr'] = function (hmrVersionId) {\n                    hmrStart(this, cmpMeta, hmrVersionId);\n                };\n            }\n            if (BUILD.scopedSlotTextContentFix) {\n                patchTextContent(HostElement.prototype, cmpMeta);\n            }\n            cmpMeta.$lazyBundleId$ = lazyBundle[0];\n            if (!exclude.includes(tagName) && !customElements.get(tagName)) {\n                cmpTags.push(tagName);\n                customElements.define(tagName, proxyComponent(HostElement, cmpMeta, 1 /* isElementConstructor */));\n            }\n        });\n    });\n    if (BUILD.invisiblePrehydration && (BUILD.hydratedClass || BUILD.hydratedAttribute)) {\n        visibilityStyle.innerHTML = cmpTags + HYDRATED_CSS;\n        visibilityStyle.setAttribute('data-styles', '');\n        head.insertBefore(visibilityStyle, metaCharset ? metaCharset.nextSibling : head.firstChild);\n    }\n    // Process deferred connectedCallbacks now all components have been registered\n    isBootstrapping = false;\n    if (deferredConnectedCallbacks.length) {\n        deferredConnectedCallbacks.map((host) => host.connectedCallback());\n    }\n    else {\n        if (BUILD.profile) {\n            plt.jmp(() => (appLoadFallback = setTimeout(appDidLoad, 30, 'timeout')));\n        }\n        else {\n            plt.jmp(() => (appLoadFallback = setTimeout(appDidLoad, 30)));\n        }\n    }\n    // Fallback appLoad event\n    endBootstrap();\n};\nconst getAssetPath = (path) => {\n    const assetUrl = new URL(path, plt.$resourcesUrl$);\n    return assetUrl.origin !== win.location.origin ? assetUrl.href : assetUrl.pathname;\n};\nconst setAssetPath = (path) => (plt.$resourcesUrl$ = path);\nconst getConnect = (_ref, tagName) => {\n    const componentOnReady = () => {\n        let elm = doc.querySelector(tagName);\n        if (!elm) {\n            elm = doc.createElement(tagName);\n            doc.body.appendChild(elm);\n        }\n        return typeof elm.componentOnReady === 'function' ? elm.componentOnReady() : Promise.resolve(elm);\n    };\n    const create = (...args) => {\n        return componentOnReady().then((el) => el.create(...args));\n    };\n    return {\n        create,\n        componentOnReady,\n    };\n};\nconst getContext = (_elm, context) => {\n    if (context in Context) {\n        return Context[context];\n    }\n    else if (context === 'window') {\n        return win;\n    }\n    else if (context === 'document') {\n        return doc;\n    }\n    else if (context === 'isServer' || context === 'isPrerender') {\n        return BUILD.hydrateServerSide ? true : false;\n    }\n    else if (context === 'isClient') {\n        return BUILD.hydrateServerSide ? false : true;\n    }\n    else if (context === 'resourcesUrl' || context === 'publicPath') {\n        return getAssetPath('.');\n    }\n    else if (context === 'queue') {\n        return {\n            write: writeTask,\n            read: readTask,\n            tick: {\n                then(cb) {\n                    return nextTick(cb);\n                },\n            },\n        };\n    }\n    return undefined;\n};\nconst insertVdomAnnotations = (doc, staticComponents) => {\n    if (doc != null) {\n        const docData = {\n            hostIds: 0,\n            rootLevelIds: 0,\n            staticComponents: new Set(staticComponents),\n        };\n        const orgLocationNodes = [];\n        parseVNodeAnnotations(doc, doc.body, docData, orgLocationNodes);\n        orgLocationNodes.forEach((orgLocationNode) => {\n            if (orgLocationNode != null) {\n                const nodeRef = orgLocationNode['s-nr'];\n                let hostId = nodeRef['s-host-id'];\n                let nodeId = nodeRef['s-node-id'];\n                let childId = `${hostId}.${nodeId}`;\n                if (hostId == null) {\n                    hostId = 0;\n                    docData.rootLevelIds++;\n                    nodeId = docData.rootLevelIds;\n                    childId = `${hostId}.${nodeId}`;\n                    if (nodeRef.nodeType === 1 /* ElementNode */) {\n                        nodeRef.setAttribute(HYDRATE_CHILD_ID, childId);\n                    }\n                    else if (nodeRef.nodeType === 3 /* TextNode */) {\n                        if (hostId === 0) {\n                            const textContent = nodeRef.nodeValue.trim();\n                            if (textContent === '') {\n                                // useless whitespace node at the document root\n                                orgLocationNode.remove();\n                                return;\n                            }\n                        }\n                        const commentBeforeTextNode = doc.createComment(childId);\n                        commentBeforeTextNode.nodeValue = `${TEXT_NODE_ID}.${childId}`;\n                        nodeRef.parentNode.insertBefore(commentBeforeTextNode, nodeRef);\n                    }\n                }\n                let orgLocationNodeId = `${ORG_LOCATION_ID}.${childId}`;\n                const orgLocationParentNode = orgLocationNode.parentElement;\n                if (orgLocationParentNode) {\n                    if (orgLocationParentNode['s-en'] === '') {\n                        // ending with a \".\" means that the parent element\n                        // of this node's original location is a SHADOW dom element\n                        // and this node is apart of the root level light dom\n                        orgLocationNodeId += `.`;\n                    }\n                    else if (orgLocationParentNode['s-en'] === 'c') {\n                        // ending with a \".c\" means that the parent element\n                        // of this node's original location is a SCOPED element\n                        // and this node is apart of the root level light dom\n                        orgLocationNodeId += `.c`;\n                    }\n                }\n                orgLocationNode.nodeValue = orgLocationNodeId;\n            }\n        });\n    }\n};\nconst parseVNodeAnnotations = (doc, node, docData, orgLocationNodes) => {\n    if (node == null) {\n        return;\n    }\n    if (node['s-nr'] != null) {\n        orgLocationNodes.push(node);\n    }\n    if (node.nodeType === 1 /* ElementNode */) {\n        node.childNodes.forEach((childNode) => {\n            const hostRef = getHostRef(childNode);\n            if (hostRef != null && !docData.staticComponents.has(childNode.nodeName.toLowerCase())) {\n                const cmpData = {\n                    nodeIds: 0,\n                };\n                insertVNodeAnnotations(doc, childNode, hostRef.$vnode$, docData, cmpData);\n            }\n            parseVNodeAnnotations(doc, childNode, docData, orgLocationNodes);\n        });\n    }\n};\nconst insertVNodeAnnotations = (doc, hostElm, vnode, docData, cmpData) => {\n    if (vnode != null) {\n        const hostId = ++docData.hostIds;\n        hostElm.setAttribute(HYDRATE_ID, hostId);\n        if (hostElm['s-cr'] != null) {\n            hostElm['s-cr'].nodeValue = `${CONTENT_REF_ID}.${hostId}`;\n        }\n        if (vnode.$children$ != null) {\n            const depth = 0;\n            vnode.$children$.forEach((vnodeChild, index) => {\n                insertChildVNodeAnnotations(doc, vnodeChild, cmpData, hostId, depth, index);\n            });\n        }\n        if (hostElm && vnode && vnode.$elm$ && !hostElm.hasAttribute('c-id')) {\n            const parent = hostElm.parentElement;\n            if (parent && parent.childNodes) {\n                const parentChildNodes = Array.from(parent.childNodes);\n                const comment = parentChildNodes.find((node) => node.nodeType === 8 /* CommentNode */ && node['s-sr']);\n                if (comment) {\n                    const index = parentChildNodes.indexOf(hostElm) - 1;\n                    vnode.$elm$.setAttribute(HYDRATE_CHILD_ID, `${comment['s-host-id']}.${comment['s-node-id']}.0.${index}`);\n                }\n            }\n        }\n    }\n};\nconst insertChildVNodeAnnotations = (doc, vnodeChild, cmpData, hostId, depth, index) => {\n    const childElm = vnodeChild.$elm$;\n    if (childElm == null) {\n        return;\n    }\n    const nodeId = cmpData.nodeIds++;\n    const childId = `${hostId}.${nodeId}.${depth}.${index}`;\n    childElm['s-host-id'] = hostId;\n    childElm['s-node-id'] = nodeId;\n    if (childElm.nodeType === 1 /* ElementNode */) {\n        childElm.setAttribute(HYDRATE_CHILD_ID, childId);\n    }\n    else if (childElm.nodeType === 3 /* TextNode */) {\n        const parentNode = childElm.parentNode;\n        const nodeName = parentNode.nodeName;\n        if (nodeName !== 'STYLE' && nodeName !== 'SCRIPT') {\n            const textNodeId = `${TEXT_NODE_ID}.${childId}`;\n            const commentBeforeTextNode = doc.createComment(textNodeId);\n            parentNode.insertBefore(commentBeforeTextNode, childElm);\n        }\n    }\n    else if (childElm.nodeType === 8 /* CommentNode */) {\n        if (childElm['s-sr']) {\n            const slotName = childElm['s-sn'] || '';\n            const slotNodeId = `${SLOT_NODE_ID}.${childId}.${slotName}`;\n            childElm.nodeValue = slotNodeId;\n        }\n    }\n    if (vnodeChild.$children$ != null) {\n        const childDepth = depth + 1;\n        vnodeChild.$children$.forEach((vnode, index) => {\n            insertChildVNodeAnnotations(doc, vnode, cmpData, hostId, childDepth, index);\n        });\n    }\n};\nconst setPlatformOptions = (opts) => Object.assign(plt, opts);\nconst Fragment = (_, children) => children;\nconst hostRefs = new WeakMap();\nconst getHostRef = (ref) => hostRefs.get(ref);\nconst registerInstance = (lazyInstance, hostRef) => hostRefs.set((hostRef.$lazyInstance$ = lazyInstance), hostRef);\nconst registerHost = (elm, cmpMeta) => {\n    const hostRef = {\n        $flags$: 0,\n        $hostElement$: elm,\n        $cmpMeta$: cmpMeta,\n        $instanceValues$: new Map(),\n    };\n    if (BUILD.isDev) {\n        hostRef.$renderCount$ = 0;\n    }\n    if (BUILD.method && BUILD.lazyLoad) {\n        hostRef.$onInstancePromise$ = new Promise((r) => (hostRef.$onInstanceResolve$ = r));\n    }\n    if (BUILD.asyncLoading) {\n        hostRef.$onReadyPromise$ = new Promise((r) => (hostRef.$onReadyResolve$ = r));\n        elm['s-p'] = [];\n        elm['s-rc'] = [];\n    }\n    addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, false);\n    return hostRefs.set(elm, hostRef);\n};\nconst isMemberInElement = (elm, memberName) => memberName in elm;\nconst consoleError = (e, el) => (customError || console.error)(e, el);\nconst STENCIL_DEV_MODE = BUILD.isTesting\n    ? ['STENCIL:'] // E2E testing\n    : [\n        '%cstencil',\n        'color: white;background:#4c47ff;font-weight: bold; font-size:10px; padding:2px 6px; border-radius: 5px',\n    ];\nconst consoleDevError = (...m) => console.error(...STENCIL_DEV_MODE, ...m);\nconst consoleDevWarn = (...m) => console.warn(...STENCIL_DEV_MODE, ...m);\nconst consoleDevInfo = (...m) => console.info(...STENCIL_DEV_MODE, ...m);\nconst setErrorHandler = (handler) => (customError = handler);\nconst cmpModules = /*@__PURE__*/ new Map();\nconst loadModule = (cmpMeta, hostRef, hmrVersionId) => {\n    // loadModuleImport\n    const exportName = cmpMeta.$tagName$.replace(/-/g, '_');\n    const bundleId = cmpMeta.$lazyBundleId$;\n    if (BUILD.isDev && typeof bundleId !== 'string') {\n        consoleDevError(`Trying to lazily load component <${cmpMeta.$tagName$}> with style mode \"${hostRef.$modeName$}\", but it does not exist.`);\n        return undefined;\n    }\n    const module = !BUILD.hotModuleReplacement ? cmpModules.get(bundleId) : false;\n    if (module) {\n        return module[exportName];\n    }\n    /*!__STENCIL_STATIC_IMPORT_SWITCH__*/\n    return import(\n    /* @vite-ignore */\n    /* webpackInclude: /\\.entry\\.js$/ */\n    /* webpackExclude: /\\.system\\.entry\\.js$/ */\n    /* webpackMode: \"lazy\" */\n    `./${bundleId}.entry.js${BUILD.hotModuleReplacement && hmrVersionId ? '?s-hmr=' + hmrVersionId : ''}`).then((importedModule) => {\n        if (!BUILD.hotModuleReplacement) {\n            cmpModules.set(bundleId, importedModule);\n        }\n        return importedModule[exportName];\n    }, consoleError);\n};\nconst styles = new Map();\nconst modeResolutionChain = [];\nconst queueDomReads = [];\nconst queueDomWrites = [];\nconst queueDomWritesLow = [];\nconst queueTask = (queue, write) => (cb) => {\n    queue.push(cb);\n    if (!queuePending) {\n        queuePending = true;\n        if (write && plt.$flags$ & 4 /* queueSync */) {\n            nextTick(flush);\n        }\n        else {\n            plt.raf(flush);\n        }\n    }\n};\nconst consume = (queue) => {\n    for (let i = 0; i < queue.length; i++) {\n        try {\n            queue[i](performance.now());\n        }\n        catch (e) {\n            consoleError(e);\n        }\n    }\n    queue.length = 0;\n};\nconst consumeTimeout = (queue, timeout) => {\n    let i = 0;\n    let ts = 0;\n    while (i < queue.length && (ts = performance.now()) < timeout) {\n        try {\n            queue[i++](ts);\n        }\n        catch (e) {\n            consoleError(e);\n        }\n    }\n    if (i === queue.length) {\n        queue.length = 0;\n    }\n    else if (i !== 0) {\n        queue.splice(0, i);\n    }\n};\nconst flush = () => {\n    if (BUILD.asyncQueue) {\n        queueCongestion++;\n    }\n    // always force a bunch of medium callbacks to run, but still have\n    // a throttle on how many can run in a certain time\n    // DOM READS!!!\n    consume(queueDomReads);\n    // DOM WRITES!!!\n    if (BUILD.asyncQueue) {\n        const timeout = (plt.$flags$ & 6 /* queueMask */) === 2 /* appLoaded */\n            ? performance.now() + 14 * Math.ceil(queueCongestion * (1.0 / 10.0))\n            : Infinity;\n        consumeTimeout(queueDomWrites, timeout);\n        consumeTimeout(queueDomWritesLow, timeout);\n        if (queueDomWrites.length > 0) {\n            queueDomWritesLow.push(...queueDomWrites);\n            queueDomWrites.length = 0;\n        }\n        if ((queuePending = queueDomReads.length + queueDomWrites.length + queueDomWritesLow.length > 0)) {\n            // still more to do yet, but we've run out of time\n            // let's let this thing cool off and try again in the next tick\n            plt.raf(flush);\n        }\n        else {\n            queueCongestion = 0;\n        }\n    }\n    else {\n        consume(queueDomWrites);\n        if ((queuePending = queueDomReads.length > 0)) {\n            // still more to do yet, but we've run out of time\n            // let's let this thing cool off and try again in the next tick\n            plt.raf(flush);\n        }\n    }\n};\nconst nextTick = /*@__PURE__*/ (cb) => promiseResolve().then(cb);\nconst readTask = /*@__PURE__*/ queueTask(queueDomReads, false);\nconst writeTask = /*@__PURE__*/ queueTask(queueDomWrites, true);\nconst Build = {\n    isDev: BUILD.isDev ? true : false,\n    isBrowser: true,\n    isServer: false,\n    isTesting: BUILD.isTesting ? true : false,\n};\nexport { BUILD, Env, NAMESPACE } from '@stencil/core/internal/app-data';\nexport { Build, CSS, Context, Fragment, H, H as HTMLElement, Host, STENCIL_DEV_MODE, addHostEventListeners, bootstrapLazy, cmpModules, connectedCallback, consoleDevError, consoleDevInfo, consoleDevWarn, consoleError, createEvent, defineCustomElement, disconnectedCallback, doc, forceModeUpdate, forceUpdate, getAssetPath, getConnect, getContext, getElement, getHostRef, getMode, getRenderingRef, getValue, h, insertVdomAnnotations, isMemberInElement, loadModule, modeResolutionChain, nextTick, parsePropertyValue, plt, postUpdateComponent, promiseResolve, proxyComponent, proxyCustomElement, readTask, registerHost, registerInstance, renderVdom, setAssetPath, setErrorHandler, setMode, setPlatformHelpers, setPlatformOptions, setValue, styles, supportsConstructibleStylesheets, supportsListenerOptions, supportsShadow, win, writeTask };\n", "import { getAssetPath } from '@stencil/core/internal/client';\n\nlet CACHED_MAP;\nconst getIconMap = () => {\n  if (typeof window === 'undefined') {\n    return new Map();\n  }\n  else {\n    if (!CACHED_MAP) {\n      const win = window;\n      win.Ionicons = win.Ionicons || {};\n      CACHED_MAP = win.Ionicons.map = win.Ionicons.map || new Map();\n    }\n    return CACHED_MAP;\n  }\n};\nconst addIcons = (icons) => {\n  const map = getIconMap();\n  Object.keys(icons).forEach(name => map.set(name, icons[name]));\n};\nconst getUrl = (i) => {\n  let url = getSrc(i.src);\n  if (url) {\n    return url;\n  }\n  url = getName(i.name, i.icon, i.mode, i.ios, i.md);\n  if (url) {\n    return getNamedUrl(url);\n  }\n  if (i.icon) {\n    url = getSrc(i.icon);\n    if (url) {\n      return url;\n    }\n    url = getSrc(i.icon[i.mode]);\n    if (url) {\n      return url;\n    }\n  }\n  return null;\n};\nconst getNamedUrl = (iconName) => {\n  const url = getIconMap().get(iconName);\n  if (url) {\n    return url;\n  }\n  return getAssetPath(`svg/${iconName}.svg`);\n};\nconst getName = (iconName, icon, mode, ios, md) => {\n  // default to \"md\" if somehow the mode wasn't set\n  mode = (mode && toLower(mode)) === 'ios' ? 'ios' : 'md';\n  // if an icon was passed in using the ios or md attributes\n  // set the iconName to whatever was passed in\n  if (ios && mode === 'ios') {\n    iconName = toLower(ios);\n  }\n  else if (md && mode === 'md') {\n    iconName = toLower(md);\n  }\n  else {\n    if (!iconName && icon && !isSrc(icon)) {\n      iconName = icon;\n    }\n    if (isStr(iconName)) {\n      iconName = toLower(iconName);\n    }\n  }\n  if (!isStr(iconName) || iconName.trim() === '') {\n    return null;\n  }\n  // only allow alpha characters and dash\n  const invalidChars = iconName.replace(/[a-z]|-|\\d/gi, '');\n  if (invalidChars !== '') {\n    return null;\n  }\n  return iconName;\n};\nconst getSrc = (src) => {\n  if (isStr(src)) {\n    src = src.trim();\n    if (isSrc(src)) {\n      return src;\n    }\n  }\n  return null;\n};\nconst isSrc = (str) => str.length > 0 && /(\\/|\\.)/.test(str);\nconst isStr = (val) => typeof val === 'string';\nconst toLower = (val) => val.toLowerCase();\n/**\n * Elements inside of web components sometimes need to inherit global attributes\n * set on the host. For example, the inner input in `ion-input` should inherit\n * the `title` attribute that developers set directly on `ion-input`. This\n * helper function should be called in componentWillLoad and assigned to a variable\n * that is later used in the render function.\n *\n * This does not need to be reactive as changing attributes on the host element\n * does not trigger a re-render.\n */\nconst inheritAttributes = (el, attributes = []) => {\n  const attributeObject = {};\n  attributes.forEach(attr => {\n    if (el.hasAttribute(attr)) {\n      const value = el.getAttribute(attr);\n      if (value !== null) {\n        attributeObject[attr] = el.getAttribute(attr);\n      }\n      el.removeAttribute(attr);\n    }\n  });\n  return attributeObject;\n};\n\nexport { addIcons as a, inheritAttributes as b, getName as c, getUrl as g, isStr as i };\n", "import { proxyCustomElement, HTMLElement, Build, h, Host } from '@stencil/core/internal/client';\nimport { i as isStr, b as inheritAttributes, g as getUrl, c as getName } from './utils.js';\n\nconst validateContent = (svgContent) => {\n  const div = document.createElement('div');\n  div.innerHTML = svgContent;\n  // setup this way to ensure it works on our buddy IE\n  for (let i = div.childNodes.length - 1; i >= 0; i--) {\n    if (div.childNodes[i].nodeName.toLowerCase() !== 'svg') {\n      div.removeChild(div.childNodes[i]);\n    }\n  }\n  // must only have 1 root element\n  const svgElm = div.firstElementChild;\n  if (svgElm && svgElm.nodeName.toLowerCase() === 'svg') {\n    const svgClass = svgElm.getAttribute('class') || '';\n    svgElm.setAttribute('class', (svgClass + ' s-ion-icon').trim());\n    // root element must be an svg\n    // lets double check we've got valid elements\n    // do not allow scripts\n    if (isValid(svgElm)) {\n      return div.innerHTML;\n    }\n  }\n  return '';\n};\nconst isValid = (elm) => {\n  if (elm.nodeType === 1) {\n    if (elm.nodeName.toLowerCase() === 'script') {\n      return false;\n    }\n    for (let i = 0; i < elm.attributes.length; i++) {\n      const name = elm.attributes[i].name;\n      if (isStr(name) && name.toLowerCase().indexOf('on') === 0) {\n        return false;\n      }\n    }\n    for (let i = 0; i < elm.childNodes.length; i++) {\n      if (!isValid(elm.childNodes[i])) {\n        return false;\n      }\n    }\n  }\n  return true;\n};\n\nconst ioniconContent = new Map();\nconst requests = new Map();\nconst getSvgContent = (url, sanitize) => {\n  // see if we already have a request for this url\n  let req = requests.get(url);\n  if (!req) {\n    if (typeof fetch !== 'undefined' && typeof document !== 'undefined') {\n      // we don't already have a request\n      req = fetch(url).then((rsp) => {\n        if (rsp.ok) {\n          return rsp.text().then((svgContent) => {\n            if (svgContent && sanitize !== false) {\n              svgContent = validateContent(svgContent);\n            }\n            ioniconContent.set(url, svgContent || '');\n          });\n        }\n        ioniconContent.set(url, '');\n      });\n      // cache for the same requests\n      requests.set(url, req);\n    }\n    else {\n      // set to empty for ssr scenarios and resolve promise\n      ioniconContent.set(url, '');\n      return Promise.resolve();\n    }\n  }\n  return req;\n};\n\nconst iconCss = \":host{display:inline-block;width:1em;height:1em;contain:strict;fill:currentColor;-webkit-box-sizing:content-box !important;box-sizing:content-box !important}:host .ionicon{stroke:currentColor}.ionicon-fill-none{fill:none}.ionicon-stroke-width{stroke-width:32px;stroke-width:var(--ionicon-stroke-width, 32px)}.icon-inner,.ionicon,svg{display:block;height:100%;width:100%}:host(.flip-rtl) .icon-inner{-webkit-transform:scaleX(-1);transform:scaleX(-1)}:host(.icon-small){font-size:18px !important}:host(.icon-large){font-size:32px !important}:host(.ion-color){color:var(--ion-color-base) !important}:host(.ion-color-primary){--ion-color-base:var(--ion-color-primary, #3880ff)}:host(.ion-color-secondary){--ion-color-base:var(--ion-color-secondary, #0cd1e8)}:host(.ion-color-tertiary){--ion-color-base:var(--ion-color-tertiary, #f4a942)}:host(.ion-color-success){--ion-color-base:var(--ion-color-success, #10dc60)}:host(.ion-color-warning){--ion-color-base:var(--ion-color-warning, #ffce00)}:host(.ion-color-danger){--ion-color-base:var(--ion-color-danger, #f14141)}:host(.ion-color-light){--ion-color-base:var(--ion-color-light, #f4f5f8)}:host(.ion-color-medium){--ion-color-base:var(--ion-color-medium, #989aa2)}:host(.ion-color-dark){--ion-color-base:var(--ion-color-dark, #222428)}\";\n\nconst Icon = /*@__PURE__*/ proxyCustomElement(class extends HTMLElement {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.__attachShadow();\n    this.iconName = null;\n    this.inheritedAttributes = {};\n    this.isVisible = false;\n    /**\n     * The mode determines which platform styles to use.\n     */\n    this.mode = getIonMode();\n    /**\n     * If enabled, ion-icon will be loaded lazily when it's visible in the viewport.\n     * Default, `false`.\n     */\n    this.lazy = false;\n    /**\n     * When set to `false`, SVG content that is HTTP fetched will not be checked\n     * if the response SVG content has any `<script>` elements, or any attributes\n     * that start with `on`, such as `onclick`.\n     * @default true\n     */\n    this.sanitize = true;\n    this.hasAriaHidden = () => {\n      const { el } = this;\n      return el.hasAttribute('aria-hidden') && el.getAttribute('aria-hidden') === 'true';\n    };\n  }\n  componentWillLoad() {\n    this.inheritedAttributes = inheritAttributes(this.el, ['aria-label']);\n  }\n  connectedCallback() {\n    // purposely do not return the promise here because loading\n    // the svg file should not hold up loading the app\n    // only load the svg if it's visible\n    this.waitUntilVisible(this.el, '50px', () => {\n      this.isVisible = true;\n      this.loadIcon();\n    });\n  }\n  disconnectedCallback() {\n    if (this.io) {\n      this.io.disconnect();\n      this.io = undefined;\n    }\n  }\n  waitUntilVisible(el, rootMargin, cb) {\n    if (Build.isBrowser && this.lazy && typeof window !== 'undefined' && window.IntersectionObserver) {\n      const io = (this.io = new window.IntersectionObserver((data) => {\n        if (data[0].isIntersecting) {\n          io.disconnect();\n          this.io = undefined;\n          cb();\n        }\n      }, { rootMargin }));\n      io.observe(el);\n    }\n    else {\n      // browser doesn't support IntersectionObserver\n      // so just fallback to always show it\n      cb();\n    }\n  }\n  loadIcon() {\n    if (Build.isBrowser && this.isVisible) {\n      const url = getUrl(this);\n      if (url) {\n        if (ioniconContent.has(url)) {\n          // sync if it's already loaded\n          this.svgContent = ioniconContent.get(url);\n        }\n        else {\n          // async if it hasn't been loaded\n          getSvgContent(url, this.sanitize).then(() => (this.svgContent = ioniconContent.get(url)));\n        }\n      }\n    }\n    const label = this.iconName = getName(this.name, this.icon, this.mode, this.ios, this.md);\n    /**\n     * Come up with a default label\n     * in case user does not provide their own.\n     */\n    if (label) {\n      this.ariaLabel = label.replace(/\\-/g, ' ');\n    }\n  }\n  render() {\n    const { iconName, ariaLabel, inheritedAttributes } = this;\n    const mode = this.mode || 'md';\n    const flipRtl = this.flipRtl ||\n      (iconName &&\n        (iconName.indexOf('arrow') > -1 || iconName.indexOf('chevron') > -1) &&\n        this.flipRtl !== false);\n    /**\n     * Only set the aria-label if a) we have generated\n     * one for the icon and if aria-hidden is not set to \"true\".\n     * If developer wants to set their own aria-label, then\n     * inheritedAttributes down below will override whatever\n     * default label we have set.\n     */\n    return (h(Host, Object.assign({ \"aria-label\": ariaLabel !== undefined && !this.hasAriaHidden() ? ariaLabel : null, role: \"img\", class: Object.assign(Object.assign({ [mode]: true }, createColorClasses(this.color)), { [`icon-${this.size}`]: !!this.size, 'flip-rtl': !!flipRtl && this.el.ownerDocument.dir === 'rtl' }) }, inheritedAttributes), Build.isBrowser && this.svgContent ? (h(\"div\", { class: \"icon-inner\", innerHTML: this.svgContent })) : (h(\"div\", { class: \"icon-inner\" }))));\n  }\n  static get assetsDirs() { return [\"svg\"]; }\n  get el() { return this; }\n  static get watchers() { return {\n    \"name\": [\"loadIcon\"],\n    \"src\": [\"loadIcon\"],\n    \"icon\": [\"loadIcon\"]\n  }; }\n  static get style() { return iconCss; }\n}, [1, \"ion-icon\", {\n    \"mode\": [1025],\n    \"color\": [1],\n    \"ios\": [1],\n    \"md\": [1],\n    \"flipRtl\": [4, \"flip-rtl\"],\n    \"name\": [513],\n    \"src\": [1],\n    \"icon\": [8],\n    \"size\": [1],\n    \"lazy\": [4],\n    \"sanitize\": [4],\n    \"svgContent\": [32],\n    \"isVisible\": [32],\n    \"ariaLabel\": [32]\n  }]);\nconst getIonMode = () => (Build.isBrowser && typeof document !== 'undefined' && document.documentElement.getAttribute('mode')) || 'md';\nconst createColorClasses = (color) => {\n  return color\n    ? {\n      'ion-color': true,\n      [`ion-color-${color}`]: true,\n    }\n    : null;\n};\nfunction defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-icon\"];\n  components.forEach(tagName => { switch (tagName) {\n    case \"ion-icon\":\n      if (!customElements.get(tagName)) {\n        customElements.define(tagName, Icon);\n      }\n      break;\n  } });\n}\n\nconst IonIcon = Icon;\nconst defineCustomElement = defineCustomElement$1;\n\nexport { IonIcon, defineCustomElement };\n", "import { defineComponent, getCurrentInstance, h, inject, ref } from 'vue';\nconst UPDATE_VALUE_EVENT = 'update:modelValue';\nconst MODEL_VALUE = 'modelValue';\nconst ROUTER_LINK_VALUE = 'routerLink';\nconst NAV_MANAGER = 'navManager';\nconst ROUTER_PROP_PREFIX = 'router';\n/**\n * Starting in Vue 3.1.0, all properties are\n * added as keys to the props object, even if\n * they are not being used. In order to correctly\n * account for both value props and v-model props,\n * we need to check if the key exists for Vue <3.1.0\n * and then check if it is not undefined for Vue >= 3.1.0.\n * See https://github.com/vuejs/vue-next/issues/3889\n */\nconst EMPTY_PROP = Symbol();\nconst DEFAULT_EMPTY_PROP = { default: EMPTY_PROP };\nconst getComponentClasses = (classes) => {\n    return (classes === null || classes === void 0 ? void 0 : classes.split(' ')) || [];\n};\nconst getElementClasses = (ref, componentClasses, defaultClasses = []) => {\n    var _a;\n    return [...Array.from(((_a = ref.value) === null || _a === void 0 ? void 0 : _a.classList) || []), ...defaultClasses]\n        .filter((c, i, self) => !componentClasses.has(c) && self.indexOf(c) === i);\n};\n/**\n* Create a callback to define a Vue component wrapper around a Web Component.\n*\n* @prop name - The component tag name (i.e. `ion-button`)\n* @prop componentProps - An array of properties on the\n* component. These usually match up with the @Prop definitions\n* in each component's TSX file.\n* @prop customElement - An option custom element instance to pass\n* to customElements.define. Only set if `includeImportCustomElements: true` in your config.\n* @prop modelProp - The prop that v-model binds to (i.e. value)\n* @prop modelUpdateEvent - The event that is fired from your Web Component when the value changes (i.e. ionChange)\n* @prop externalModelUpdateEvent - The external event to fire from your Vue component when modelUpdateEvent fires. This is used for ensuring that v-model references have been\n* correctly updated when a user's event callback fires.\n*/\nexport const defineContainer = (name, defineCustomElement, componentProps = [], modelProp, modelUpdateEvent, externalModelUpdateEvent) => {\n    /**\n    * Create a Vue component wrapper around a Web Component.\n    * Note: The `props` here are not all properties on a component.\n    * They refer to whatever properties are set on an instance of a component.\n    */\n    if (defineCustomElement !== undefined) {\n        defineCustomElement();\n    }\n    const Container = defineComponent((props, { attrs, slots, emit }) => {\n        var _a;\n        let modelPropValue = props[modelProp];\n        const containerRef = ref();\n        const classes = new Set(getComponentClasses(attrs.class));\n        const onVnodeBeforeMount = (vnode) => {\n            // Add a listener to tell Vue to update the v-model\n            if (vnode.el) {\n                const eventsNames = Array.isArray(modelUpdateEvent) ? modelUpdateEvent : [modelUpdateEvent];\n                eventsNames.forEach((eventName) => {\n                    vnode.el.addEventListener(eventName.toLowerCase(), (e) => {\n                        modelPropValue = (e === null || e === void 0 ? void 0 : e.target)[modelProp];\n                        emit(UPDATE_VALUE_EVENT, modelPropValue);\n                        /**\n                         * We need to emit the change event here\n                         * rather than on the web component to ensure\n                         * that any v-model bindings have been updated.\n                         * Otherwise, the developer will listen on the\n                         * native web component, but the v-model will\n                         * not have been updated yet.\n                         */\n                        if (externalModelUpdateEvent) {\n                            emit(externalModelUpdateEvent, e);\n                        }\n                    });\n                });\n            }\n        };\n        const currentInstance = getCurrentInstance();\n        const hasRouter = (_a = currentInstance === null || currentInstance === void 0 ? void 0 : currentInstance.appContext) === null || _a === void 0 ? void 0 : _a.provides[NAV_MANAGER];\n        const navManager = hasRouter ? inject(NAV_MANAGER) : undefined;\n        const handleRouterLink = (ev) => {\n            const { routerLink } = props;\n            if (routerLink === EMPTY_PROP)\n                return;\n            if (navManager !== undefined) {\n                let navigationPayload = { event: ev };\n                for (const key in props) {\n                    const value = props[key];\n                    if (props.hasOwnProperty(key) && key.startsWith(ROUTER_PROP_PREFIX) && value !== EMPTY_PROP) {\n                        navigationPayload[key] = value;\n                    }\n                }\n                navManager.navigate(navigationPayload);\n            }\n            else {\n                console.warn('Tried to navigate, but no router was found. Make sure you have mounted Vue Router.');\n            }\n        };\n        return () => {\n            modelPropValue = props[modelProp];\n            getComponentClasses(attrs.class).forEach(value => {\n                classes.add(value);\n            });\n            const oldClick = props.onClick;\n            const handleClick = (ev) => {\n                if (oldClick !== undefined) {\n                    oldClick(ev);\n                }\n                if (!ev.defaultPrevented) {\n                    handleRouterLink(ev);\n                }\n            };\n            let propsToAdd = {\n                ref: containerRef,\n                class: getElementClasses(containerRef, classes),\n                onClick: handleClick,\n                onVnodeBeforeMount: (modelUpdateEvent) ? onVnodeBeforeMount : undefined\n            };\n            /**\n             * We can use Object.entries here\n             * to avoid the hasOwnProperty check,\n             * but that would require 2 iterations\n             * where as this only requires 1.\n             */\n            for (const key in props) {\n                const value = props[key];\n                if (props.hasOwnProperty(key) && value !== EMPTY_PROP) {\n                    propsToAdd[key] = value;\n                }\n            }\n            if (modelProp) {\n                /**\n                 * If form value property was set using v-model\n                 * then we should use that value.\n                 * Otherwise, check to see if form value property\n                 * was set as a static value (i.e. no v-model).\n                 */\n                if (props[MODEL_VALUE] !== EMPTY_PROP) {\n                    propsToAdd = Object.assign(Object.assign({}, propsToAdd), { [modelProp]: props[MODEL_VALUE] });\n                }\n                else if (modelPropValue !== EMPTY_PROP) {\n                    propsToAdd = Object.assign(Object.assign({}, propsToAdd), { [modelProp]: modelPropValue });\n                }\n            }\n            return h(name, propsToAdd, slots.default && slots.default());\n        };\n    });\n    Container.displayName = name;\n    Container.props = {\n        [ROUTER_LINK_VALUE]: DEFAULT_EMPTY_PROP\n    };\n    componentProps.forEach(componentProp => {\n        Container.props[componentProp] = DEFAULT_EMPTY_PROP;\n    });\n    if (modelProp) {\n        Container.props[MODEL_VALUE] = DEFAULT_EMPTY_PROP;\n        Container.emits = [UPDATE_VALUE_EVENT, externalModelUpdateEvent];\n    }\n    return Container;\n};\n//# sourceMappingURL=utils.js.map", "/* eslint-disable */\n/* tslint:disable */\n/* auto-generated vue proxies */\nimport { defineContainer } from './vue-component-lib/utils';\nimport { defineCustomElement as defineIonAccordion } from '@ionic/core/components/ion-accordion.js';\nimport { defineCustomElement as defineIonAccordionGroup } from '@ionic/core/components/ion-accordion-group.js';\nimport { defineCustomElement as defineIonAvatar } from '@ionic/core/components/ion-avatar.js';\nimport { defineCustomElement as defineIonBackdrop } from '@ionic/core/components/ion-backdrop.js';\nimport { defineCustomElement as defineIonBadge } from '@ionic/core/components/ion-badge.js';\nimport { defineCustomElement as defineIonBreadcrumb } from '@ionic/core/components/ion-breadcrumb.js';\nimport { defineCustomElement as defineIonBreadcrumbs } from '@ionic/core/components/ion-breadcrumbs.js';\nimport { defineCustomElement as defineIonButton } from '@ionic/core/components/ion-button.js';\nimport { defineCustomElement as defineIonButtons } from '@ionic/core/components/ion-buttons.js';\nimport { defineCustomElement as defineIonCard } from '@ionic/core/components/ion-card.js';\nimport { defineCustomElement as defineIonCardContent } from '@ionic/core/components/ion-card-content.js';\nimport { defineCustomElement as defineIonCardHeader } from '@ionic/core/components/ion-card-header.js';\nimport { defineCustomElement as defineIonCardSubtitle } from '@ionic/core/components/ion-card-subtitle.js';\nimport { defineCustomElement as defineIonCardTitle } from '@ionic/core/components/ion-card-title.js';\nimport { defineCustomElement as defineIonCheckbox } from '@ionic/core/components/ion-checkbox.js';\nimport { defineCustomElement as defineIonChip } from '@ionic/core/components/ion-chip.js';\nimport { defineCustomElement as defineIonCol } from '@ionic/core/components/ion-col.js';\nimport { defineCustomElement as defineIonContent } from '@ionic/core/components/ion-content.js';\nimport { defineCustomElement as defineIonDatetime } from '@ionic/core/components/ion-datetime.js';\nimport { defineCustomElement as defineIonDatetimeButton } from '@ionic/core/components/ion-datetime-button.js';\nimport { defineCustomElement as defineIonFab } from '@ionic/core/components/ion-fab.js';\nimport { defineCustomElement as defineIonFabButton } from '@ionic/core/components/ion-fab-button.js';\nimport { defineCustomElement as defineIonFabList } from '@ionic/core/components/ion-fab-list.js';\nimport { defineCustomElement as defineIonFooter } from '@ionic/core/components/ion-footer.js';\nimport { defineCustomElement as defineIonGrid } from '@ionic/core/components/ion-grid.js';\nimport { defineCustomElement as defineIonHeader } from '@ionic/core/components/ion-header.js';\nimport { defineCustomElement as defineIonImg } from '@ionic/core/components/ion-img.js';\nimport { defineCustomElement as defineIonInfiniteScroll } from '@ionic/core/components/ion-infinite-scroll.js';\nimport { defineCustomElement as defineIonInfiniteScrollContent } from '@ionic/core/components/ion-infinite-scroll-content.js';\nimport { defineCustomElement as defineIonInput } from '@ionic/core/components/ion-input.js';\nimport { defineCustomElement as defineIonItem } from '@ionic/core/components/ion-item.js';\nimport { defineCustomElement as defineIonItemDivider } from '@ionic/core/components/ion-item-divider.js';\nimport { defineCustomElement as defineIonItemGroup } from '@ionic/core/components/ion-item-group.js';\nimport { defineCustomElement as defineIonItemOption } from '@ionic/core/components/ion-item-option.js';\nimport { defineCustomElement as defineIonItemOptions } from '@ionic/core/components/ion-item-options.js';\nimport { defineCustomElement as defineIonItemSliding } from '@ionic/core/components/ion-item-sliding.js';\nimport { defineCustomElement as defineIonLabel } from '@ionic/core/components/ion-label.js';\nimport { defineCustomElement as defineIonList } from '@ionic/core/components/ion-list.js';\nimport { defineCustomElement as defineIonListHeader } from '@ionic/core/components/ion-list-header.js';\nimport { defineCustomElement as defineIonMenu } from '@ionic/core/components/ion-menu.js';\nimport { defineCustomElement as defineIonMenuButton } from '@ionic/core/components/ion-menu-button.js';\nimport { defineCustomElement as defineIonMenuToggle } from '@ionic/core/components/ion-menu-toggle.js';\nimport { defineCustomElement as defineIonNav } from '@ionic/core/components/ion-nav.js';\nimport { defineCustomElement as defineIonNavLink } from '@ionic/core/components/ion-nav-link.js';\nimport { defineCustomElement as defineIonNote } from '@ionic/core/components/ion-note.js';\nimport { defineCustomElement as defineIonProgressBar } from '@ionic/core/components/ion-progress-bar.js';\nimport { defineCustomElement as defineIonRadio } from '@ionic/core/components/ion-radio.js';\nimport { defineCustomElement as defineIonRadioGroup } from '@ionic/core/components/ion-radio-group.js';\nimport { defineCustomElement as defineIonRange } from '@ionic/core/components/ion-range.js';\nimport { defineCustomElement as defineIonRefresher } from '@ionic/core/components/ion-refresher.js';\nimport { defineCustomElement as defineIonRefresherContent } from '@ionic/core/components/ion-refresher-content.js';\nimport { defineCustomElement as defineIonReorder } from '@ionic/core/components/ion-reorder.js';\nimport { defineCustomElement as defineIonReorderGroup } from '@ionic/core/components/ion-reorder-group.js';\nimport { defineCustomElement as defineIonRippleEffect } from '@ionic/core/components/ion-ripple-effect.js';\nimport { defineCustomElement as defineIonRow } from '@ionic/core/components/ion-row.js';\nimport { defineCustomElement as defineIonSearchbar } from '@ionic/core/components/ion-searchbar.js';\nimport { defineCustomElement as defineIonSegment } from '@ionic/core/components/ion-segment.js';\nimport { defineCustomElement as defineIonSegmentButton } from '@ionic/core/components/ion-segment-button.js';\nimport { defineCustomElement as defineIonSelect } from '@ionic/core/components/ion-select.js';\nimport { defineCustomElement as defineIonSelectOption } from '@ionic/core/components/ion-select-option.js';\nimport { defineCustomElement as defineIonSkeletonText } from '@ionic/core/components/ion-skeleton-text.js';\nimport { defineCustomElement as defineIonSlide } from '@ionic/core/components/ion-slide.js';\nimport { defineCustomElement as defineIonSlides } from '@ionic/core/components/ion-slides.js';\nimport { defineCustomElement as defineIonSpinner } from '@ionic/core/components/ion-spinner.js';\nimport { defineCustomElement as defineIonSplitPane } from '@ionic/core/components/ion-split-pane.js';\nimport { defineCustomElement as defineIonText } from '@ionic/core/components/ion-text.js';\nimport { defineCustomElement as defineIonTextarea } from '@ionic/core/components/ion-textarea.js';\nimport { defineCustomElement as defineIonThumbnail } from '@ionic/core/components/ion-thumbnail.js';\nimport { defineCustomElement as defineIonTitle } from '@ionic/core/components/ion-title.js';\nimport { defineCustomElement as defineIonToggle } from '@ionic/core/components/ion-toggle.js';\nimport { defineCustomElement as defineIonToolbar } from '@ionic/core/components/ion-toolbar.js';\nimport { defineCustomElement as defineIonVirtualScroll } from '@ionic/core/components/ion-virtual-scroll.js';\nexport const IonAccordion = /*@__PURE__*/ defineContainer('ion-accordion', defineIonAccordion, [\n    'value',\n    'disabled',\n    'readonly',\n    'toggleIcon',\n    'toggleIconSlot'\n]);\nexport const IonAccordionGroup = /*@__PURE__*/ defineContainer('ion-accordion-group', defineIonAccordionGroup, [\n    'animated',\n    'multiple',\n    'value',\n    'disabled',\n    'readonly',\n    'expand',\n    'ionChange'\n], 'value', 'v-ion-change', 'ionChange');\nexport const IonAvatar = /*@__PURE__*/ defineContainer('ion-avatar', defineIonAvatar);\nexport const IonBackdrop = /*@__PURE__*/ defineContainer('ion-backdrop', defineIonBackdrop, [\n    'visible',\n    'tappable',\n    'stopPropagation',\n    'ionBackdropTap'\n]);\nexport const IonBadge = /*@__PURE__*/ defineContainer('ion-badge', defineIonBadge, [\n    'color'\n]);\nexport const IonBreadcrumb = /*@__PURE__*/ defineContainer('ion-breadcrumb', defineIonBreadcrumb, [\n    'collapsed',\n    'last',\n    'showCollapsedIndicator',\n    'color',\n    'active',\n    'disabled',\n    'download',\n    'href',\n    'rel',\n    'separator',\n    'target',\n    'routerDirection',\n    'routerAnimation',\n    'ionFocus',\n    'ionBlur',\n    'collapsedClick'\n]);\nexport const IonBreadcrumbs = /*@__PURE__*/ defineContainer('ion-breadcrumbs', defineIonBreadcrumbs, [\n    'color',\n    'maxItems',\n    'itemsBeforeCollapse',\n    'itemsAfterCollapse',\n    'ionCollapsedClick'\n]);\nexport const IonButton = /*@__PURE__*/ defineContainer('ion-button', defineIonButton, [\n    'color',\n    'buttonType',\n    'disabled',\n    'expand',\n    'fill',\n    'routerDirection',\n    'routerAnimation',\n    'download',\n    'href',\n    'rel',\n    'shape',\n    'size',\n    'strong',\n    'target',\n    'type',\n    'ionFocus',\n    'ionBlur'\n]);\nexport const IonButtons = /*@__PURE__*/ defineContainer('ion-buttons', defineIonButtons, [\n    'collapse'\n]);\nexport const IonCard = /*@__PURE__*/ defineContainer('ion-card', defineIonCard, [\n    'color',\n    'button',\n    'type',\n    'disabled',\n    'download',\n    'href',\n    'rel',\n    'routerDirection',\n    'routerAnimation',\n    'target'\n]);\nexport const IonCardContent = /*@__PURE__*/ defineContainer('ion-card-content', defineIonCardContent);\nexport const IonCardHeader = /*@__PURE__*/ defineContainer('ion-card-header', defineIonCardHeader, [\n    'color',\n    'translucent'\n]);\nexport const IonCardSubtitle = /*@__PURE__*/ defineContainer('ion-card-subtitle', defineIonCardSubtitle, [\n    'color'\n]);\nexport const IonCardTitle = /*@__PURE__*/ defineContainer('ion-card-title', defineIonCardTitle, [\n    'color'\n]);\nexport const IonCheckbox = /*@__PURE__*/ defineContainer('ion-checkbox', defineIonCheckbox, [\n    'color',\n    'name',\n    'checked',\n    'indeterminate',\n    'disabled',\n    'value',\n    'ionChange',\n    'ionFocus',\n    'ionBlur',\n    'ionStyle'\n], 'checked', 'v-ion-change', 'ionChange');\nexport const IonChip = /*@__PURE__*/ defineContainer('ion-chip', defineIonChip, [\n    'color',\n    'outline',\n    'disabled'\n]);\nexport const IonCol = /*@__PURE__*/ defineContainer('ion-col', defineIonCol, [\n    'offset',\n    'offsetXs',\n    'offsetSm',\n    'offsetMd',\n    'offsetLg',\n    'offsetXl',\n    'pull',\n    'pullXs',\n    'pullSm',\n    'pullMd',\n    'pullLg',\n    'pullXl',\n    'push',\n    'pushXs',\n    'pushSm',\n    'pushMd',\n    'pushLg',\n    'pushXl',\n    'size',\n    'sizeXs',\n    'sizeSm',\n    'sizeMd',\n    'sizeLg',\n    'sizeXl'\n]);\nexport const IonContent = /*@__PURE__*/ defineContainer('ion-content', defineIonContent, [\n    'color',\n    'fullscreen',\n    'forceOverscroll',\n    'scrollX',\n    'scrollY',\n    'scrollEvents',\n    'ionScrollStart',\n    'ionScroll',\n    'ionScrollEnd'\n]);\nexport const IonDatetime = /*@__PURE__*/ defineContainer('ion-datetime', defineIonDatetime, [\n    'color',\n    'name',\n    'disabled',\n    'readonly',\n    'isDateEnabled',\n    'min',\n    'max',\n    'presentation',\n    'cancelText',\n    'doneText',\n    'clearText',\n    'yearValues',\n    'monthValues',\n    'dayValues',\n    'hourValues',\n    'minuteValues',\n    'locale',\n    'firstDayOfWeek',\n    'multiple',\n    'value',\n    'showDefaultTitle',\n    'showDefaultButtons',\n    'showClearButton',\n    'showDefaultTimeLabel',\n    'hourCycle',\n    'size',\n    'preferWheel',\n    'ionCancel',\n    'ionChange',\n    'ionFocus',\n    'ionBlur',\n    'ionStyle',\n    'ionRender'\n], 'value', 'v-ion-change', 'ionChange');\nexport const IonDatetimeButton = /*@__PURE__*/ defineContainer('ion-datetime-button', defineIonDatetimeButton, [\n    'color',\n    'disabled',\n    'datetime'\n]);\nexport const IonFab = /*@__PURE__*/ defineContainer('ion-fab', defineIonFab, [\n    'horizontal',\n    'vertical',\n    'edge',\n    'activated'\n]);\nexport const IonFabButton = /*@__PURE__*/ defineContainer('ion-fab-button', defineIonFabButton, [\n    'color',\n    'activated',\n    'disabled',\n    'download',\n    'href',\n    'rel',\n    'routerDirection',\n    'routerAnimation',\n    'target',\n    'show',\n    'translucent',\n    'type',\n    'size',\n    'closeIcon',\n    'ionFocus',\n    'ionBlur'\n]);\nexport const IonFabList = /*@__PURE__*/ defineContainer('ion-fab-list', defineIonFabList, [\n    'activated',\n    'side'\n]);\nexport const IonFooter = /*@__PURE__*/ defineContainer('ion-footer', defineIonFooter, [\n    'collapse',\n    'translucent'\n]);\nexport const IonGrid = /*@__PURE__*/ defineContainer('ion-grid', defineIonGrid, [\n    'fixed'\n]);\nexport const IonHeader = /*@__PURE__*/ defineContainer('ion-header', defineIonHeader, [\n    'collapse',\n    'translucent'\n]);\nexport const IonImg = /*@__PURE__*/ defineContainer('ion-img', defineIonImg, [\n    'alt',\n    'src',\n    'ionImgWillLoad',\n    'ionImgDidLoad',\n    'ionError'\n]);\nexport const IonInfiniteScroll = /*@__PURE__*/ defineContainer('ion-infinite-scroll', defineIonInfiniteScroll, [\n    'threshold',\n    'disabled',\n    'position',\n    'ionInfinite'\n]);\nexport const IonInfiniteScrollContent = /*@__PURE__*/ defineContainer('ion-infinite-scroll-content', defineIonInfiniteScrollContent, [\n    'loadingSpinner',\n    'loadingText'\n]);\nexport const IonInput = /*@__PURE__*/ defineContainer('ion-input', defineIonInput, [\n    'fireFocusEvents',\n    'color',\n    'accept',\n    'autocapitalize',\n    'autocomplete',\n    'autocorrect',\n    'autofocus',\n    'clearInput',\n    'clearOnEdit',\n    'debounce',\n    'disabled',\n    'enterkeyhint',\n    'inputmode',\n    'max',\n    'maxlength',\n    'min',\n    'minlength',\n    'multiple',\n    'name',\n    'pattern',\n    'placeholder',\n    'readonly',\n    'required',\n    'spellcheck',\n    'step',\n    'size',\n    'type',\n    'value',\n    'ionInput',\n    'ionChange',\n    'ionBlur',\n    'ionFocus',\n    'ionStyle'\n], 'value', 'v-ion-change', 'ionChange');\nexport const IonItem = /*@__PURE__*/ defineContainer('ion-item', defineIonItem, [\n    'color',\n    'button',\n    'detail',\n    'detailIcon',\n    'disabled',\n    'download',\n    'fill',\n    'shape',\n    'href',\n    'rel',\n    'lines',\n    'counter',\n    'routerAnimation',\n    'routerDirection',\n    'target',\n    'type',\n    'counterFormatter'\n]);\nexport const IonItemDivider = /*@__PURE__*/ defineContainer('ion-item-divider', defineIonItemDivider, [\n    'color',\n    'sticky'\n]);\nexport const IonItemGroup = /*@__PURE__*/ defineContainer('ion-item-group', defineIonItemGroup);\nexport const IonItemOption = /*@__PURE__*/ defineContainer('ion-item-option', defineIonItemOption, [\n    'color',\n    'disabled',\n    'download',\n    'expandable',\n    'href',\n    'rel',\n    'target',\n    'type'\n]);\nexport const IonItemOptions = /*@__PURE__*/ defineContainer('ion-item-options', defineIonItemOptions, [\n    'side',\n    'ionSwipe'\n]);\nexport const IonItemSliding = /*@__PURE__*/ defineContainer('ion-item-sliding', defineIonItemSliding, [\n    'disabled',\n    'ionDrag'\n]);\nexport const IonLabel = /*@__PURE__*/ defineContainer('ion-label', defineIonLabel, [\n    'color',\n    'position',\n    'ionColor',\n    'ionStyle'\n]);\nexport const IonList = /*@__PURE__*/ defineContainer('ion-list', defineIonList, [\n    'lines',\n    'inset'\n]);\nexport const IonListHeader = /*@__PURE__*/ defineContainer('ion-list-header', defineIonListHeader, [\n    'color',\n    'lines'\n]);\nexport const IonMenu = /*@__PURE__*/ defineContainer('ion-menu', defineIonMenu, [\n    'contentId',\n    'menuId',\n    'type',\n    'disabled',\n    'side',\n    'swipeGesture',\n    'maxEdgeStart',\n    'ionWillOpen',\n    'ionWillClose',\n    'ionDidOpen',\n    'ionDidClose',\n    'ionMenuChange'\n]);\nexport const IonMenuButton = /*@__PURE__*/ defineContainer('ion-menu-button', defineIonMenuButton, [\n    'color',\n    'disabled',\n    'menu',\n    'autoHide',\n    'type'\n]);\nexport const IonMenuToggle = /*@__PURE__*/ defineContainer('ion-menu-toggle', defineIonMenuToggle, [\n    'menu',\n    'autoHide'\n]);\nexport const IonNav = /*@__PURE__*/ defineContainer('ion-nav', defineIonNav, [\n    'delegate',\n    'swipeGesture',\n    'animated',\n    'animation',\n    'rootParams',\n    'root',\n    'ionNavWillLoad',\n    'ionNavWillChange',\n    'ionNavDidChange'\n]);\nexport const IonNavLink = /*@__PURE__*/ defineContainer('ion-nav-link', defineIonNavLink, [\n    'component',\n    'componentProps',\n    'routerDirection',\n    'routerAnimation'\n]);\nexport const IonNote = /*@__PURE__*/ defineContainer('ion-note', defineIonNote, [\n    'color'\n]);\nexport const IonProgressBar = /*@__PURE__*/ defineContainer('ion-progress-bar', defineIonProgressBar, [\n    'type',\n    'reversed',\n    'value',\n    'buffer',\n    'color'\n]);\nexport const IonRadio = /*@__PURE__*/ defineContainer('ion-radio', defineIonRadio, [\n    'color',\n    'name',\n    'disabled',\n    'value',\n    'ionStyle',\n    'ionFocus',\n    'ionBlur'\n], 'value', 'v-ion-change', 'ionChange');\nexport const IonRadioGroup = /*@__PURE__*/ defineContainer('ion-radio-group', defineIonRadioGroup, [\n    'allowEmptySelection',\n    'name',\n    'value',\n    'ionChange'\n], 'value', 'v-ion-change', 'ionChange');\nexport const IonRange = /*@__PURE__*/ defineContainer('ion-range', defineIonRange, [\n    'color',\n    'debounce',\n    'name',\n    'dualKnobs',\n    'min',\n    'max',\n    'pin',\n    'pinFormatter',\n    'snaps',\n    'step',\n    'ticks',\n    'activeBarStart',\n    'disabled',\n    'value',\n    'ionChange',\n    'ionStyle',\n    'ionFocus',\n    'ionBlur',\n    'ionKnobMoveStart',\n    'ionKnobMoveEnd'\n], 'value', 'v-ion-change', 'ionChange');\nexport const IonRefresher = /*@__PURE__*/ defineContainer('ion-refresher', defineIonRefresher, [\n    'pullMin',\n    'pullMax',\n    'closeDuration',\n    'snapbackDuration',\n    'pullFactor',\n    'disabled',\n    'ionRefresh',\n    'ionPull',\n    'ionStart'\n]);\nexport const IonRefresherContent = /*@__PURE__*/ defineContainer('ion-refresher-content', defineIonRefresherContent, [\n    'pullingIcon',\n    'pullingText',\n    'refreshingSpinner',\n    'refreshingText'\n]);\nexport const IonReorder = /*@__PURE__*/ defineContainer('ion-reorder', defineIonReorder);\nexport const IonReorderGroup = /*@__PURE__*/ defineContainer('ion-reorder-group', defineIonReorderGroup, [\n    'disabled',\n    'ionItemReorder'\n]);\nexport const IonRippleEffect = /*@__PURE__*/ defineContainer('ion-ripple-effect', defineIonRippleEffect, [\n    'type'\n]);\nexport const IonRow = /*@__PURE__*/ defineContainer('ion-row', defineIonRow);\nexport const IonSearchbar = /*@__PURE__*/ defineContainer('ion-searchbar', defineIonSearchbar, [\n    'color',\n    'animated',\n    'autocomplete',\n    'autocorrect',\n    'cancelButtonIcon',\n    'cancelButtonText',\n    'clearIcon',\n    'debounce',\n    'disabled',\n    'inputmode',\n    'enterkeyhint',\n    'placeholder',\n    'searchIcon',\n    'showCancelButton',\n    'showClearButton',\n    'spellcheck',\n    'type',\n    'value',\n    'ionInput',\n    'ionChange',\n    'ionCancel',\n    'ionClear',\n    'ionBlur',\n    'ionFocus',\n    'ionStyle'\n], 'value', 'v-ion-change', 'ionChange');\nexport const IonSegment = /*@__PURE__*/ defineContainer('ion-segment', defineIonSegment, [\n    'color',\n    'disabled',\n    'scrollable',\n    'swipeGesture',\n    'value',\n    'selectOnFocus',\n    'ionChange',\n    'ionSelect',\n    'ionStyle'\n], 'value', 'v-ion-change', 'ionChange');\nexport const IonSegmentButton = /*@__PURE__*/ defineContainer('ion-segment-button', defineIonSegmentButton, [\n    'disabled',\n    'layout',\n    'type',\n    'value'\n], 'value', 'v-ion-change', 'ionChange');\nexport const IonSelect = /*@__PURE__*/ defineContainer('ion-select', defineIonSelect, [\n    'disabled',\n    'cancelText',\n    'okText',\n    'placeholder',\n    'name',\n    'selectedText',\n    'multiple',\n    'interface',\n    'interfaceOptions',\n    'compareWith',\n    'value',\n    'ionChange',\n    'ionCancel',\n    'ionDismiss',\n    'ionFocus',\n    'ionBlur',\n    'ionStyle'\n], 'value', 'v-ion-change', 'ionChange');\nexport const IonSelectOption = /*@__PURE__*/ defineContainer('ion-select-option', defineIonSelectOption, [\n    'disabled',\n    'value'\n]);\nexport const IonSkeletonText = /*@__PURE__*/ defineContainer('ion-skeleton-text', defineIonSkeletonText, [\n    'animated'\n]);\nexport const IonSlide = /*@__PURE__*/ defineContainer('ion-slide', defineIonSlide);\nexport const IonSlides = /*@__PURE__*/ defineContainer('ion-slides', defineIonSlides, [\n    'options',\n    'pager',\n    'scrollbar',\n    'ionSlidesDidLoad',\n    'ionSlideTap',\n    'ionSlideDoubleTap',\n    'ionSlideWillChange',\n    'ionSlideDidChange',\n    'ionSlideNextStart',\n    'ionSlidePrevStart',\n    'ionSlideNextEnd',\n    'ionSlidePrevEnd',\n    'ionSlideTransitionStart',\n    'ionSlideTransitionEnd',\n    'ionSlideDrag',\n    'ionSlideReachStart',\n    'ionSlideReachEnd',\n    'ionSlideTouchStart',\n    'ionSlideTouchEnd'\n]);\nexport const IonSpinner = /*@__PURE__*/ defineContainer('ion-spinner', defineIonSpinner, [\n    'color',\n    'duration',\n    'name',\n    'paused'\n]);\nexport const IonSplitPane = /*@__PURE__*/ defineContainer('ion-split-pane', defineIonSplitPane, [\n    'contentId',\n    'disabled',\n    'when',\n    'ionSplitPaneVisible'\n]);\nexport const IonText = /*@__PURE__*/ defineContainer('ion-text', defineIonText, [\n    'color'\n]);\nexport const IonTextarea = /*@__PURE__*/ defineContainer('ion-textarea', defineIonTextarea, [\n    'fireFocusEvents',\n    'color',\n    'autocapitalize',\n    'autofocus',\n    'clearOnEdit',\n    'debounce',\n    'disabled',\n    'inputmode',\n    'enterkeyhint',\n    'maxlength',\n    'minlength',\n    'name',\n    'placeholder',\n    'readonly',\n    'required',\n    'spellcheck',\n    'cols',\n    'rows',\n    'wrap',\n    'autoGrow',\n    'value',\n    'ionChange',\n    'ionInput',\n    'ionStyle',\n    'ionBlur',\n    'ionFocus'\n], 'value', 'v-ion-change', 'ionChange');\nexport const IonThumbnail = /*@__PURE__*/ defineContainer('ion-thumbnail', defineIonThumbnail);\nexport const IonTitle = /*@__PURE__*/ defineContainer('ion-title', defineIonTitle, [\n    'color',\n    'size',\n    'ionStyle'\n]);\nexport const IonToggle = /*@__PURE__*/ defineContainer('ion-toggle', defineIonToggle, [\n    'color',\n    'name',\n    'checked',\n    'disabled',\n    'value',\n    'enableOnOffLabels',\n    'ionChange',\n    'ionFocus',\n    'ionBlur',\n    'ionStyle'\n], 'checked', 'v-ion-change', 'ionChange');\nexport const IonToolbar = /*@__PURE__*/ defineContainer('ion-toolbar', defineIonToolbar, [\n    'color'\n]);\nexport const IonVirtualScroll = /*@__PURE__*/ defineContainer('ion-virtual-scroll', defineIonVirtualScroll, [\n    'approxItemHeight',\n    'approxHeaderHeight',\n    'approxFooterHeight',\n    'headerFn',\n    'footerFn',\n    'items',\n    'itemHeight',\n    'headerHeight',\n    'footerHeight',\n    'renderItem',\n    'renderHeader',\n    'renderFooter',\n    'nodeRender',\n    'domRender'\n]);\n//# sourceMappingURL=proxies.js.map", "export const useBackButton = (priority, handler) => {\n    const callback = (ev) => ev.detail.register(priority, handler);\n    const unregister = () => document.removeEventListener('ionBackButton', callback);\n    document.addEventListener('ionBackButton', callback);\n    return { unregister };\n};\n//# sourceMappingURL=back-button.js.map", "import { ref } from 'vue';\nexport const useKeyboard = () => {\n    let isOpen = ref(false);\n    let keyboardHeight = ref(0);\n    const showCallback = (ev) => {\n        isOpen.value = true;\n        keyboardHeight.value = ev.detail.keyboardHeight;\n    };\n    const hideCallback = () => {\n        isOpen.value = false;\n        keyboardHeight.value = 0;\n    };\n    const unregister = () => {\n        if (typeof window !== 'undefined') {\n            window.removeEventListener('ionKeyboardDidShow', showCallback);\n            window.removeEventListener('ionKeyboardDidHide', hideCallback);\n        }\n    };\n    if (typeof window !== 'undefined') {\n        window.addEventListener('ionKeyboardDidShow', showCallback);\n        window.addEventListener('ionKeyboardDidHide', hideCallback);\n    }\n    return {\n        isOpen,\n        keyboardHeight,\n        unregister\n    };\n};\n//# sourceMappingURL=keyboard.js.map", "import { LIFECYCLE_DID_ENTER, LIFECYCLE_DID_LEAVE, LIFECYCLE_WILL_ENTER, LIFECYCLE_WILL_LEAVE } from '@ionic/core/components';\nexport var LifecycleHooks;\n(function (LifecycleHooks) {\n    LifecycleHooks[\"WillEnter\"] = \"onIonViewWillEnter\";\n    LifecycleHooks[\"DidEnter\"] = \"onIonViewDidEnter\";\n    LifecycleHooks[\"WillLeave\"] = \"onIonViewWillLeave\";\n    LifecycleHooks[\"DidLeave\"] = \"onIonViewDidLeave\";\n})(LifecycleHooks || (LifecycleHooks = {}));\nconst hookNames = {\n    [LIFECYCLE_WILL_ENTER]: LifecycleHooks.WillEnter,\n    [LIFECYCLE_DID_ENTER]: LifecycleHooks.DidEnter,\n    [LIFECYCLE_WILL_LEAVE]: LifecycleHooks.WillLeave,\n    [LIFECYCLE_DID_LEAVE]: LifecycleHooks.DidLeave\n};\nconst ids = { main: 0 };\nexport const generateId = (type = 'main') => {\n    var _a;\n    const id = ((_a = ids[type]) !== null && _a !== void 0 ? _a : 0) + 1;\n    ids[type] = id;\n    return (id).toString();\n};\n// TODO types\nexport const fireLifecycle = (vueComponent, vueInstance, lifecycle) => {\n    if (vueComponent === null || vueComponent === void 0 ? void 0 : vueComponent[lifecycle]) {\n        vueComponent[lifecycle].bind(vueInstance === null || vueInstance === void 0 ? void 0 : vueInstance.value)();\n    }\n    const instance = vueInstance === null || vueInstance === void 0 ? void 0 : vueInstance.value;\n    if (instance === null || instance === void 0 ? void 0 : instance[lifecycle]) {\n        instance[lifecycle]();\n    }\n    /**\n     * Fire any Composition API\n     * Ionic Lifecycle hooks\n     */\n    if (instance) {\n        const hook = hookNames[lifecycle];\n        const hooks = instance[hook];\n        if (hooks) {\n            hooks.forEach((hook) => hook());\n        }\n    }\n};\nexport const getConfig = () => {\n    if (typeof window !== 'undefined') {\n        const Ionic = window.Ionic;\n        if (Ionic && Ionic.config) {\n            return Ionic.config;\n        }\n    }\n    return null;\n};\nexport const defineCustomElement = (tagName, customElement) => {\n    if (typeof customElements === 'undefined')\n        return;\n    if (!customElements.get(tagName)) {\n        customElements.define(tagName, customElement);\n    }\n};\n//# sourceMappingURL=utils.js.map", "import { LifecycleHooks } from '../utils';\nimport { getCurrentInstance } from 'vue';\n/**\n * Creates an returns a function that\n * can be used to provide a lifecycle hook.\n */\nconst injectHook = (lifecycleType, hook, component) => {\n    if (component) {\n        // Add to public instance so it is accessible to IonRouterOutlet\n        const target = component;\n        const hooks = target.proxy[lifecycleType] || (target.proxy[lifecycleType] = []);\n        /**\n         * Define property on public instances using `setup` syntax in Vue 3.x\n         */\n        if (target.exposed) {\n            target.exposed[lifecycleType] = hooks;\n        }\n        const wrappedHook = (...args) => {\n            if (target.isUnmounted) {\n                return;\n            }\n            return args ? hook(...args) : hook();\n        };\n        hooks.push(wrappedHook);\n        return wrappedHook;\n    }\n    else {\n        console.warn('[@ionic/vue]: Ionic Lifecycle Hooks can only be used during execution of setup().');\n    }\n};\nconst createHook = (lifecycle) => {\n    return (hook, target = getCurrentInstance()) => injectHook(lifecycle, hook, target);\n};\nexport const onIonViewWillEnter = createHook(LifecycleHooks.WillEnter);\nexport const onIonViewDidEnter = createHook(LifecycleHooks.DidEnter);\nexport const onIonViewWillLeave = createHook(LifecycleHooks.WillLeave);\nexport const onIonViewDidLeave = createHook(LifecycleHooks.DidLeave);\n//# sourceMappingURL=lifecycle.js.map", "import { inject } from 'vue';\n/**\n * Used to navigate within Vue Router\n * while controlling the animation.\n */\nexport const useIonRouter = () => {\n    const { canGoBack, goBack, goForward, handleNavigate } = inject('navManager');\n    const navigate = (location, routerDirection, routerAction, routerAnimation) => handleNavigate(location, routerAction, routerDirection, routerAnimation);\n    const push = (location, routerAnimation) => navigate(location, 'forward', 'push', routerAnimation);\n    const replace = (location, routerAnimation) => navigate(location, 'root', 'replace', routerAnimation);\n    const back = (routerAnimation) => goBack(routerAnimation);\n    const forward = (routerAnimation) => goForward(routerAnimation);\n    return {\n        canGoBack,\n        push,\n        replace,\n        back,\n        forward,\n        navigate\n    };\n};\n//# sourceMappingURL=router.js.map", "import { initialize } from '@ionic/core/components';\n/**\n* We need to make sure that the web component fires an event\n* that will not conflict with the user's @ionChange binding,\n* otherwise the binding's callback will fire before any\n* v-model values have been updated.\n*/\nconst toKebabCase = (eventName) => eventName === 'ionChange' ? 'v-ion-change' : eventName.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, '$1-$2').toLowerCase();\nconst getHelperFunctions = () => {\n    return {\n        ael: (el, eventName, cb, opts) => el.addEventListener(toKebabCase(eventName), cb, opts),\n        rel: (el, eventName, cb, opts) => el.removeEventListener(toKebabCase(eventName), cb, opts),\n        ce: (eventName, opts) => new CustomEvent(toKebabCase(eventName), opts)\n    };\n};\nexport const IonicVue = {\n    async install(_, config = {}) {\n        /**\n         * By default Ionic Framework hides elements that\n         * are not hydrated, but in the CE build there is no\n         * hydration.\n         * TODO: Remove when all integrations have been\n         * migrated to CE build.\n         */\n        if (typeof document !== 'undefined') {\n            document.documentElement.classList.add('ion-ce');\n        }\n        const { ael, rel, ce } = getHelperFunctions();\n        initialize(Object.assign(Object.assign({}, config), { _ael: ael, _rel: rel, _ce: ce }));\n    }\n};\n//# sourceMappingURL=ionic-vue.js.map", "import { h, inject, defineComponent } from 'vue';\nimport { defineCustomElement } from '../utils';\nimport { IonBackButton as IonBackButtonCmp } from '@ionic/core/components/ion-back-button.js';\nimport { IonIcon as IonIconCmp } from 'ionicons/components/ion-icon.js';\nexport const IonBackButton = /*@__PURE__*/ defineComponent((_, { attrs, slots }) => {\n    defineCustomElement('ion-back-button', IonBackButtonCmp);\n    defineCustomElement('ion-icon', IonIconCmp);\n    const ionRouter = inject('navManager');\n    const onClick = () => {\n        const defaultHref = attrs['default-href'] || attrs['defaultHref'];\n        const routerAnimation = attrs['router-animation'] || attrs['routerAnimation'];\n        ionRouter.handleNavigateBack(defaultHref, routerAnimation);\n    };\n    return () => {\n        return h('ion-back-button', Object.assign({ onClick }, attrs), slots.default && slots.default());\n    };\n});\n//# sourceMappingURL=IonBackButton.js.map", "import { h, defineComponent } from 'vue';\nexport const IonPage = /*@__PURE__*/ defineComponent({\n    name: 'IonPage',\n    props: {\n        registerIonPage: { type: Function, default: () => { } }\n    },\n    mounted() {\n        this.$props.registerIonPage(this.$refs.ionPage);\n    },\n    setup(_, { attrs, slots }) {\n        return () => {\n            return h('div', Object.assign(Object.assign({}, attrs), { ['class']: 'ion-page', ref: 'ionPage' }), slots.default && slots.default());\n        };\n    }\n});\n//# sourceMappingURL=IonPage.js.map", "import { h, defineComponent, ref, computed, inject, provide, watch, shallowRef, onUnmounted } from 'vue';\nimport { LIFECYCLE_DID_ENTER, LIFECYCLE_DID_LEAVE, LIFECYCLE_WILL_ENTER, LIFECYCLE_WILL_LEAVE } from '@ionic/core/components';\nimport { IonRouterOutlet as IonRouterOutletCmp } from '@ionic/core/components/ion-router-outlet.js';\nimport { matchedRouteKey, routeLocationKey, useRoute } from 'vue-router';\nimport { fireLifecycle, generateId, getConfig, defineCustomElement } from '../utils';\nconst isViewVisible = (enteringEl) => {\n    return !enteringEl.classList.contains('ion-page-hidden') && !enteringEl.classList.contains('ion-page-invisible');\n};\nlet viewDepthKey = Symbol(0);\nexport const IonRouterOutlet = /*@__PURE__*/ defineComponent({\n    name: 'IonRouterOutlet',\n    setup() {\n        defineCustomElement('ion-router-outlet', IonRouterOutletCmp);\n        const injectedRoute = inject(routeLocationKey);\n        const route = useRoute();\n        const depth = inject(viewDepthKey, 0);\n        const matchedRouteRef = computed(() => route.matched[depth]);\n        let previousMatchedRouteRef;\n        let previousMatchedPath;\n        provide(viewDepthKey, depth + 1);\n        provide(matchedRouteKey, matchedRouteRef);\n        const ionRouterOutlet = ref();\n        const id = generateId('ion-router-outlet');\n        // TODO types\n        const ionRouter = inject('navManager');\n        const viewStacks = inject('viewStacks');\n        const components = shallowRef([]);\n        let skipTransition = false;\n        // The base url for this router outlet\n        let parentOutletPath;\n        /**\n         * Note: Do not listen for matchedRouteRef by itself here\n         * as the callback will not fire for parameterized routes (i.e. /page/:id).\n         * So going from /page/1 to /page/2 would not fire this callback if we\n         * only listened for changes to matchedRouteRef.\n         */\n        watch(() => [route, matchedRouteRef.value], ([currentRoute, currentMatchedRouteRef]) => {\n            /**\n             * This callback checks whether or not a router outlet\n             * needs to respond to a change in the matched route.\n             * It handles a few cases:\n             * 1. The matched route is undefined. This means that\n             * the matched route is not applicable to this outlet.\n             * For example, a /settings route is not applicable\n             * to a /tabs/... route.\n             *\n             * Note: When going back to a tabs outlet from a non-tabs outlet,\n             * the tabs outlet should NOT attempt a page transition from the\n             * previous tab to the active tab. To do this we compare the current\n             * route with the previous route. Unfortunately, we cannot rely on the\n             * previous value provided by Vue in the watch callback. This is because\n             * when coming back to the tabs context, the previous matched route will\n             * be undefined (because nothing in the tabs context matches /settings)\n             * but the current matched route will be defined and so a transition\n             * will always occur.\n             *\n             * 2. The matched route is defined and is different than\n             * the previously matched route. This is the most\n             * common case such as when you go from /page1 to /page2.\n             *\n             * 3. The matched route is the same but the parameters are different.\n             * This is a special case for parameterized routes (i.e. /page/:id).\n             * When going from /page/1 to /page/2, the matched route object will\n             * be the same, but we still need to perform a page transition. To do this\n             * we check if the parameters are different (i.e. 1 vs 2). To avoid enumerating\n             * all of the keys in the params object, we check the url path to\n             * see if they are different after ensuring we are in a parameterized route.\n             */\n            if (currentMatchedRouteRef !== undefined) {\n                const matchedDifferentRoutes = currentMatchedRouteRef !== previousMatchedRouteRef;\n                const matchedDifferentParameterRoutes = (currentRoute.matched[currentRoute.matched.length - 1] === currentMatchedRouteRef &&\n                    currentRoute.path !== previousMatchedPath);\n                if (matchedDifferentRoutes || matchedDifferentParameterRoutes) {\n                    setupViewItem(matchedRouteRef);\n                }\n            }\n            previousMatchedRouteRef = currentMatchedRouteRef;\n            previousMatchedPath = currentRoute.path;\n        });\n        const canStart = () => {\n            const config = getConfig();\n            const swipeEnabled = config && config.get('swipeBackEnabled', ionRouterOutlet.value.mode === 'ios');\n            if (!swipeEnabled)\n                return false;\n            const stack = viewStacks.getViewStack(id);\n            if (!stack || stack.length <= 1)\n                return false;\n            /**\n             * We only want to outlet of the entering view\n             * to respond to this gesture, so check\n             * to make sure the view is in the outlet we want.\n             */\n            const routeInfo = ionRouter.getLeavingRouteInfo();\n            const enteringViewItem = viewStacks.findViewItemByRouteInfo({ pathname: routeInfo.pushedByRoute || '' }, id);\n            return !!enteringViewItem;\n        };\n        const onStart = async () => {\n            const routeInfo = ionRouter.getLeavingRouteInfo();\n            const { routerAnimation } = routeInfo;\n            const enteringViewItem = viewStacks.findViewItemByRouteInfo({ pathname: routeInfo.pushedByRoute || '' }, id);\n            const leavingViewItem = viewStacks.findViewItemByRouteInfo(routeInfo, id);\n            if (leavingViewItem) {\n                let animationBuilder = routerAnimation;\n                const enteringEl = enteringViewItem.ionPageElement;\n                const leavingEl = leavingViewItem.ionPageElement;\n                /**\n                * If we are going back from a page that\n                * was presented using a custom animation\n                * we should default to using that\n                * unless the developer explicitly\n                * provided another animation.\n                */\n                const customAnimation = enteringViewItem.routerAnimation;\n                if (animationBuilder === undefined &&\n                    // todo check for tab switch\n                    customAnimation !== undefined) {\n                    animationBuilder = customAnimation;\n                }\n                leavingViewItem.routerAnimation = animationBuilder;\n                await transition(enteringEl, leavingEl, 'back', ionRouter.canGoBack(2), true, animationBuilder);\n            }\n            return Promise.resolve();\n        };\n        const onEnd = (shouldContinue) => {\n            if (shouldContinue) {\n                skipTransition = true;\n                /**\n                 * Use the same logic as clicking\n                 * ion-back-button to determine where\n                 * to go back to.\n                 */\n                ionRouter.handleNavigateBack();\n            }\n            else {\n                /**\n                 * In the event that the swipe\n                 * gesture was aborted, we should\n                 * re-hide the page that was going to enter.\n                 */\n                const routeInfo = ionRouter.getCurrentRouteInfo();\n                const enteringViewItem = viewStacks.findViewItemByRouteInfo({ pathname: routeInfo.pushedByRoute || '' }, id);\n                enteringViewItem.ionPageElement.setAttribute('aria-hidden', 'true');\n                enteringViewItem.ionPageElement.classList.add('ion-page-hidden');\n            }\n        };\n        watch(ionRouterOutlet, () => {\n            ionRouterOutlet.value.swipeHandler = {\n                canStart,\n                onStart,\n                onEnd\n            };\n        });\n        const transition = (enteringEl, leavingEl, direction, // TODO types\n        showGoBack, progressAnimation, animationBuilder) => {\n            return new Promise(resolve => {\n                if (skipTransition) {\n                    skipTransition = false;\n                    return resolve(false);\n                }\n                if (enteringEl === leavingEl) {\n                    return resolve(false);\n                }\n                requestAnimationFrame(() => {\n                    requestAnimationFrame(async () => {\n                        enteringEl.classList.add('ion-page-invisible');\n                        const result = await ionRouterOutlet.value.commit(enteringEl, leavingEl, {\n                            deepWait: true,\n                            duration: direction === undefined || direction === 'root' || direction === 'none' ? 0 : undefined,\n                            direction,\n                            showGoBack,\n                            progressAnimation,\n                            animationBuilder\n                        });\n                        return resolve(result);\n                    });\n                });\n            });\n        };\n        const handlePageTransition = async () => {\n            const routeInfo = ionRouter.getCurrentRouteInfo();\n            const { routerDirection, routerAction, routerAnimation, prevRouteLastPathname, delta } = routeInfo;\n            const enteringViewItem = viewStacks.findViewItemByRouteInfo(routeInfo, id);\n            let leavingViewItem = viewStacks.findLeavingViewItemByRouteInfo(routeInfo, id);\n            const enteringEl = enteringViewItem.ionPageElement;\n            /**\n             * All views that can be transitioned to must have\n             * an `<ion-page>` element for transitions and lifecycle\n             * methods to work properly.\n             */\n            if (enteringEl === undefined) {\n                console.warn(`[@ionic/vue Warning]: The view you are trying to render for path ${routeInfo.pathname} does not have the required <ion-page> component. Transitions and lifecycle methods may not work as expected.\n\nSee https://ionicframework.com/docs/vue/navigation#ionpage for more information.`);\n            }\n            if (enteringViewItem === leavingViewItem)\n                return;\n            if (!leavingViewItem && prevRouteLastPathname) {\n                leavingViewItem = viewStacks.findViewItemByPathname(prevRouteLastPathname, id);\n            }\n            /**\n             * If the entering view is already\n             * visible, then no transition is needed.\n             * This is most common when navigating\n             * from a tabs page to a non-tabs page\n             * and then back to the tabs page.\n             * Even when the tabs context navigated away,\n             * the inner tabs page was still active.\n             * This also avoids an issue where\n             * the previous tabs page is incorrectly\n             * unmounted since it would automatically\n             * unmount the previous view.\n             *\n             * This should also only apply to entering and\n             * leaving items in the same router outlet (i.e.\n             * Tab1 and Tab2), otherwise this will\n             * return early for swipe to go back when\n             * going from a non-tabs page to a tabs page.\n             */\n            if (isViewVisible(enteringEl) && (leavingViewItem === null || leavingViewItem === void 0 ? void 0 : leavingViewItem.ionPageElement) !== undefined && !isViewVisible(leavingViewItem.ionPageElement)) {\n                return;\n            }\n            fireLifecycle(enteringViewItem.vueComponent, enteringViewItem.vueComponentRef, LIFECYCLE_WILL_ENTER);\n            if ((leavingViewItem === null || leavingViewItem === void 0 ? void 0 : leavingViewItem.ionPageElement) && enteringViewItem !== leavingViewItem) {\n                let animationBuilder = routerAnimation;\n                const leavingEl = leavingViewItem.ionPageElement;\n                fireLifecycle(leavingViewItem.vueComponent, leavingViewItem.vueComponentRef, LIFECYCLE_WILL_LEAVE);\n                /**\n                * If we are going back from a page that\n                * was presented using a custom animation\n                * we should default to using that\n                * unless the developer explicitly\n                * provided another animation.\n                */\n                const customAnimation = enteringViewItem.routerAnimation;\n                if (animationBuilder === undefined &&\n                    routerDirection === 'back' &&\n                    // todo check for tab switch\n                    customAnimation !== undefined) {\n                    animationBuilder = customAnimation;\n                }\n                leavingViewItem.routerAnimation = animationBuilder;\n                await transition(enteringEl, leavingEl, routerDirection, !!routeInfo.pushedByRoute, false, animationBuilder);\n                leavingEl.classList.add('ion-page-hidden');\n                leavingEl.setAttribute('aria-hidden', 'true');\n                const usingLinearNavigation = viewStacks.size() === 1;\n                if (routerAction === 'replace') {\n                    leavingViewItem.mount = false;\n                    leavingViewItem.ionPageElement = undefined;\n                    leavingViewItem.ionRoute = false;\n                }\n                else if (!(routerAction === 'push' && routerDirection === 'forward')) {\n                    const shouldLeavingViewBeRemoved = routerDirection !== 'none' && leavingViewItem && (enteringViewItem !== leavingViewItem);\n                    if (shouldLeavingViewBeRemoved) {\n                        leavingViewItem.mount = false;\n                        leavingViewItem.ionPageElement = undefined;\n                        leavingViewItem.ionRoute = false;\n                        /**\n                         * router.go() expects navigation to be\n                         * linear. If an app is using multiple stacks then\n                         * it is not using linear navigation. As a result, router.go()\n                         * will not give the results that developers are expecting.\n                         */\n                        if (usingLinearNavigation) {\n                            viewStacks.unmountLeavingViews(id, enteringViewItem, delta);\n                        }\n                    }\n                }\n                else if (usingLinearNavigation) {\n                    viewStacks.mountIntermediaryViews(id, leavingViewItem, delta);\n                }\n                fireLifecycle(leavingViewItem.vueComponent, leavingViewItem.vueComponentRef, LIFECYCLE_DID_LEAVE);\n            }\n            else {\n                /**\n                 * If there is no leaving element, just show\n                 * the entering element. Wrap it in an raf\n                 * in case ion-content's fullscreen callback\n                 * is running. Otherwise we'd have a flicker.\n                 */\n                requestAnimationFrame(() => enteringEl.classList.remove('ion-page-invisible'));\n            }\n            fireLifecycle(enteringViewItem.vueComponent, enteringViewItem.vueComponentRef, LIFECYCLE_DID_ENTER);\n            components.value = viewStacks.getChildrenToRender(id);\n        };\n        const setupViewItem = (matchedRouteRef) => {\n            const firstMatchedRoute = route.matched[0];\n            if (!parentOutletPath) {\n                parentOutletPath = firstMatchedRoute.path;\n            }\n            /**\n             * If no matched route, do not do anything in this outlet.\n             * If there is a match, but it the first matched path\n             * is not the root path for this outlet, then this view\n             * change needs to be rendered in a different outlet.\n             * We also add an exception for when the matchedRouteRef is\n             * equal to the first matched route (i.e. the base router outlet).\n             * This logic is mainly to help nested outlets/multi-tab\n             * setups work better.\n             */\n            if (!matchedRouteRef.value ||\n                (matchedRouteRef.value !== firstMatchedRoute && firstMatchedRoute.path !== parentOutletPath)) {\n                return;\n            }\n            const currentRoute = ionRouter.getCurrentRouteInfo();\n            let enteringViewItem = viewStacks.findViewItemByRouteInfo(currentRoute, id);\n            if (!enteringViewItem) {\n                enteringViewItem = viewStacks.createViewItem(id, matchedRouteRef.value.components.default, matchedRouteRef.value, currentRoute);\n                viewStacks.add(enteringViewItem);\n            }\n            if (!enteringViewItem.mount) {\n                enteringViewItem.mount = true;\n                enteringViewItem.registerCallback = () => {\n                    handlePageTransition();\n                    enteringViewItem.registerCallback = undefined;\n                };\n            }\n            else {\n                handlePageTransition();\n            }\n            components.value = viewStacks.getChildrenToRender(id);\n        };\n        if (matchedRouteRef.value) {\n            setupViewItem(matchedRouteRef);\n        }\n        /**\n         * Remove stack data for this outlet\n         * when outlet is destroyed otherwise\n         * we will see cached view data.\n         */\n        onUnmounted(() => viewStacks.clear(id));\n        // TODO types\n        const registerIonPage = (viewItem, ionPageEl) => {\n            const oldIonPageEl = viewItem.ionPageElement;\n            viewStacks.registerIonPage(viewItem, ionPageEl);\n            /**\n             * If there is a registerCallback,\n             * then this component is being registered\n             * as a result of a navigation change.\n             */\n            if (viewItem.registerCallback) {\n                /**\n                 * Page should be hidden initially\n                 * to avoid flickering.\n                 */\n                ionPageEl.classList.add('ion-page-invisible');\n                viewItem.registerCallback();\n                /**\n                 * If there is no registerCallback, then\n                 * this component is likely being re-registered\n                 * as a result of a hot module replacement.\n                 * We need to see if the oldIonPageEl has\n                 * .ion-page-invisible. If it does not then we\n                 * need to remove it from the new ionPageEl otherwise\n                 * the page will be hidden when it is replaced.\n                 */\n            }\n            else if (oldIonPageEl && !oldIonPageEl.classList.contains('ion-page-invisible')) {\n                ionPageEl.classList.remove('ion-page-invisible');\n            }\n        };\n        return {\n            id,\n            components,\n            injectedRoute,\n            ionRouterOutlet,\n            registerIonPage\n        };\n    },\n    render() {\n        const { components, registerIonPage, injectedRoute } = this;\n        return h('ion-router-outlet', { ref: 'ionRouterOutlet' }, \n        // TODO types\n        components && components.map((c) => {\n            var _a, _b;\n            let props = {\n                ref: c.vueComponentRef,\n                key: c.pathname,\n                registerIonPage: (ionPageEl) => registerIonPage(c, ionPageEl)\n            };\n            /**\n             * IonRouterOutlet does not support named outlets.\n             */\n            const routePropsOption = (_b = (_a = c.matchedRoute) === null || _a === void 0 ? void 0 : _a.props) === null || _b === void 0 ? void 0 : _b.default;\n            /**\n             * Since IonRouterOutlet renders multiple components,\n             * each render will cause all props functions to be\n             * called again. As a result, we need to cache the function\n             * result and provide it on each render so that the props\n             * are not lost when navigating from and back to a page.\n             * When a component is destroyed and re-created, the\n             * function is called again.\n             */\n            const getPropsFunctionResult = () => {\n                var _a;\n                const cachedPropsResult = (_a = c.vueComponentData) === null || _a === void 0 ? void 0 : _a.propsFunctionResult;\n                if (cachedPropsResult) {\n                    return cachedPropsResult;\n                }\n                else {\n                    const propsFunctionResult = routePropsOption(injectedRoute);\n                    c.vueComponentData = Object.assign(Object.assign({}, c.vueComponentData), { propsFunctionResult });\n                    return propsFunctionResult;\n                }\n            };\n            const routeProps = routePropsOption\n                ? routePropsOption === true\n                    ? c.params\n                    : typeof routePropsOption === 'function'\n                        ? getPropsFunctionResult()\n                        : routePropsOption\n                : null;\n            props = Object.assign(Object.assign({}, props), routeProps);\n            return h(c.vueComponent, props);\n        }));\n    }\n});\n//# sourceMappingURL=IonRouterOutlet.js.map", "import { h, defineComponent, inject } from 'vue';\nimport { defineCustomElement } from '../utils';\nimport { IonTabButton as IonTabButtonCmp } from '@ionic/core/components/ion-tab-button.js';\nexport const IonTabButton = /*@__PURE__*/ defineComponent({\n    name: 'IonTabButton',\n    props: {\n        _getTabState: { type: Function, default: () => { return {}; } },\n        disabled: Boolean,\n        download: String,\n        href: String,\n        rel: String,\n        layout: String,\n        selected: Boolean,\n        tab: String,\n        target: String\n    },\n    setup(props, { slots }) {\n        defineCustomElement('ion-tab-button', IonTabButtonCmp);\n        const ionRouter = inject('navManager');\n        const onClick = (ev) => {\n            if (ev.cancelable) {\n                ev.preventDefault();\n            }\n            /**\n             * Keeping track of the originalHref\n             * (i.e. /tabs/tab1) lets us redirect\n             * users back to a child page using currentHref\n             * (i.e. /tabs/tab1/child).\n             */\n            const { tab, href, _getTabState } = props;\n            const tabState = _getTabState();\n            const tappedTab = tabState.tabs[tab] || {};\n            const originalHref = tappedTab.originalHref || href;\n            const currentHref = tappedTab.currentHref || href;\n            const prevActiveTab = tabState.activeTab;\n            /**\n             * If we are still on the same\n             * tab as before, but the base href\n             * does not equal the current href,\n             * then we must be on a child page and\n             * should direct users back to the root\n             * of the tab.\n             */\n            if (prevActiveTab === tab) {\n                if (originalHref !== currentHref) {\n                    ionRouter.resetTab(tab);\n                }\n            }\n            else {\n                ionRouter.changeTab(tab, currentHref);\n            }\n        };\n        return () => {\n            return h('ion-tab-button', Object.assign({ onClick }, props), slots.default && slots.default());\n        };\n    }\n});\n//# sourceMappingURL=IonTabButton.js.map", "import { h, defineComponent } from 'vue';\nconst WILL_CHANGE = 'ionTabsWillChange';\nconst DID_CHANGE = 'ionTabsDidChange';\nexport const IonTabs = /*@__PURE__*/ defineComponent({\n    name: 'IonTabs',\n    emits: [WILL_CHANGE, DID_CHANGE],\n    render() {\n        var _a;\n        const { $slots: slots, $emit } = this;\n        const slottedContent = slots.default && slots.default();\n        let routerOutlet;\n        /**\n         * Developers must pass an ion-router-outlet\n         * inside of ion-tabs.\n         */\n        if (slottedContent && slottedContent.length > 0) {\n            routerOutlet = slottedContent.find((child) => child.type && child.type.name === 'IonRouterOutlet');\n        }\n        if (!routerOutlet) {\n            throw new Error('IonTabs must contain an IonRouterOutlet. See https://ionicframework.com/docs/vue/navigation#working-with-tabs for more information.');\n        }\n        let childrenToRender = [\n            h('div', {\n                class: 'tabs-inner',\n                style: {\n                    'position': 'relative',\n                    'flex': '1',\n                    'contain': 'layout size style'\n                }\n            }, routerOutlet)\n        ];\n        /**\n         * If ion-tab-bar has slot=\"top\" it needs to be\n         * rendered before `.tabs-inner` otherwise it will\n         * not show above the tab content.\n         */\n        if (slottedContent && slottedContent.length > 0) {\n            /**\n             * Render all content except for router outlet\n             * since that needs to be inside of `.tabs-inner`.\n             */\n            const filteredContent = slottedContent.filter((child) => (!child.type ||\n                (child.type && child.type.name !== 'IonRouterOutlet')));\n            const slottedTabBar = filteredContent.find((child) => child.type && child.type.name === 'IonTabBar');\n            const hasTopSlotTabBar = slottedTabBar && ((_a = slottedTabBar.props) === null || _a === void 0 ? void 0 : _a.slot) === 'top';\n            if (slottedTabBar) {\n                if (!slottedTabBar.props) {\n                    slottedTabBar.props = {};\n                }\n                /**\n                 * ionTabsWillChange and ionTabsDidChange are\n                 * fired from `ion-tabs`, so we need to pass these down\n                 * as props so they can fire when the active tab changes.\n                 * TODO: We may want to move logic from the tab bar into here\n                 * so we do not have code split across two components.\n                 */\n                slottedTabBar.props._tabsWillChange = (tab) => $emit(WILL_CHANGE, { tab });\n                slottedTabBar.props._tabsDidChange = (tab) => $emit(DID_CHANGE, { tab });\n            }\n            if (hasTopSlotTabBar) {\n                childrenToRender = [\n                    ...filteredContent,\n                    ...childrenToRender\n                ];\n            }\n            else {\n                childrenToRender = [\n                    ...childrenToRender,\n                    ...filteredContent\n                ];\n            }\n        }\n        return h('ion-tabs', {\n            style: {\n                'display': 'flex',\n                'position': 'absolute',\n                'top': '0',\n                'left': '0',\n                'right': '0',\n                'bottom': '0',\n                'flex-direction': 'column',\n                'width': '100%',\n                'height': '100%',\n                'contain': 'layout size style',\n                'z-index': '0'\n            }\n        }, childrenToRender);\n    }\n});\n//# sourceMappingURL=IonTabs.js.map", "import { h, defineComponent, getCurrentInstance, inject } from 'vue';\nimport { defineCustomElement } from '../utils';\nimport { IonTabBar as IonTabBarCmp } from '@ionic/core/components/ion-tab-bar.js';\nconst isTabButton = (child) => { var _a; return ((_a = child.type) === null || _a === void 0 ? void 0 : _a.name) === 'IonTabButton'; };\nconst getTabs = (nodes) => {\n    let tabs = [];\n    nodes.forEach((node) => {\n        if (isTabButton(node)) {\n            tabs.push(node);\n        }\n        else if (Array.isArray(node.children) && node.children.length > 1) {\n            const childTabs = getTabs(node.children);\n            tabs = [...tabs, ...childTabs];\n        }\n    });\n    return tabs;\n};\nexport const IonTabBar = defineComponent({\n    name: 'IonTabBar',\n    props: {\n        _tabsWillChange: { type: Function, default: () => { } },\n        _tabsDidChange: { type: Function, default: () => { } }\n    },\n    data() {\n        return {\n            tabState: {\n                activeTab: undefined,\n                tabs: {}\n            },\n            tabVnodes: []\n        };\n    },\n    updated() {\n        this.setupTabState(inject('navManager'));\n    },\n    methods: {\n        setupTabState(ionRouter) {\n            /**\n             * For each tab, we need to keep track of its\n             * base href as well as any child page that\n             * is active in its stack so that when we go back\n             * to a tab from another tab, we can correctly\n             * show any child pages if necessary.\n             */\n            const tabState = this.$data.tabState;\n            const currentInstance = getCurrentInstance();\n            const tabs = this.$data.tabVnodes = getTabs((currentInstance.subTree.children || []));\n            tabs.forEach(child => {\n                tabState.tabs[child.props.tab] = {\n                    originalHref: child.props.href,\n                    currentHref: child.props.href,\n                    ref: child\n                };\n                /**\n                 * Passing this prop to each tab button\n                 * lets it be aware of the state that\n                 * ion-tab-bar is managing for it.\n                 */\n                child.component.props._getTabState = () => tabState;\n            });\n            this.checkActiveTab(ionRouter);\n        },\n        checkActiveTab(ionRouter) {\n            const currentRoute = ionRouter.getCurrentRouteInfo();\n            const childNodes = this.$data.tabVnodes;\n            const { tabs, activeTab: prevActiveTab } = this.$data.tabState;\n            const tabState = this.$data.tabState;\n            const tabKeys = Object.keys(tabs);\n            const activeTab = tabKeys\n                .find(key => {\n                const href = tabs[key].originalHref;\n                return currentRoute.pathname.startsWith(href);\n            });\n            /**\n             * For each tab, check to see if the\n             * base href has changed. If so, update\n             * it in the tabs state.\n             */\n            childNodes.forEach((child) => {\n                const tab = tabs[child.props.tab];\n                if (!tab || (tab.originalHref !== child.props.href)) {\n                    tabs[child.props.tab] = {\n                        originalHref: child.props.href,\n                        currentHref: child.props.href,\n                        ref: child\n                    };\n                }\n            });\n            if (activeTab && prevActiveTab) {\n                const prevHref = this.$data.tabState.tabs[prevActiveTab].currentHref;\n                /**\n                 * If the tabs change or the url changes,\n                 * update the currentHref for the active tab.\n                 * Ex: url changes from /tabs/tab1 --> /tabs/tab1/child\n                 * If we went to tab2 then back to tab1, we should\n                 * land on /tabs/tab1/child instead of /tabs/tab1.\n                 */\n                if (activeTab !== prevActiveTab || (prevHref !== currentRoute.pathname)) {\n                    /**\n                     * By default the search is `undefined` in Ionic Vue,\n                     * but Vue Router can set the search to the empty string.\n                     * We check for truthy here because empty string is falsy\n                     * and currentRoute.search cannot ever be a boolean.\n                     */\n                    const search = (currentRoute.search) ? `?${currentRoute.search}` : '';\n                    tabs[activeTab] = Object.assign(Object.assign({}, tabs[activeTab]), { currentHref: currentRoute.pathname + search });\n                }\n                /**\n                 * If navigating back and the tabs change,\n                 * set the previous tab back to its original href.\n                 */\n                if (currentRoute.routerAction === 'pop' && (activeTab !== prevActiveTab)) {\n                    tabs[prevActiveTab] = Object.assign(Object.assign({}, tabs[prevActiveTab]), { currentHref: tabs[prevActiveTab].originalHref });\n                }\n            }\n            const activeChild = childNodes.find((child) => { var _a; return isTabButton(child) && ((_a = child.props) === null || _a === void 0 ? void 0 : _a.tab) === activeTab; });\n            const tabBar = this.$refs.ionTabBar;\n            const tabDidChange = activeTab !== prevActiveTab;\n            if (tabBar) {\n                if (activeChild) {\n                    tabDidChange && this.$props._tabsWillChange(activeTab);\n                    ionRouter.handleSetCurrentTab(activeTab);\n                    tabBar.selectedTab = tabState.activeTab = activeTab;\n                    tabDidChange && this.$props._tabsDidChange(activeTab);\n                    /**\n                     * When going to a tab that does\n                     * not have an associated ion-tab-button\n                     * we need to remove the selected state from\n                    * the old tab.\n                     */\n                }\n                else {\n                    tabBar.selectedTab = tabState.activeTab = '';\n                }\n            }\n        }\n    },\n    mounted() {\n        const ionRouter = inject('navManager');\n        this.setupTabState(ionRouter);\n        ionRouter.registerHistoryChangeListener(() => this.checkActiveTab(ionRouter));\n    },\n    setup(_, { slots }) {\n        defineCustomElement('ion-tab-bar', IonTabBarCmp);\n        return () => {\n            return h('ion-tab-bar', { ref: 'ionTabBar' }, slots.default && slots.default());\n        };\n    }\n});\n//# sourceMappingURL=IonTabBar.js.map", "import { h, defineComponent, shallowRef } from 'vue';\nimport { defineCustomElement } from '../utils';\nimport { IonApp as IonAppCmp } from '@ionic/core/components/ion-app.js';\nconst userComponents = shallowRef([]);\nexport const IonApp = /*@__PURE__*/ defineComponent((_, { attrs, slots }) => {\n    defineCustomElement('ion-app', IonAppCmp);\n    return () => {\n        return h('ion-app', Object.assign({}, attrs), [slots.default && slots.default(), ...userComponents.value]);\n    };\n});\n/**\n * When rendering user components inside of\n * ion-modal, or ion-popover the component\n * needs to be created inside of the current application\n * context otherwise libraries such as vue-i18n or vuex\n * will not work properly.\n *\n * `userComponents` renders teleported components as children\n * of `ion-app` within the current application context.\n */\nexport const addTeleportedUserComponent = (component) => {\n    userComponents.value = [\n        ...userComponents.value,\n        component\n    ];\n};\nexport const removeTeleportedUserComponent = (component) => {\n    userComponents.value = userComponents.value.filter(cmp => cmp !== component);\n};\n//# sourceMappingURL=IonApp.js.map", "import { h, Teleport } from 'vue';\nimport { addTeleportedUserComponent, removeTeleportedUserComponent } from './components/IonApp';\nexport const VueDelegate = (addFn = addTeleportedUserComponent, removeFn = removeTeleportedUserComponent) => {\n    let Component;\n    const attachViewToDom = (parentElement, component, componentProps = {}, classes) => {\n        /**\n         * Ionic Framework passes in modal and popover element\n         * refs as props, but if these are not defined\n         * on the Vue component instance as props, Vue will\n         * warn the user.\n         */\n        delete componentProps['modal'];\n        delete componentProps['popover'];\n        const div = document.createElement('div');\n        classes && div.classList.add(...classes);\n        parentElement.appendChild(div);\n        Component = h(Teleport, { to: div }, h(component, Object.assign({}, componentProps)));\n        addFn(Component);\n        return Promise.resolve(div);\n    };\n    const removeViewFromDom = () => {\n        Component && removeFn(Component);\n        return Promise.resolve();\n    };\n    return { attachViewToDom, removeViewFromDom };\n};\n//# sourceMappingURL=framework-delegate.js.map", "import { defineComponent, h, shallowRef } from 'vue';\nimport { VueDelegate } from '../framework-delegate';\nimport { defineCustomElement } from '../utils';\nimport { IonNav as IonNavCmp } from '@ionic/core/components/ion-nav.js';\nexport const IonNav = /*@__PURE__*/ defineComponent(() => {\n    defineCustomElement('ion-nav', IonNavCmp);\n    const views = shallowRef([]);\n    /**\n     * Allows us to create the component\n     * within the Vue application context.\n     */\n    const addView = (component) => views.value = [...views.value, component];\n    const removeView = (component) => views.value = views.value.filter(cmp => cmp !== component);\n    const delegate = VueDelegate(addView, removeView);\n    return () => {\n        return h('ion-nav', { delegate }, views.value);\n    };\n});\n//# sourceMappingURL=IonNav.js.map", "import { h, defineComponent } from 'vue';\nimport { isPlatform } from '@ionic/core/components';\nimport { defineCustomElement } from '../utils';\nimport { IonIcon as IonIconCmp } from 'ionicons/components/ion-icon.js';\nexport const IonIcon = /*@__PURE__*/ defineComponent({\n    name: 'IonIcon',\n    props: {\n        color: String,\n        flipRtl: Boolean,\n        icon: String,\n        ios: String,\n        lazy: String,\n        md: String,\n        mode: String,\n        name: String,\n        size: String,\n        src: String\n    },\n    setup(props, { slots }) {\n        defineCustomElement('ion-icon', IonIconCmp);\n        return () => {\n            var _a, _b;\n            const { icon, ios, md } = props;\n            let iconToUse;\n            if (ios || md) {\n                if (isPlatform('ios')) {\n                    iconToUse = (_a = ios !== null && ios !== void 0 ? ios : md) !== null && _a !== void 0 ? _a : icon;\n                }\n                else {\n                    iconToUse = (_b = md !== null && md !== void 0 ? md : ios) !== null && _b !== void 0 ? _b : icon;\n                }\n            }\n            else {\n                iconToUse = icon;\n            }\n            return h('ion-icon', Object.assign(Object.assign({}, props), { icon: iconToUse }), slots);\n        };\n    }\n});\n//# sourceMappingURL=IonIcon.js.map", "import { defineComponent, h, ref, onMounted } from 'vue';\nconst EMPTY_PROP = Symbol();\nconst DEFAULT_EMPTY_PROP = { default: EMPTY_PROP };\nexport const defineOverlayContainer = (name, defineCustomElement, componentProps = [], controller) => {\n    const createControllerComponent = () => {\n        return defineComponent((props, { slots, emit }) => {\n            const eventListeners = [\n                { componentEv: `${name}-will-present`, frameworkEv: 'willPresent' },\n                { componentEv: `${name}-did-present`, frameworkEv: 'didPresent' },\n                { componentEv: `${name}-will-dismiss`, frameworkEv: 'willDismiss' },\n                { componentEv: `${name}-did-dismiss`, frameworkEv: 'didDismiss' },\n            ];\n            if (defineCustomElement !== undefined) {\n                defineCustomElement();\n            }\n            const overlay = ref();\n            const onVnodeMounted = async () => {\n                const isOpen = props.isOpen;\n                isOpen && (await present(props));\n            };\n            const onVnodeUpdated = async (node, prevNode) => {\n                const isOpen = node.props.isOpen;\n                const prevIsOpen = prevNode.props.isOpen;\n                /**\n                 * Do not do anything if this prop\n                 * did not change.\n                 */\n                if (isOpen === prevIsOpen)\n                    return;\n                if (isOpen) {\n                    await present(props);\n                }\n                else {\n                    await dismiss();\n                }\n            };\n            const onVnodeBeforeUnmount = async () => {\n                await dismiss();\n            };\n            const dismiss = async () => {\n                if (!overlay.value)\n                    return;\n                await overlay.value;\n                overlay.value = overlay.value.dismiss();\n                await overlay.value;\n                overlay.value = undefined;\n            };\n            const present = async (props) => {\n                var _a;\n                /**\n                 * Do not open another instance\n                 * if one is already opened.\n                 */\n                if (overlay.value) {\n                    await overlay.value;\n                }\n                if ((_a = overlay.value) === null || _a === void 0 ? void 0 : _a.present) {\n                    await overlay.value.present();\n                    return;\n                }\n                let restOfProps = {};\n                /**\n                 * We can use Object.entries here\n                 * to avoid the hasOwnProperty check,\n                 * but that would require 2 iterations\n                 * where as this only requires 1.\n                 */\n                for (const key in props) {\n                    const value = props[key];\n                    if (props.hasOwnProperty(key) && value !== EMPTY_PROP) {\n                        restOfProps[key] = value;\n                    }\n                }\n                /**\n                 * These are getting passed as props.\n                 * Potentially a Vue bug with Web Components?\n                 */\n                delete restOfProps.onWillPresent;\n                delete restOfProps.onDidPresent;\n                delete restOfProps.onWillDismiss;\n                delete restOfProps.onDidDismiss;\n                const component = slots.default && slots.default()[0];\n                overlay.value = controller.create(Object.assign(Object.assign({}, restOfProps), { component }));\n                overlay.value = await overlay.value;\n                eventListeners.forEach(eventListener => {\n                    overlay.value.addEventListener(eventListener.componentEv, () => {\n                        emit(eventListener.frameworkEv);\n                    });\n                });\n                await overlay.value.present();\n            };\n            return () => {\n                return h('div', {\n                    style: { display: 'none' },\n                    onVnodeMounted,\n                    onVnodeUpdated,\n                    onVnodeBeforeUnmount,\n                    isOpen: props.isOpen === true\n                });\n            };\n        });\n    };\n    const createInlineComponent = () => {\n        return defineComponent((props, { slots }) => {\n            if (defineCustomElement !== undefined) {\n                defineCustomElement();\n            }\n            const isOpen = ref(false);\n            const elementRef = ref();\n            onMounted(() => {\n                elementRef.value.addEventListener('will-present', () => isOpen.value = true);\n                elementRef.value.addEventListener('did-dismiss', () => isOpen.value = false);\n            });\n            return () => {\n                let restOfProps = {};\n                /**\n                 * We can use Object.entries here\n                 * to avoid the hasOwnProperty check,\n                 * but that would require 2 iterations\n                 * where as this only requires 1.\n                 */\n                for (const key in props) {\n                    const value = props[key];\n                    if (props.hasOwnProperty(key) && value !== EMPTY_PROP) {\n                        restOfProps[key] = value;\n                    }\n                }\n                return h(name, Object.assign(Object.assign({}, restOfProps), { ref: elementRef }), (isOpen.value || restOfProps.keepContentsMounted) ? slots : undefined);\n            };\n        });\n    };\n    const Container = (controller !== undefined) ? createControllerComponent() : createInlineComponent();\n    Container.displayName = name;\n    Container.props = {\n        'isOpen': DEFAULT_EMPTY_PROP\n    };\n    componentProps.forEach(componentProp => {\n        Container.props[componentProp] = DEFAULT_EMPTY_PROP;\n    });\n    if (controller !== undefined) {\n        Container.emits = ['willPresent', 'didPresent', 'willDismiss', 'didDismiss'];\n    }\n    return Container;\n};\n//# sourceMappingURL=overlays.js.map", "/* auto-generated vue overlay proxies */\nimport { actionSheetController, alertController, loadingController, pickerController, toastController, } from '@ionic/core/components';\nimport { defineCustomElement as defineIonActionSheetCustomElement } from '@ionic/core/components/ion-action-sheet.js';\nimport { defineCustomElement as defineIonAlertCustomElement } from '@ionic/core/components/ion-alert.js';\nimport { defineCustomElement as defineIonLoadingCustomElement } from '@ionic/core/components/ion-loading.js';\nimport { defineCustomElement as defineIonPickerCustomElement } from '@ionic/core/components/ion-picker.js';\nimport { defineCustomElement as defineIonToastCustomElement } from '@ionic/core/components/ion-toast.js';\nimport { defineCustomElement as defineIonModalCustomElement } from '@ionic/core/components/ion-modal.js';\nimport { defineCustomElement as defineIonPopoverCustomElement } from '@ionic/core/components/ion-popover.js';\nimport { defineOverlayContainer } from '../vue-component-lib/overlays';\nexport const IonActionSheet = /*@__PURE__*/ defineOverlayContainer('ion-action-sheet', defineIonActionSheetCustomElement, ['animated', 'backdropDismiss', 'buttons', 'cssClass', 'enterAnimation', 'header', 'htmlAttributes', 'keyboardClose', 'leaveAnimation', 'mode', 'subHeader', 'translucent'], actionSheetController);\nexport const IonAlert = /*@__PURE__*/ defineOverlayContainer('ion-alert', defineIonAlertCustomElement, ['animated', 'backdropDismiss', 'buttons', 'cssClass', 'enterAnimation', 'header', 'htmlAttributes', 'inputs', 'keyboardClose', 'leaveAnimation', 'message', 'mode', 'subHeader', 'translucent'], alertController);\nexport const IonLoading = /*@__PURE__*/ defineOverlayContainer('ion-loading', defineIonLoadingCustomElement, ['animated', 'backdropDismiss', 'cssClass', 'duration', 'enterAnimation', 'htmlAttributes', 'keyboardClose', 'leaveAnimation', 'message', 'mode', 'showBackdrop', 'spinner', 'translucent'], loadingController);\nexport const IonPicker = /*@__PURE__*/ defineOverlayContainer('ion-picker', defineIonPickerCustomElement, ['animated', 'backdropDismiss', 'buttons', 'columns', 'cssClass', 'duration', 'enterAnimation', 'htmlAttributes', 'keyboardClose', 'leaveAnimation', 'mode', 'showBackdrop'], pickerController);\nexport const IonToast = /*@__PURE__*/ defineOverlayContainer('ion-toast', defineIonToastCustomElement, ['animated', 'buttons', 'color', 'cssClass', 'duration', 'enterAnimation', 'header', 'htmlAttributes', 'icon', 'keyboardClose', 'leaveAnimation', 'message', 'mode', 'position', 'translucent'], toastController);\nexport const IonModal = /*@__PURE__*/ defineOverlayContainer('ion-modal', defineIonModalCustomElement, ['animated', 'backdropBreakpoint', 'backdropDismiss', 'breakpoints', 'canDismiss', 'enterAnimation', 'handle', 'handleBehavior', 'htmlAttributes', 'initialBreakpoint', 'isOpen', 'keepContentsMounted', 'keyboardClose', 'leaveAnimation', 'mode', 'presentingElement', 'showBackdrop', 'swipeToClose', 'trigger']);\nexport const IonPopover = /*@__PURE__*/ defineOverlayContainer('ion-popover', defineIonPopoverCustomElement, ['alignment', 'animated', 'arrow', 'backdropDismiss', 'component', 'componentProps', 'dismissOnSelect', 'enterAnimation', 'event', 'htmlAttributes', 'isOpen', 'keepContentsMounted', 'keyboardClose', 'leaveAnimation', 'mode', 'reference', 'showBackdrop', 'side', 'size', 'translucent', 'trigger', 'triggerAction']);\n//# sourceMappingURL=Overlays.js.map", "import { modalController as modalCtrl, popoverController as popoverCtrl, alertController as alertCtrl, actionSheetController as actionSheetCtrl, loadingController as loadingCtrl, pickerController as pickerCtrl, toastController as toastCtrl, } from '@ionic/core/components';\nimport { VueDelegate } from './framework-delegate';\nimport { defineCustomElement as defineIonActionSheetCustomElement } from '@ionic/core/components/ion-action-sheet.js';\nimport { defineCustomElement as defineIonAlertCustomElement } from '@ionic/core/components/ion-alert.js';\nimport { defineCustomElement as defineIonLoadingCustomElement } from '@ionic/core/components/ion-loading.js';\nimport { defineCustomElement as defineIonPickerCustomElement } from '@ionic/core/components/ion-picker.js';\nimport { defineCustomElement as defineIonToastCustomElement } from '@ionic/core/components/ion-toast.js';\nimport { defineCustomElement as defineIonModalCustomElement } from '@ionic/core/components/ion-modal.js';\nimport { defineCustomElement as defineIonPopoverCustomElement } from '@ionic/core/components/ion-popover.js';\n/**\n * Wrap the controllers export from @ionic/core\n * register the underlying Web Component and\n * (optionally) provide a framework delegate.\n */\nconst createController = (defineCustomElement, oldController, useDelegate = false) => {\n    const delegate = useDelegate ? VueDelegate() : undefined;\n    const oldCreate = oldController.create.bind(oldController);\n    oldController.create = (options) => {\n        defineCustomElement();\n        return oldCreate(Object.assign(Object.assign({}, options), { delegate }));\n    };\n    return oldController;\n};\nconst modalController = /*@__PURE__*/ createController(defineIonModalCustomElement, modalCtrl, true);\nconst popoverController = /*@__PURE__*/ createController(defineIonPopoverCustomElement, popoverCtrl, true);\nconst alertController = /*@__PURE__*/ createController(defineIonAlertCustomElement, alertCtrl);\nconst actionSheetController = /*@__PURE__*/ createController(defineIonActionSheetCustomElement, actionSheetCtrl);\nconst loadingController = /*@__PURE__*/ createController(defineIonLoadingCustomElement, loadingCtrl);\nconst pickerController = /*@__PURE__*/ createController(defineIonPickerCustomElement, pickerCtrl);\nconst toastController = /*@__PURE__*/ createController(defineIonToastCustomElement, toastCtrl);\nexport { modalController, popoverController, alertController, actionSheetController, loadingController, pickerController, toastController };\n//# sourceMappingURL=controllers.js.map"],
  "mappings": "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J,CAAC;AACW,IAAC,UAAwB,gBAAgB,YAAYC,uBAAe;EAC5E;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACJ,CAAC;AACW,IAAC,iBAA+B,gBAAgB,oBAAoBC,qBAAoB;AACxF,IAAC,gBAA8B,gBAAgB,mBAAmBC,uBAAqB;EAC/F;EACA;AACJ,CAAC;AACW,IAAC,kBAAgC,gBAAgB,qBAAqBC,uBAAuB;EACrG;AACJ,CAAC;AACW,IAAC,eAA6B,gBAAgB,kBAAkBC,uBAAoB;EAC5F;AACJ,CAAC;AACW,IAAC,cAA4B,gBAAgB,gBAAgBC,uBAAmB;EACxF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACJ,GAAG,WAAW,gBAAgB,WAAW;AAC7B,IAAC,UAAwB,gBAAgB,YAAYC,uBAAe;EAC5E;EACA;EACA;AACJ,CAAC;AACW,IAAC,SAAuB,gBAAgB,WAAWC,uBAAc;EACzE;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACJ,CAAC;AACW,IAAC,aAA2B,gBAAgB,eAAeC,uBAAkB;EACrF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACJ,CAAC;AACW,IAAC,cAA4B,gBAAgB,gBAAgBC,uBAAmB;EACxF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACJ,GAAG,SAAS,gBAAgB,WAAW;AAC3B,IAAC,oBAAkC,gBAAgB,uBAAuBC,uBAAyB;EAC3G;EACA;EACA;AACJ,CAAC;AACW,IAAC,SAAuB,gBAAgB,WAAWC,uBAAc;EACzE;EACA;EACA;EACA;AACJ,CAAC;AACW,IAAC,eAA6B,gBAAgB,kBAAkBC,uBAAoB;EAC5F;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACJ,CAAC;AACW,IAAC,aAA2B,gBAAgB,gBAAgBC,uBAAkB;EACtF;EACA;AACJ,CAAC;AACW,IAAC,YAA0B,gBAAgB,cAAcC,uBAAiB;EAClF;EACA;AACJ,CAAC;AACW,IAAC,UAAwB,gBAAgB,YAAYC,uBAAe;EAC5E;AACJ,CAAC;AACW,IAAC,YAA0B,gBAAgB,cAAcC,uBAAiB;EAClF;EACA;AACJ,CAAC;AACW,IAAC,SAAuB,gBAAgB,WAAWC,uBAAc;EACzE;EACA;EACA;EACA;EACA;AACJ,CAAC;AACW,IAAC,oBAAkC,gBAAgB,uBAAuBC,uBAAyB;EAC3G;EACA;EACA;EACA;AACJ,CAAC;AACW,IAAC,2BAAyC,gBAAgB,+BAA+BC,uBAAgC;EACjI;EACA;AACJ,CAAC;AACW,IAAC,WAAyB,gBAAgB,aAAaC,uBAAgB;EAC/E;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACJ,GAAG,SAAS,gBAAgB,WAAW;AAC3B,IAAC,UAAwB,gBAAgB,YAAYC,uBAAe;EAC5E;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACJ,CAAC;AACW,IAAC,iBAA+B,gBAAgB,oBAAoBC,uBAAsB;EAClG;EACA;AACJ,CAAC;AACW,IAAC,eAA6B,gBAAgB,kBAAkBC,qBAAkB;AAClF,IAAC,gBAA8B,gBAAgB,mBAAmBC,uBAAqB;EAC/F;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACJ,CAAC;AACW,IAAC,iBAA+B,gBAAgB,oBAAoBC,uBAAsB;EAClG;EACA;AACJ,CAAC;AACW,IAAC,iBAA+B,gBAAgB,oBAAoBC,uBAAsB;EAClG;EACA;AACJ,CAAC;AACW,IAAC,WAAyB,gBAAgB,aAAaC,uBAAgB;EAC/E;EACA;EACA;EACA;AACJ,CAAC;AACW,IAAC,UAAwB,gBAAgB,YAAYC,uBAAe;EAC5E;EACA;AACJ,CAAC;AACW,IAAC,gBAA8B,gBAAgB,mBAAmBC,uBAAqB;EAC/F;EACA;AACJ,CAAC;AACW,IAAC,UAAwB,gBAAgB,YAAYC,uBAAe;EAC5E;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACJ,CAAC;AACW,IAAC,gBAA8B,gBAAgB,mBAAmBC,uBAAqB;EAC/F;EACA;EACA;EACA;EACA;AACJ,CAAC;AACW,IAAC,gBAA8B,gBAAgB,mBAAmBC,uBAAqB;EAC/F;EACA;AACJ,CAAC;AAYW,IAAC,aAA2B,gBAAgB,gBAAgBC,uBAAkB;EACtF;EACA;EACA;EACA;AACJ,CAAC;AACW,IAAC,UAAwB,gBAAgB,YAAYC,uBAAe;EAC5E;AACJ,CAAC;AACW,IAAC,iBAA+B,gBAAgB,oBAAoBC,uBAAsB;EAClG;EACA;EACA;EACA;EACA;AACJ,CAAC;AACW,IAAC,WAAyB,gBAAgB,aAAaC,uBAAgB;EAC/E;EACA;EACA;EACA;EACA;EACA;EACA;AACJ,GAAG,SAAS,gBAAgB,WAAW;AAC3B,IAAC,gBAA8B,gBAAgB,mBAAmBC,uBAAqB;EAC/F;EACA;EACA;EACA;AACJ,GAAG,SAAS,gBAAgB,WAAW;AAC3B,IAAC,WAAyB,gBAAgB,aAAaC,uBAAgB;EAC/E;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACJ,GAAG,SAAS,gBAAgB,WAAW;AAC3B,IAAC,eAA6B,gBAAgB,iBAAiBC,uBAAoB;EAC3F;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACJ,CAAC;AACW,IAAC,sBAAoC,gBAAgB,yBAAyBC,uBAA2B;EACjH;EACA;EACA;EACA;AACJ,CAAC;AACW,IAAC,aAA2B,gBAAgB,eAAeC,qBAAgB;AAC3E,IAAC,kBAAgC,gBAAgB,qBAAqBC,uBAAuB;EACrG;EACA;AACJ,CAAC;AACW,IAAC,kBAAgC,gBAAgB,qBAAqBC,uBAAuB;EACrG;AACJ,CAAC;AACW,IAAC,SAAuB,gBAAgB,WAAWC,qBAAY;AAC/D,IAAC,eAA6B,gBAAgB,iBAAiBC,uBAAoB;EAC3F;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACJ,GAAG,SAAS,gBAAgB,WAAW;AAC3B,IAAC,aAA2B,gBAAgB,eAAeC,uBAAkB;EACrF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACJ,GAAG,SAAS,gBAAgB,WAAW;AAC3B,IAAC,mBAAiC,gBAAgB,sBAAsBC,uBAAwB;EACxG;EACA;EACA;EACA;AACJ,GAAG,SAAS,gBAAgB,WAAW;AAC3B,IAAC,YAA0B,gBAAgB,cAAcC,uBAAiB;EAClF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACJ,GAAG,SAAS,gBAAgB,WAAW;AAC3B,IAAC,kBAAgC,gBAAgB,qBAAqBC,uBAAuB;EACrG;EACA;AACJ,CAAC;AACW,IAAC,kBAAgC,gBAAgB,qBAAqBC,uBAAuB;EACrG;AACJ,CAAC;AACW,IAAC,WAAyB,gBAAgB,aAAaC,qBAAc;AACrE,IAAC,YAA0B,gBAAgB,cAAcC,uBAAiB;EAClF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACJ,CAAC;AACW,IAAC,aAA2B,gBAAgB,eAAeC,uBAAkB;EACrF;EACA;EACA;EACA;AACJ,CAAC;AACW,IAAC,eAA6B,gBAAgB,kBAAkBC,uBAAoB;EAC5F;EACA;EACA;EACA;AACJ,CAAC;AACW,IAAC,UAAwB,gBAAgB,YAAYC,uBAAe;EAC5E;AACJ,CAAC;AACW,IAAC,cAA4B,gBAAgB,gBAAgBC,uBAAmB;EACxF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACJ,GAAG,SAAS,gBAAgB,WAAW;AAC3B,IAAC,eAA6B,gBAAgB,iBAAiBC,qBAAkB;AACjF,IAAC,WAAyB,gBAAgB,aAAaC,uBAAgB;EAC/E;EACA;EACA;AACJ,CAAC;AACW,IAAC,YAA0B,gBAAgB,cAAcC,uBAAiB;EAClF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACJ,GAAG,WAAW,gBAAgB,WAAW;AAC7B,IAAC,aAA2B,gBAAgB,eAAeC,uBAAkB;EACrF;AACJ,CAAC;AACW,IAAC,mBAAiC,gBAAgB,sBAAsBC,uBAAwB;EACxG;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACJ,CAAC;AC3rBW,IAAC,gBAAgB,CAAC,UAAU,YAAY;AAChD,QAAM,WAAW,CAAC,OAAO,GAAG,OAAO,SAAS,UAAU,OAAO;AAC7D,QAAM,aAAa,MAAM,SAAS,oBAAoB,iBAAiB,QAAQ;AAC/E,WAAS,iBAAiB,iBAAiB,QAAQ;AACnD,SAAO,EAAE,WAAU;AACvB;ACJY,IAAC,cAAc,MAAM;AAC7B,MAAI,SAAS,IAAI,KAAK;AACtB,MAAI,iBAAiB,IAAI,CAAC;AAC1B,QAAM,eAAe,CAAC,OAAO;AACzB,WAAO,QAAQ;AACf,mBAAe,QAAQ,GAAG,OAAO;EACzC;AACI,QAAM,eAAe,MAAM;AACvB,WAAO,QAAQ;AACf,mBAAe,QAAQ;EAC/B;AACI,QAAM,aAAa,MAAM;AACrB,QAAI,OAAO,WAAW,aAAa;AAC/B,aAAO,oBAAoB,sBAAsB,YAAY;AAC7D,aAAO,oBAAoB,sBAAsB,YAAY;IACzE;EACA;AACI,MAAI,OAAO,WAAW,aAAa;AAC/B,WAAO,iBAAiB,sBAAsB,YAAY;AAC1D,WAAO,iBAAiB,sBAAsB,YAAY;EAClE;AACI,SAAO;IACH;IACA;IACA;EACR;AACA;AC1BO,IAAI;CACV,SAAUC,iBAAgB;AACvB,EAAAA,gBAAe,WAAW,IAAI;AAC9B,EAAAA,gBAAe,UAAU,IAAI;AAC7B,EAAAA,gBAAe,WAAW,IAAI;AAC9B,EAAAA,gBAAe,UAAU,IAAI;AACjC,GAAG,mBAAmB,iBAAiB,CAAA,EAAG;AAC1C,IAAM,YAAY;EACd,CAAC,oBAAoB,GAAG,eAAe;EACvC,CAAC,mBAAmB,GAAG,eAAe;EACtC,CAAC,oBAAoB,GAAG,eAAe;EACvC,CAAC,mBAAmB,GAAG,eAAe;AAC1C;AACA,IAAM,MAAM,EAAE,MAAM,EAAC;AACd,IAAM,aAAa,CAAC,OAAO,WAAW;AACzC,MAAI;AACJ,QAAM,OAAO,KAAK,IAAI,IAAI,OAAO,QAAQ,OAAO,SAAS,KAAK,KAAK;AACnE,MAAI,IAAI,IAAI;AACZ,SAAQ,GAAI,SAAQ;AACxB;AAEO,IAAM,gBAAgB,CAAC,cAAc,aAAa,cAAc;AACnE,MAAI,iBAAiB,QAAQ,iBAAiB,SAAS,SAAS,aAAa,SAAS,GAAG;AACrF,iBAAa,SAAS,EAAE,KAAK,gBAAgB,QAAQ,gBAAgB,SAAS,SAAS,YAAY,KAAK,EAAC;EACjH;AACI,QAAM,WAAW,gBAAgB,QAAQ,gBAAgB,SAAS,SAAS,YAAY;AACvF,MAAI,aAAa,QAAQ,aAAa,SAAS,SAAS,SAAS,SAAS,GAAG;AACzE,aAAS,SAAS,EAAC;EAC3B;AAKI,MAAI,UAAU;AACV,UAAM,OAAO,UAAU,SAAS;AAChC,UAAM,QAAQ,SAAS,IAAI;AAC3B,QAAI,OAAO;AACP,YAAM,QAAQ,CAACC,UAASA,MAAI,CAAE;IAC1C;EACA;AACA;AACO,IAAM,YAAY,MAAM;AAC3B,MAAI,OAAO,WAAW,aAAa;AAC/B,UAAM,QAAQ,OAAO;AACrB,QAAI,SAAS,MAAM,QAAQ;AACvB,aAAO,MAAM;IACzB;EACA;AACI,SAAO;AACX;AACO,IAAMzE,wBAAsB,CAAC,SAAS,kBAAkB;AAC3D,MAAI,OAAO,mBAAmB;AAC1B;AACJ,MAAI,CAAC,eAAe,IAAI,OAAO,GAAG;AAC9B,mBAAe,OAAO,SAAS,aAAa;EACpD;AACA;ACnDA,IAAM,aAAa,CAAC,eAAe,MAAM,cAAc;AACnD,MAAI,WAAW;AAEX,UAAM,SAAS;AACf,UAAM,QAAQ,OAAO,MAAM,aAAa,MAAM,OAAO,MAAM,aAAa,IAAI,CAAA;AAI5E,QAAI,OAAO,SAAS;AAChB,aAAO,QAAQ,aAAa,IAAI;IAC5C;AACQ,UAAM,cAAc,IAAI,SAAS;AAC7B,UAAI,OAAO,aAAa;AACpB;MAChB;AACY,aAAO,OAAO,KAAK,GAAG,IAAI,IAAI,KAAI;IAC9C;AACQ,UAAM,KAAK,WAAW;AACtB,WAAO;EACf,OACS;AACD,YAAQ,KAAK,mFAAmF;EACxG;AACA;AACA,IAAM,aAAa,CAAC,cAAc;AAC9B,SAAO,CAAC,MAAM,SAAS,mBAAkB,MAAO,WAAW,WAAW,MAAM,MAAM;AACtF;AACY,IAAC,qBAAqB,WAAW,eAAe,SAAS;AACzD,IAAC,oBAAoB,WAAW,eAAe,QAAQ;AACvD,IAAC,qBAAqB,WAAW,eAAe,SAAS;AACzD,IAAC,oBAAoB,WAAW,eAAe,QAAQ;AC/BvD,IAAC,eAAe,MAAM;AAC9B,QAAM,EAAE,WAAW,QAAQ,WAAW,eAAc,IAAK,OAAO,YAAY;AAC5E,QAAM,WAAW,CAAC,UAAU,iBAAiB,cAAc,oBAAoB,eAAe,UAAU,cAAc,iBAAiB,eAAe;AACtJ,QAAM,OAAO,CAAC,UAAU,oBAAoB,SAAS,UAAU,WAAW,QAAQ,eAAe;AACjG,QAAM,UAAU,CAAC,UAAU,oBAAoB,SAAS,UAAU,QAAQ,WAAW,eAAe;AACpG,QAAM,OAAO,CAAC,oBAAoB,OAAO,eAAe;AACxD,QAAM,UAAU,CAAC,oBAAoB,UAAU,eAAe;AAC9D,SAAO;IACH;IACA;IACA;IACA;IACA;IACA;EACR;AACA;ACbA,IAAM,cAAc,CAAC,cAAc,cAAc,cAAc,iBAAiB,UAAU,QAAQ,gCAAgC,OAAO,EAAE,YAAW;AACtJ,IAAM,qBAAqB,MAAM;AAC7B,SAAO;IACH,KAAK,CAAC,IAAI,WAAW,IAAI,SAAS,GAAG,iBAAiB,YAAY,SAAS,GAAG,IAAI,IAAI;IACtF,KAAK,CAAC,IAAI,WAAW,IAAI,SAAS,GAAG,oBAAoB,YAAY,SAAS,GAAG,IAAI,IAAI;IACzF,IAAI,CAAC,WAAW,SAAS,IAAI,YAAY,YAAY,SAAS,GAAG,IAAI;EAC7E;AACA;AACY,IAAC,WAAW;EACpB,MAAM,QAAQ,GAAG,SAAS,CAAA,GAAI;AAQ1B,QAAI,OAAO,aAAa,aAAa;AACjC,eAAS,gBAAgB,UAAU,IAAI,QAAQ;IAC3D;AACQ,UAAM,EAAE,KAAK,KAAK,GAAE,IAAK,mBAAkB;AAC3C,eAAW,OAAO,OAAO,OAAO,OAAO,CAAA,GAAI,MAAM,GAAG,EAAE,MAAM,KAAK,MAAM,KAAK,KAAK,GAAE,CAAE,CAAC;EAC9F;AACA;AC1BY,IAAC0E,iBAA8B,gBAAgB,CAAC,GAAG,EAAE,OAAO,MAAK,MAAO;AAChF,EAAA1E,sBAAoB,mBAAmB2E,aAAgB;AACvD,EAAA3E,sBAAoB,YAAY4E,OAAU;AAC1C,QAAM,YAAY,OAAO,YAAY;AACrC,QAAM,UAAU,MAAM;AAClB,UAAM,cAAc,MAAM,cAAc,KAAK,MAAM,aAAa;AAChE,UAAM,kBAAkB,MAAM,kBAAkB,KAAK,MAAM,iBAAiB;AAC5E,cAAU,mBAAmB,aAAa,eAAe;EACjE;AACI,SAAO,MAAM;AACT,WAAO,EAAE,mBAAmB,OAAO,OAAO,EAAE,QAAO,GAAI,KAAK,GAAG,MAAM,WAAW,MAAM,QAAO,CAAE;EACvG;AACA,CAAC;ACfW,IAAC,UAAwB,gBAAgB;EACjD,MAAM;EACN,OAAO;IACH,iBAAiB,EAAE,MAAM,UAAU,SAAS,MAAM;IAAA,EAAG;EAC7D;EACI,UAAU;AACN,SAAK,OAAO,gBAAgB,KAAK,MAAM,OAAO;EACtD;EACI,MAAM,GAAG,EAAE,OAAO,MAAK,GAAI;AACvB,WAAO,MAAM;AACT,aAAO,EAAE,OAAO,OAAO,OAAO,OAAO,OAAO,CAAA,GAAI,KAAK,GAAG,EAAE,CAAC,OAAO,GAAG,YAAY,KAAK,UAAS,CAAE,GAAG,MAAM,WAAW,MAAM,QAAO,CAAE;IAChJ;EACA;AACA,CAAC;ACTD,IAAM,gBAAgB,CAAC,eAAe;AAClC,SAAO,CAAC,WAAW,UAAU,SAAS,iBAAiB,KAAK,CAAC,WAAW,UAAU,SAAS,oBAAoB;AACnH;AACA,IAAI,eAAe,OAAO,CAAC;AACf,IAACC,mBAAgC,gBAAgB;EACzD,MAAM;EACN,QAAQ;AACJ,IAAA7E,sBAAoB,qBAAqB8E,eAAkB;AAC3D,UAAM,gBAAgB,OAAO,gBAAgB;AAC7C,UAAM,QAAQ,SAAQ;AACtB,UAAM,QAAQ,OAAO,cAAc,CAAC;AACpC,UAAM,kBAAkB,SAAS,MAAM,MAAM,QAAQ,KAAK,CAAC;AAC3D,QAAI;AACJ,QAAI;AACJ,YAAQ,cAAc,QAAQ,CAAC;AAC/B,YAAQ,iBAAiB,eAAe;AACxC,UAAM,kBAAkB,IAAG;AAC3B,UAAM,KAAK,WAAW,mBAAmB;AAEzC,UAAM,YAAY,OAAO,YAAY;AACrC,UAAM,aAAa,OAAO,YAAY;AACtC,UAAM,aAAa,WAAW,CAAA,CAAE;AAChC,QAAI,iBAAiB;AAErB,QAAI;AAOJ,UAAM,MAAM,CAAC,OAAO,gBAAgB,KAAK,GAAG,CAAC,CAAC,cAAc,sBAAsB,MAAM;AAgCpF,UAAI,2BAA2B,QAAW;AACtC,cAAM,yBAAyB,2BAA2B;AAC1D,cAAM,kCAAmC,aAAa,QAAQ,aAAa,QAAQ,SAAS,CAAC,MAAM,0BAC/F,aAAa,SAAS;AAC1B,YAAI,0BAA0B,iCAAiC;AAC3D,wBAAc,eAAe;QACjD;MACA;AACY,gCAA0B;AAC1B,4BAAsB,aAAa;IAC/C,CAAS;AACD,UAAM,WAAW,MAAM;AACnB,YAAM,SAAS,UAAS;AACxB,YAAM,eAAe,UAAU,OAAO,IAAI,oBAAoB,gBAAgB,MAAM,SAAS,KAAK;AAClG,UAAI,CAAC;AACD,eAAO;AACX,YAAM,QAAQ,WAAW,aAAa,EAAE;AACxC,UAAI,CAAC,SAAS,MAAM,UAAU;AAC1B,eAAO;AAMX,YAAM,YAAY,UAAU,oBAAmB;AAC/C,YAAM,mBAAmB,WAAW,wBAAwB,EAAE,UAAU,UAAU,iBAAiB,GAAE,GAAI,EAAE;AAC3G,aAAO,CAAC,CAAC;IACrB;AACQ,UAAM,UAAU,YAAY;AACxB,YAAM,YAAY,UAAU,oBAAmB;AAC/C,YAAM,EAAE,gBAAe,IAAK;AAC5B,YAAM,mBAAmB,WAAW,wBAAwB,EAAE,UAAU,UAAU,iBAAiB,GAAE,GAAI,EAAE;AAC3G,YAAM,kBAAkB,WAAW,wBAAwB,WAAW,EAAE;AACxE,UAAI,iBAAiB;AACjB,YAAI,mBAAmB;AACvB,cAAM,aAAa,iBAAiB;AACpC,cAAM,YAAY,gBAAgB;AAQlC,cAAM,kBAAkB,iBAAiB;AACzC,YAAI,qBAAqB;QAErB,oBAAoB,QAAW;AAC/B,6BAAmB;QACvC;AACgB,wBAAgB,kBAAkB;AAClC,cAAM,WAAW,YAAY,WAAW,QAAQ,UAAU,UAAU,CAAC,GAAG,MAAM,gBAAgB;MAC9G;AACY,aAAO,QAAQ,QAAO;IAClC;AACQ,UAAM,QAAQ,CAAC,mBAAmB;AAC9B,UAAI,gBAAgB;AAChB,yBAAiB;AAMjB,kBAAU,mBAAkB;MAC5C,OACiB;AAMD,cAAM,YAAY,UAAU,oBAAmB;AAC/C,cAAM,mBAAmB,WAAW,wBAAwB,EAAE,UAAU,UAAU,iBAAiB,GAAE,GAAI,EAAE;AAC3G,yBAAiB,eAAe,aAAa,eAAe,MAAM;AAClE,yBAAiB,eAAe,UAAU,IAAI,iBAAiB;MAC/E;IACA;AACQ,UAAM,iBAAiB,MAAM;AACzB,sBAAgB,MAAM,eAAe;QACjC;QACA;QACA;MAChB;IACA,CAAS;AACD,UAAM,aAAa,CAAC,YAAY,WAAW,WAC3C,YAAY,mBAAmB,qBAAqB;AAChD,aAAO,IAAI,QAAQ,aAAW;AAC1B,YAAI,gBAAgB;AAChB,2BAAiB;AACjB,iBAAO,QAAQ,KAAK;QACxC;AACgB,YAAI,eAAe,WAAW;AAC1B,iBAAO,QAAQ,KAAK;QACxC;AACgB,8BAAsB,MAAM;AACxB,gCAAsB,YAAY;AAC9B,uBAAW,UAAU,IAAI,oBAAoB;AAC7C,kBAAM,SAAS,MAAM,gBAAgB,MAAM,OAAO,YAAY,WAAW;cACrE,UAAU;cACV,UAAU,cAAc,UAAa,cAAc,UAAU,cAAc,SAAS,IAAI;cACxF;cACA;cACA;cACA;YAC5B,CAAyB;AACD,mBAAO,QAAQ,MAAM;UAC7C,CAAqB;QACrB,CAAiB;MACjB,CAAa;IACb;AACQ,UAAM,uBAAuB,YAAY;AACrC,YAAM,YAAY,UAAU,oBAAmB;AAC/C,YAAM,EAAE,iBAAiB,cAAc,iBAAiB,uBAAuB,MAAK,IAAK;AACzF,YAAM,mBAAmB,WAAW,wBAAwB,WAAW,EAAE;AACzE,UAAI,kBAAkB,WAAW,+BAA+B,WAAW,EAAE;AAC7E,YAAM,aAAa,iBAAiB;AAMpC,UAAI,eAAe,QAAW;AAC1B,gBAAQ,KAAK,oEAAoE,UAAU;;iFAE1B;MACjF;AACY,UAAI,qBAAqB;AACrB;AACJ,UAAI,CAAC,mBAAmB,uBAAuB;AAC3C,0BAAkB,WAAW,uBAAuB,uBAAuB,EAAE;MAC7F;AAoBY,UAAI,cAAc,UAAU,MAAM,oBAAoB,QAAQ,oBAAoB,SAAS,SAAS,gBAAgB,oBAAoB,UAAa,CAAC,cAAc,gBAAgB,cAAc,GAAG;AACjM;MAChB;AACY,oBAAc,iBAAiB,cAAc,iBAAiB,iBAAiB,oBAAoB;AACnG,WAAK,oBAAoB,QAAQ,oBAAoB,SAAS,SAAS,gBAAgB,mBAAmB,qBAAqB,iBAAiB;AAC5I,YAAI,mBAAmB;AACvB,cAAM,YAAY,gBAAgB;AAClC,sBAAc,gBAAgB,cAAc,gBAAgB,iBAAiB,oBAAoB;AAQjG,cAAM,kBAAkB,iBAAiB;AACzC,YAAI,qBAAqB,UACrB,oBAAoB;QAEpB,oBAAoB,QAAW;AAC/B,6BAAmB;QACvC;AACgB,wBAAgB,kBAAkB;AAClC,cAAM,WAAW,YAAY,WAAW,iBAAiB,CAAC,CAAC,UAAU,eAAe,OAAO,gBAAgB;AAC3G,kBAAU,UAAU,IAAI,iBAAiB;AACzC,kBAAU,aAAa,eAAe,MAAM;AAC5C,cAAM,wBAAwB,WAAW,KAAI,MAAO;AACpD,YAAI,iBAAiB,WAAW;AAC5B,0BAAgB,QAAQ;AACxB,0BAAgB,iBAAiB;AACjC,0BAAgB,WAAW;QAC/C,WACyB,EAAE,iBAAiB,UAAU,oBAAoB,YAAY;AAClE,gBAAM,6BAA6B,oBAAoB,UAAU,mBAAoB,qBAAqB;AAC1G,cAAI,4BAA4B;AAC5B,4BAAgB,QAAQ;AACxB,4BAAgB,iBAAiB;AACjC,4BAAgB,WAAW;AAO3B,gBAAI,uBAAuB;AACvB,yBAAW,oBAAoB,IAAI,kBAAkB,KAAK;YACtF;UACA;QACA,WACyB,uBAAuB;AAC5B,qBAAW,uBAAuB,IAAI,iBAAiB,KAAK;QAChF;AACgB,sBAAc,gBAAgB,cAAc,gBAAgB,iBAAiB,mBAAmB;MAChH,OACiB;AAOD,8BAAsB,MAAM,WAAW,UAAU,OAAO,oBAAoB,CAAC;MAC7F;AACY,oBAAc,iBAAiB,cAAc,iBAAiB,iBAAiB,mBAAmB;AAClG,iBAAW,QAAQ,WAAW,oBAAoB,EAAE;IAChE;AACQ,UAAM,gBAAgB,CAACC,qBAAoB;AACvC,YAAM,oBAAoB,MAAM,QAAQ,CAAC;AACzC,UAAI,CAAC,kBAAkB;AACnB,2BAAmB,kBAAkB;MACrD;AAWY,UAAI,CAACA,iBAAgB,SAChBA,iBAAgB,UAAU,qBAAqB,kBAAkB,SAAS,kBAAmB;AAC9F;MAChB;AACY,YAAM,eAAe,UAAU,oBAAmB;AAClD,UAAI,mBAAmB,WAAW,wBAAwB,cAAc,EAAE;AAC1E,UAAI,CAAC,kBAAkB;AACnB,2BAAmB,WAAW,eAAe,IAAIA,iBAAgB,MAAM,WAAW,SAASA,iBAAgB,OAAO,YAAY;AAC9H,mBAAW,IAAI,gBAAgB;MAC/C;AACY,UAAI,CAAC,iBAAiB,OAAO;AACzB,yBAAiB,QAAQ;AACzB,yBAAiB,mBAAmB,MAAM;AACtC,+BAAoB;AACpB,2BAAiB,mBAAmB;QACxD;MACA,OACiB;AACD,6BAAoB;MACpC;AACY,iBAAW,QAAQ,WAAW,oBAAoB,EAAE;IAChE;AACQ,QAAI,gBAAgB,OAAO;AACvB,oBAAc,eAAe;IACzC;AAMQ,gBAAY,MAAM,WAAW,MAAM,EAAE,CAAC;AAEtC,UAAM,kBAAkB,CAAC,UAAU,cAAc;AAC7C,YAAM,eAAe,SAAS;AAC9B,iBAAW,gBAAgB,UAAU,SAAS;AAM9C,UAAI,SAAS,kBAAkB;AAK3B,kBAAU,UAAU,IAAI,oBAAoB;AAC5C,iBAAS,iBAAgB;MAUzC,WACqB,gBAAgB,CAAC,aAAa,UAAU,SAAS,oBAAoB,GAAG;AAC7E,kBAAU,UAAU,OAAO,oBAAoB;MAC/D;IACA;AACQ,WAAO;MACH;MACA;MACA;MACA;MACA;IACZ;EACA;EACI,SAAS;AACL,UAAM,EAAE,YAAY,iBAAiB,cAAa,IAAK;AACvD,WAAO;MAAE;MAAqB,EAAE,KAAK,kBAAiB;;MAEtD,cAAc,WAAW,IAAI,CAAC,MAAM;AAChC,YAAI,IAAI;AACR,YAAI,QAAQ;UACR,KAAK,EAAE;UACP,KAAK,EAAE;UACP,iBAAiB,CAAC,cAAc,gBAAgB,GAAG,SAAS;QAC5E;AAIY,cAAM,oBAAoB,MAAM,KAAK,EAAE,kBAAkB,QAAQ,OAAO,SAAS,SAAS,GAAG,WAAW,QAAQ,OAAO,SAAS,SAAS,GAAG;AAU5I,cAAM,yBAAyB,MAAM;AACjC,cAAIC;AACJ,gBAAM,qBAAqBA,MAAK,EAAE,sBAAsB,QAAQA,QAAO,SAAS,SAASA,IAAG;AAC5F,cAAI,mBAAmB;AACnB,mBAAO;UAC3B,OACqB;AACD,kBAAM,sBAAsB,iBAAiB,aAAa;AAC1D,cAAE,mBAAmB,OAAO,OAAO,OAAO,OAAO,CAAA,GAAI,EAAE,gBAAgB,GAAG,EAAE,oBAAmB,CAAE;AACjG,mBAAO;UAC3B;QACA;AACY,cAAM,aAAa,mBACb,qBAAqB,OACjB,EAAE,SACF,OAAO,qBAAqB,aACxB,uBAAsB,IACtB,mBACR;AACN,gBAAQ,OAAO,OAAO,OAAO,OAAO,CAAA,GAAI,KAAK,GAAG,UAAU;AAC1D,eAAO,EAAE,EAAE,cAAc,KAAK;MAC1C,CAAS;IAAC;EACV;AACA,CAAC;AC5ZW,IAACC,gBAA6B,gBAAgB;EACtD,MAAM;EACN,OAAO;IACH,cAAc,EAAE,MAAM,UAAU,SAAS,MAAM;AAAE,aAAO,CAAA;IAAG,EAAE;IAC7D,UAAU;IACV,UAAU;IACV,MAAM;IACN,KAAK;IACL,QAAQ;IACR,UAAU;IACV,KAAK;IACL,QAAQ;EAChB;EACI,MAAM,OAAO,EAAE,MAAK,GAAI;AACpB,IAAAjF,sBAAoB,kBAAkBkF,YAAe;AACrD,UAAM,YAAY,OAAO,YAAY;AACrC,UAAM,UAAU,CAAC,OAAO;AACpB,UAAI,GAAG,YAAY;AACf,WAAG,eAAc;MACjC;AAOY,YAAM,EAAE,KAAK,MAAM,aAAY,IAAK;AACpC,YAAM,WAAW,aAAY;AAC7B,YAAM,YAAY,SAAS,KAAK,GAAG,KAAK,CAAA;AACxC,YAAM,eAAe,UAAU,gBAAgB;AAC/C,YAAM,cAAc,UAAU,eAAe;AAC7C,YAAM,gBAAgB,SAAS;AAS/B,UAAI,kBAAkB,KAAK;AACvB,YAAI,iBAAiB,aAAa;AAC9B,oBAAU,SAAS,GAAG;QAC1C;MACA,OACiB;AACD,kBAAU,UAAU,KAAK,WAAW;MACpD;IACA;AACQ,WAAO,MAAM;AACT,aAAO,EAAE,kBAAkB,OAAO,OAAO,EAAE,QAAO,GAAI,KAAK,GAAG,MAAM,WAAW,MAAM,QAAO,CAAE;IAC1G;EACA;AACA,CAAC;ACvDD,IAAM,cAAc;AACpB,IAAM,aAAa;AACP,IAAC,UAAwB,gBAAgB;EACjD,MAAM;EACN,OAAO,CAAC,aAAa,UAAU;EAC/B,SAAS;AACL,QAAI;AACJ,UAAM,EAAE,QAAQ,OAAO,MAAK,IAAK;AACjC,UAAM,iBAAiB,MAAM,WAAW,MAAM,QAAO;AACrD,QAAI;AAKJ,QAAI,kBAAkB,eAAe,SAAS,GAAG;AAC7C,qBAAe,eAAe,KAAK,CAAC,UAAU,MAAM,QAAQ,MAAM,KAAK,SAAS,iBAAiB;IAC7G;AACQ,QAAI,CAAC,cAAc;AACf,YAAM,IAAI,MAAM,qIAAqI;IACjK;AACQ,QAAI,mBAAmB;MACnB,EAAE,OAAO;QACL,OAAO;QACP,OAAO;UACH,YAAY;UACZ,QAAQ;UACR,WAAW;QAC/B;MACA,GAAe,YAAY;IAC3B;AAMQ,QAAI,kBAAkB,eAAe,SAAS,GAAG;AAK7C,YAAM,kBAAkB,eAAe,OAAO,CAAC,UAAW,CAAC,MAAM,QAC5D,MAAM,QAAQ,MAAM,KAAK,SAAS,iBAAmB;AAC1D,YAAM,gBAAgB,gBAAgB,KAAK,CAAC,UAAU,MAAM,QAAQ,MAAM,KAAK,SAAS,WAAW;AACnG,YAAM,mBAAmB,mBAAmB,KAAK,cAAc,WAAW,QAAQ,OAAO,SAAS,SAAS,GAAG,UAAU;AACxH,UAAI,eAAe;AACf,YAAI,CAAC,cAAc,OAAO;AACtB,wBAAc,QAAQ,CAAA;QAC1C;AAQgB,sBAAc,MAAM,kBAAkB,CAAC,QAAQ,MAAM,aAAa,EAAE,IAAG,CAAE;AACzE,sBAAc,MAAM,iBAAiB,CAAC,QAAQ,MAAM,YAAY,EAAE,IAAG,CAAE;MACvF;AACY,UAAI,kBAAkB;AAClB,2BAAmB;UACf,GAAG;UACH,GAAG;QACvB;MACA,OACiB;AACD,2BAAmB;UACf,GAAG;UACH,GAAG;QACvB;MACA;IACA;AACQ,WAAO,EAAE,YAAY;MACjB,OAAO;QACH,WAAW;QACX,YAAY;QACZ,OAAO;QACP,QAAQ;QACR,SAAS;QACT,UAAU;QACV,kBAAkB;QAClB,SAAS;QACT,UAAU;QACV,WAAW;QACX,WAAW;MAC3B;IACA,GAAW,gBAAgB;EAC3B;AACA,CAAC;ACrFD,IAAM,cAAc,CAAC,UAAU;AAAE,MAAI;AAAI,WAAS,KAAK,MAAM,UAAU,QAAQ,OAAO,SAAS,SAAS,GAAG,UAAU;AAAe;AACpI,IAAM,UAAU,CAAC,UAAU;AACvB,MAAI,OAAO,CAAA;AACX,QAAM,QAAQ,CAAC,SAAS;AACpB,QAAI,YAAY,IAAI,GAAG;AACnB,WAAK,KAAK,IAAI;IAC1B,WACiB,MAAM,QAAQ,KAAK,QAAQ,KAAK,KAAK,SAAS,SAAS,GAAG;AAC/D,YAAM,YAAY,QAAQ,KAAK,QAAQ;AACvC,aAAO,CAAC,GAAG,MAAM,GAAG,SAAS;IACzC;EACA,CAAK;AACD,SAAO;AACX;AACY,IAACC,aAAY,gBAAgB;EACrC,MAAM;EACN,OAAO;IACH,iBAAiB,EAAE,MAAM,UAAU,SAAS,MAAM;IAAA,EAAG;IACrD,gBAAgB,EAAE,MAAM,UAAU,SAAS,MAAM;IAAA,EAAG;EAC5D;EACI,OAAO;AACH,WAAO;MACH,UAAU;QACN,WAAW;QACX,MAAM,CAAA;MACtB;MACY,WAAW,CAAA;IACvB;EACA;EACI,UAAU;AACN,SAAK,cAAc,OAAO,YAAY,CAAC;EAC/C;EACI,SAAS;IACL,cAAc,WAAW;AAQrB,YAAM,WAAW,KAAK,MAAM;AAC5B,YAAM,kBAAkB,mBAAkB;AAC1C,YAAM,OAAO,KAAK,MAAM,YAAY,QAAS,gBAAgB,QAAQ,YAAY,CAAA,CAAE;AACnF,WAAK,QAAQ,WAAS;AAClB,iBAAS,KAAK,MAAM,MAAM,GAAG,IAAI;UAC7B,cAAc,MAAM,MAAM;UAC1B,aAAa,MAAM,MAAM;UACzB,KAAK;QACzB;AAMgB,cAAM,UAAU,MAAM,eAAe,MAAM;MAC3D,CAAa;AACD,WAAK,eAAe,SAAS;IACzC;IACQ,eAAe,WAAW;AACtB,YAAM,eAAe,UAAU,oBAAmB;AAClD,YAAM,aAAa,KAAK,MAAM;AAC9B,YAAM,EAAE,MAAM,WAAW,cAAa,IAAK,KAAK,MAAM;AACtD,YAAM,WAAW,KAAK,MAAM;AAC5B,YAAM,UAAU,OAAO,KAAK,IAAI;AAChC,YAAM,YAAY,QACb,KAAK,SAAO;AACb,cAAM,OAAO,KAAK,GAAG,EAAE;AACvB,eAAO,aAAa,SAAS,WAAW,IAAI;MAC5D,CAAa;AAMD,iBAAW,QAAQ,CAAC,UAAU;AAC1B,cAAM,MAAM,KAAK,MAAM,MAAM,GAAG;AAChC,YAAI,CAAC,OAAQ,IAAI,iBAAiB,MAAM,MAAM,MAAO;AACjD,eAAK,MAAM,MAAM,GAAG,IAAI;YACpB,cAAc,MAAM,MAAM;YAC1B,aAAa,MAAM,MAAM;YACzB,KAAK;UAC7B;QACA;MACA,CAAa;AACD,UAAI,aAAa,eAAe;AAC5B,cAAM,WAAW,KAAK,MAAM,SAAS,KAAK,aAAa,EAAE;AAQzD,YAAI,cAAc,iBAAkB,aAAa,aAAa,UAAW;AAOrE,gBAAM,SAAU,aAAa,SAAU,IAAI,aAAa,WAAW;AACnE,eAAK,SAAS,IAAI,OAAO,OAAO,OAAO,OAAO,CAAA,GAAI,KAAK,SAAS,CAAC,GAAG,EAAE,aAAa,aAAa,WAAW,OAAM,CAAE;QACvI;AAKgB,YAAI,aAAa,iBAAiB,SAAU,cAAc,eAAgB;AACtE,eAAK,aAAa,IAAI,OAAO,OAAO,OAAO,OAAO,CAAA,GAAI,KAAK,aAAa,CAAC,GAAG,EAAE,aAAa,KAAK,aAAa,EAAE,aAAY,CAAE;QACjJ;MACA;AACY,YAAM,cAAc,WAAW,KAAK,CAAC,UAAU;AAAE,YAAI;AAAI,eAAO,YAAY,KAAK,OAAO,KAAK,MAAM,WAAW,QAAQ,OAAO,SAAS,SAAS,GAAG,SAAS;MAAU,CAAE;AACvK,YAAM,SAAS,KAAK,MAAM;AAC1B,YAAM,eAAe,cAAc;AACnC,UAAI,QAAQ;AACR,YAAI,aAAa;AACb,0BAAgB,KAAK,OAAO,gBAAgB,SAAS;AACrD,oBAAU,oBAAoB,SAAS;AACvC,iBAAO,cAAc,SAAS,YAAY;AAC1C,0BAAgB,KAAK,OAAO,eAAe,SAAS;QAOxE,OACqB;AACD,iBAAO,cAAc,SAAS,YAAY;QAC9D;MACA;IACA;EACA;EACI,UAAU;AACN,UAAM,YAAY,OAAO,YAAY;AACrC,SAAK,cAAc,SAAS;AAC5B,cAAU,8BAA8B,MAAM,KAAK,eAAe,SAAS,CAAC;EACpF;EACI,MAAM,GAAG,EAAE,MAAK,GAAI;AAChB,IAAAnF,sBAAoB,eAAeoF,SAAY;AAC/C,WAAO,MAAM;AACT,aAAO,EAAE,eAAe,EAAE,KAAK,YAAW,GAAI,MAAM,WAAW,MAAM,QAAO,CAAE;IAC1F;EACA;AACA,CAAC;ACjJD,IAAM,iBAAiB,WAAW,CAAA,CAAE;AACxB,IAACC,UAAuB,gBAAgB,CAAC,GAAG,EAAE,OAAO,MAAK,MAAO;AACzE,EAAArF,sBAAoB,WAAWsF,MAAS;AACxC,SAAO,MAAM;AACT,WAAO,EAAE,WAAW,OAAO,OAAO,CAAA,GAAI,KAAK,GAAG,CAAC,MAAM,WAAW,MAAM,QAAO,GAAI,GAAG,eAAe,KAAK,CAAC;EACjH;AACA,CAAC;AAWM,IAAM,6BAA6B,CAAC,cAAc;AACrD,iBAAe,QAAQ;IACnB,GAAG,eAAe;IAClB;EACR;AACA;AACO,IAAM,gCAAgC,CAAC,cAAc;AACxD,iBAAe,QAAQ,eAAe,MAAM,OAAO,SAAO,QAAQ,SAAS;AAC/E;AC1BO,IAAM,cAAc,CAAC,QAAQ,4BAA4B,WAAW,kCAAkC;AACzG,MAAI;AACJ,QAAM,kBAAkB,CAAC,eAAe,WAAW,iBAAiB,CAAA,GAAI,YAAY;AAOhF,WAAO,eAAe,OAAO;AAC7B,WAAO,eAAe,SAAS;AAC/B,UAAM,MAAM,SAAS,cAAc,KAAK;AACxC,eAAW,IAAI,UAAU,IAAI,GAAG,OAAO;AACvC,kBAAc,YAAY,GAAG;AAC7B,gBAAY,EAAE,UAAU,EAAE,IAAI,IAAG,GAAI,EAAE,WAAW,OAAO,OAAO,CAAA,GAAI,cAAc,CAAC,CAAC;AACpF,UAAM,SAAS;AACf,WAAO,QAAQ,QAAQ,GAAG;EAClC;AACI,QAAM,oBAAoB,MAAM;AAC5B,iBAAa,SAAS,SAAS;AAC/B,WAAO,QAAQ,QAAO;EAC9B;AACI,SAAO,EAAE,iBAAiB,kBAAiB;AAC/C;ACrBY,IAACC,UAAuB,gBAAgB,MAAM;AACtD,EAAAvF,sBAAoB,WAAWwF,MAAS;AACxC,QAAM,QAAQ,WAAW,CAAA,CAAE;AAK3B,QAAM,UAAU,CAAC,cAAc,MAAM,QAAQ,CAAC,GAAG,MAAM,OAAO,SAAS;AACvE,QAAM,aAAa,CAAC,cAAc,MAAM,QAAQ,MAAM,MAAM,OAAO,SAAO,QAAQ,SAAS;AAC3F,QAAM,WAAW,YAAY,SAAS,UAAU;AAChD,SAAO,MAAM;AACT,WAAO,EAAE,WAAW,EAAE,SAAQ,GAAI,MAAM,KAAK;EACrD;AACA,CAAC;ACbW,IAACC,WAAwB,gBAAgB;EACjD,MAAM;EACN,OAAO;IACH,OAAO;IACP,SAAS;IACT,MAAM;IACN,KAAK;IACL,MAAM;IACN,IAAI;IACJ,MAAM;IACN,MAAM;IACN,MAAM;IACN,KAAK;EACb;EACI,MAAM,OAAO,EAAE,MAAK,GAAI;AACpB,IAAAzF,sBAAoB,YAAY4E,OAAU;AAC1C,WAAO,MAAM;AACT,UAAI,IAAI;AACR,YAAM,EAAE,MAAM,KAAK,GAAE,IAAK;AAC1B,UAAI;AACJ,UAAI,OAAO,IAAI;AACX,YAAI,WAAW,KAAK,GAAG;AACnB,uBAAa,KAAK,QAAQ,QAAQ,QAAQ,SAAS,MAAM,QAAQ,QAAQ,OAAO,SAAS,KAAK;QAClH,OACqB;AACD,uBAAa,KAAK,OAAO,QAAQ,OAAO,SAAS,KAAK,SAAS,QAAQ,OAAO,SAAS,KAAK;QAChH;MACA,OACiB;AACD,oBAAY;MAC5B;AACY,aAAO,EAAE,YAAY,OAAO,OAAO,OAAO,OAAO,CAAA,GAAI,KAAK,GAAG,EAAE,MAAM,UAAS,CAAE,GAAG,KAAK;IACpG;EACA;AACA,CAAC;ACrCD,IAAMc,eAAa,OAAM;AACzB,IAAMC,uBAAqB,EAAE,SAASD,aAAU;AACzC,IAAM,yBAAyB,CAAC,MAAM1F,uBAAqB,iBAAiB,CAAA,GAAI,eAAe;AAClG,QAAM,4BAA4B,MAAM;AACpC,WAAO,gBAAgB,CAAC,OAAO,EAAE,OAAO,KAAI,MAAO;AAC/C,YAAM,iBAAiB;QACnB,EAAE,aAAa,GAAG,qBAAqB,aAAa,cAAa;QACjE,EAAE,aAAa,GAAG,oBAAoB,aAAa,aAAY;QAC/D,EAAE,aAAa,GAAG,qBAAqB,aAAa,cAAa;QACjE,EAAE,aAAa,GAAG,oBAAoB,aAAa,aAAY;MAC/E;AACY,UAAIA,0BAAwB,QAAW;AACnC,QAAAA,sBAAmB;MACnC;AACY,YAAM,UAAU,IAAG;AACnB,YAAM,iBAAiB,YAAY;AAC/B,cAAM,SAAS,MAAM;AACrB,kBAAW,MAAM,QAAQ,KAAK;MAC9C;AACY,YAAM,iBAAiB,OAAO,MAAM,aAAa;AAC7C,cAAM,SAAS,KAAK,MAAM;AAC1B,cAAM,aAAa,SAAS,MAAM;AAKlC,YAAI,WAAW;AACX;AACJ,YAAI,QAAQ;AACR,gBAAM,QAAQ,KAAK;QACvC,OACqB;AACD,gBAAM,QAAO;QACjC;MACA;AACY,YAAM,uBAAuB,YAAY;AACrC,cAAM,QAAO;MAC7B;AACY,YAAM,UAAU,YAAY;AACxB,YAAI,CAAC,QAAQ;AACT;AACJ,cAAM,QAAQ;AACd,gBAAQ,QAAQ,QAAQ,MAAM,QAAO;AACrC,cAAM,QAAQ;AACd,gBAAQ,QAAQ;MAChC;AACY,YAAM,UAAU,OAAO4F,WAAU;AAC7B,YAAI;AAKJ,YAAI,QAAQ,OAAO;AACf,gBAAM,QAAQ;QAClC;AACgB,aAAK,KAAK,QAAQ,WAAW,QAAQ,OAAO,SAAS,SAAS,GAAG,SAAS;AACtE,gBAAM,QAAQ,MAAM,QAAO;AAC3B;QACpB;AACgB,YAAI,cAAc,CAAA;AAOlB,mBAAW,OAAOA,QAAO;AACrB,gBAAM,QAAQA,OAAM,GAAG;AACvB,cAAIA,OAAM,eAAe,GAAG,KAAK,UAAUF,cAAY;AACnD,wBAAY,GAAG,IAAI;UAC3C;QACA;AAKgB,eAAO,YAAY;AACnB,eAAO,YAAY;AACnB,eAAO,YAAY;AACnB,eAAO,YAAY;AACnB,cAAM,YAAY,MAAM,WAAW,MAAM,QAAO,EAAG,CAAC;AACpD,gBAAQ,QAAQ,WAAW,OAAO,OAAO,OAAO,OAAO,OAAO,CAAA,GAAI,WAAW,GAAG,EAAE,UAAS,CAAE,CAAC;AAC9F,gBAAQ,QAAQ,MAAM,QAAQ;AAC9B,uBAAe,QAAQ,mBAAiB;AACpC,kBAAQ,MAAM,iBAAiB,cAAc,aAAa,MAAM;AAC5D,iBAAK,cAAc,WAAW;UACtD,CAAqB;QACrB,CAAiB;AACD,cAAM,QAAQ,MAAM,QAAO;MAC3C;AACY,aAAO,MAAM;AACT,eAAO,EAAE,OAAO;UACZ,OAAO,EAAE,SAAS,OAAM;UACxB;UACA;UACA;UACA,QAAQ,MAAM,WAAW;QAC7C,CAAiB;MACjB;IACA,CAAS;EACT;AACI,QAAM,wBAAwB,MAAM;AAChC,WAAO,gBAAgB,CAAC,OAAO,EAAE,MAAK,MAAO;AACzC,UAAI1F,0BAAwB,QAAW;AACnC,QAAAA,sBAAmB;MACnC;AACY,YAAM,SAAS,IAAI,KAAK;AACxB,YAAM,aAAa,IAAG;AACtB,gBAAU,MAAM;AACZ,mBAAW,MAAM,iBAAiB,gBAAgB,MAAM,OAAO,QAAQ,IAAI;AAC3E,mBAAW,MAAM,iBAAiB,eAAe,MAAM,OAAO,QAAQ,KAAK;MAC3F,CAAa;AACD,aAAO,MAAM;AACT,YAAI,cAAc,CAAA;AAOlB,mBAAW,OAAO,OAAO;AACrB,gBAAM,QAAQ,MAAM,GAAG;AACvB,cAAI,MAAM,eAAe,GAAG,KAAK,UAAU0F,cAAY;AACnD,wBAAY,GAAG,IAAI;UAC3C;QACA;AACgB,eAAO,EAAE,MAAM,OAAO,OAAO,OAAO,OAAO,CAAA,GAAI,WAAW,GAAG,EAAE,KAAK,WAAU,CAAE,GAAI,OAAO,SAAS,YAAY,sBAAuB,QAAQ,MAAS;MACxK;IACA,CAAS;EACT;AACI,QAAM,YAAa,eAAe,SAAa,0BAAyB,IAAK,sBAAqB;AAClG,YAAU,cAAc;AACxB,YAAU,QAAQ;IACd,UAAUC;EAClB;AACI,iBAAe,QAAQ,mBAAiB;AACpC,cAAU,MAAM,aAAa,IAAIA;EACzC,CAAK;AACD,MAAI,eAAe,QAAW;AAC1B,cAAU,QAAQ,CAAC,eAAe,cAAc,eAAe,YAAY;EACnF;AACI,SAAO;AACX;ACrIY,IAAC,iBAA+B,uBAAuB,oBAAoBE,sBAAmC,CAAC,YAAY,mBAAmB,WAAW,YAAY,kBAAkB,UAAU,kBAAkB,iBAAiB,kBAAkB,QAAQ,aAAa,aAAa,GAAGC,qBAAqB;AAChT,IAAC,WAAyB,uBAAuB,aAAaC,sBAA6B,CAAC,YAAY,mBAAmB,WAAW,YAAY,kBAAkB,UAAU,kBAAkB,UAAU,iBAAiB,kBAAkB,WAAW,QAAQ,aAAa,aAAa,GAAGC,eAAe;AAC5S,IAAC,aAA2B,uBAAuB,eAAeC,uBAA+B,CAAC,YAAY,mBAAmB,YAAY,YAAY,kBAAkB,kBAAkB,iBAAiB,kBAAkB,WAAW,QAAQ,gBAAgB,WAAW,aAAa,GAAGC,iBAAiB;AAC/S,IAAC,YAA0B,uBAAuB,cAAcC,uBAA8B,CAAC,YAAY,mBAAmB,WAAW,WAAW,YAAY,YAAY,kBAAkB,kBAAkB,iBAAiB,kBAAkB,QAAQ,cAAc,GAAGC,gBAAgB;AAC5R,IAAC,WAAyB,uBAAuB,aAAaC,uBAA6B,CAAC,YAAY,WAAW,SAAS,YAAY,YAAY,kBAAkB,UAAU,kBAAkB,QAAQ,iBAAiB,kBAAkB,WAAW,QAAQ,YAAY,aAAa,GAAGC,eAAe;AAC3S,IAAC,WAAyB,uBAAuB,aAAaC,uBAA6B,CAAC,YAAY,sBAAsB,mBAAmB,eAAe,cAAc,kBAAkB,UAAU,kBAAkB,kBAAkB,qBAAqB,UAAU,uBAAuB,iBAAiB,kBAAkB,QAAQ,qBAAqB,gBAAgB,gBAAgB,SAAS,CAAC;AAC9Y,IAAC,aAA2B,uBAAuB,eAAeC,uBAA+B,CAAC,aAAa,YAAY,SAAS,mBAAmB,aAAa,kBAAkB,mBAAmB,kBAAkB,SAAS,kBAAkB,UAAU,uBAAuB,iBAAiB,kBAAkB,QAAQ,aAAa,gBAAgB,QAAQ,QAAQ,eAAe,WAAW,eAAe,CAAC;ACFra,IAAM,mBAAmB,CAACxG,uBAAqB,eAAe,cAAc,UAAU;AAClF,QAAM,WAAW,cAAc,YAAW,IAAK;AAC/C,QAAM,YAAY,cAAc,OAAO,KAAK,aAAa;AACzD,gBAAc,SAAS,CAAC,YAAY;AAChC,IAAAA,sBAAmB;AACnB,WAAO,UAAU,OAAO,OAAO,OAAO,OAAO,CAAA,GAAI,OAAO,GAAG,EAAE,SAAQ,CAAE,CAAC;EAChF;AACI,SAAO;AACX;AACK,IAACyG,mBAAgC,iBAAiBF,uBAA6BG,iBAAW,IAAI;AAC9F,IAACC,qBAAkC,iBAAiBH,uBAA+BI,mBAAa,IAAI;AACpG,IAACZ,mBAAgC,iBAAiBD,sBAA6Bc,eAAS;AACxF,IAACf,yBAAsC,iBAAiBD,sBAAmCiB,qBAAe;AAC1G,IAACZ,qBAAkC,iBAAiBD,uBAA+Bc,iBAAW;AAC9F,IAACX,oBAAiC,iBAAiBD,uBAA8Ba,gBAAU;AAC3F,IAACV,mBAAgC,iBAAiBD,uBAA6BY,eAAS;",
  "names": ["h", "supportsListenerOptions", "scopeId", "h", "h", "i", "isSvgMode", "newVNode", "i", "ref", "scopeId", "ref", "i", "win", "i", "i", "h", "ref", "i", "defineCustomElement", "defineIonAccordion", "defineIonAccordionGroup", "defineIonAvatar", "defineIonBackdrop", "defineIonBadge", "defineIonBreadcrumb", "defineIonBreadcrumbs", "defineIonButton", "defineIonButtons", "defineIonCard", "defineIonCardContent", "defineIonCardHeader", "defineIonCardSubtitle", "defineIonCardTitle", "defineIonCheckbox", "defineIonChip", "defineIonCol", "defineIonContent", "defineIonDatetime", "defineIonDatetimeButton", "defineIonFab", "defineIonFabButton", "defineIonFabList", "defineIonFooter", "defineIonGrid", "defineIonHeader", "defineIonImg", "defineIonInfiniteScroll", "defineIonInfiniteScrollContent", "defineIonInput", "defineIonItem", "defineIonItemDivider", "defineIonItemGroup", "defineIonItemOption", "defineIonItemOptions", "defineIonItemSliding", "defineIonLabel", "defineIonList", "defineIonListHeader", "defineIonMenu", "defineIonMenuButton", "defineIonMenuToggle", "defineIonNavLink", "defineIonNote", "defineIonProgressBar", "defineIonRadio", "defineIonRadioGroup", "defineIonRange", "defineIonRefresher", "defineIonRefresherContent", "defineIonReorder", "defineIonReorderGroup", "defineIonRippleEffect", "defineIonRow", "defineIonSearchbar", "defineIonSegment", "defineIonSegmentButton", "defineIonSelect", "defineIonSelectOption", "defineIonSkeletonText", "defineIonSlide", "defineIonSlides", "defineIonSpinner", "defineIonSplitPane", "defineIonText", "defineIonTextarea", "defineIonThumbnail", "defineIonTitle", "defineIonToggle", "defineIonToolbar", "defineIonVirtualScroll", "LifecycleHooks", "hook", "IonBackButton", "IonBackButtonCmp", "IonIconCmp", "IonRouterOutlet", "IonRouterOutletCmp", "matchedRouteRef", "_a", "IonTabButton", "IonTabButtonCmp", "IonTabBar", "IonTabBarCmp", "IonApp", "IonAppCmp", "IonNav", "IonNavCmp", "IonIcon", "EMPTY_PROP", "DEFAULT_EMPTY_PROP", "props", "defineIonActionSheetCustomElement", "actionSheetController", "defineIonAlertCustomElement", "alertController", "defineIonLoadingCustomElement", "loadingController", "defineIonPickerCustomElement", "pickerController", "defineIonToastCustomElement", "toastController", "defineIonModalCustomElement", "defineIonPopoverCustomElement", "modalController", "modalCtrl", "popoverController", "popoverCtrl", "alertCtrl", "actionSheetCtrl", "loadingCtrl", "pickerCtrl", "toastCtrl"]
}
