{"version":3,"file":"vue-scroll-picker.umd.js","sources":["../src/components/picker.ts","../src/index.ts"],"sourcesContent":["import { defineComponent, PropType, h, renderSlot, VNode } from 'vue'\n\n\nfunction debounce<TFunc extends Function>(handle: TFunc, delay = 83): TFunc { // eslint-disable-line @typescript-eslint/ban-types\n  let timeout = null as any\n  return function (this: any) {\n    if (timeout) {\n      clearTimeout(timeout)\n      timeout = null\n    }\n    const self = this // eslint-disable-line no-invalid-this,@typescript-eslint/no-this-alias\n    const args = arguments // eslint-disable-line prefer-rest-params\n    timeout = setTimeout(() => handle.apply(self, args), delay)\n  } as any as TFunc\n}\n\nfunction getBoundingClientCenterY(elem: HTMLElement) {\n  const { top, bottom } = elem.getBoundingClientRect()\n  return (top + bottom) / 2\n}\n\nfunction normalizeOptions(options: ScrollPickerOptionable[]): ScrollPickerOption[] {\n  return options.map((option) => {\n    switch (typeof option) {\n      case 'string': {\n        return { value: option, name: option }\n      }\n      case 'number':\n      case 'boolean': {\n        return { value: option, name: `${option}` }\n      }\n    }\n    return option\n  })\n}\n\nfunction isTouchEvent(event: any): event is TouchEvent {\n  return event.changedTouches || event.touches\n}\n\nfunction getEventXY(event: TouchEvent | MouseEvent): { clientX: number, clientY: number } {\n  if (isTouchEvent(event)) {\n    return event.changedTouches[0] || event.touches[0]\n  }\n  return event\n}\n\ntype MouseWheelEvent = MouseEvent & { deltaY: number }\n\nexport interface ScrollPickerOption {\n  name: string\n  value: any\n}\n\nexport type ScrollPickerOptionable = string | number | boolean | ScrollPickerOption\n\nexport default defineComponent({\n  props: {\n    modelValue: null,\n    options: {\n      type: Array as PropType<ScrollPickerOptionable[]>,\n      default: () => [],\n    },\n    dragSensitivity: {\n      type: Number,\n      default: 1.7,\n    },\n    touchSensitivity: {\n      type: Number,\n      default: 1.7,\n    },\n    scrollSensitivity: {\n      type: Number,\n      default: 1,\n    },\n    empty: {\n      type: String,\n      default: 'No Items',\n    },\n    placeholder: {\n      type: String,\n      default: null,\n    },\n  },\n  data() {\n    const internalOptions = normalizeOptions(this.options)\n\n    let internalIndex = internalOptions.findIndex(option => option.value == this.modelValue)\n    if (internalIndex === -1 && !this.placeholder && !this.$slots.placeholder && this.options.length > 0) {\n      internalIndex = 0\n    }\n    const internalValue = internalOptions[internalIndex]?.value ?? null\n\n    return {\n      refItems: [] as HTMLDivElement[],\n\n      internalOptions,\n      internalIndex,\n      internalValue,\n\n      pivots: [] as number[],\n      pivotsMin: 0,\n      pivotsMax: 0,\n\n      scroll: null as number | null,\n      scrollOffsetTop: 0,\n      scrollMin: 0,\n      scrollMax: 0,\n\n      transitioning: false,\n      transitionTimer: null as any | null,\n\n      start: null as [scroll: number, clientY: number] | null,\n\n      isMouseDown: false,\n      isDragging: false,\n    }\n  },\n  beforeUpdate() {\n    this.refItems = []\n  },\n  mounted() {\n    this.calculatePivots()\n    this.scroll = this.findScrollByIndex(this.internalIndex)\n    if (this.internalValue !== this.modelValue) {\n      this.$emit('update:modelValue', this.internalValue)\n    }\n\n    const $el = this.$el as HTMLDivElement\n\n    $el.addEventListener('touchstart', this.onStart)\n    $el.addEventListener('touchmove', this.onMove)\n    $el.addEventListener('touchend', this.onEnd)\n    $el.addEventListener('touchcancel', this.onCancel)\n\n    $el.addEventListener('mousewheel', this.onWheel as any)\n    $el.addEventListener('DOMMouseScroll', this.onWheel as any)\n    $el.addEventListener('wheel', this.onWheel)\n    $el.addEventListener('mousedown', this.onStart)\n    $el.addEventListener('mousemove', this.onMove)\n    $el.addEventListener('mouseup', this.onEnd)\n    $el.addEventListener('mouseleave', this.onCancel)\n\n  },\n  beforeUnmount() {\n    const $el = this.$el as HTMLDivElement\n\n    $el.removeEventListener('touchstart', this.onStart)\n    $el.removeEventListener('touchmove', this.onMove)\n    $el.removeEventListener('touchend', this.onEnd)\n    $el.removeEventListener('touchcancel', this.onCancel)\n\n    $el.removeEventListener('mousewheel', this.onWheel as any)\n    $el.removeEventListener('DOMMouseScroll', this.onWheel as any)\n    $el.removeEventListener('wheel', this.onWheel)\n    $el.removeEventListener('mousedown', this.onStart)\n    $el.removeEventListener('mousemove', this.onMove)\n    $el.removeEventListener('mouseup', this.onEnd)\n    $el.removeEventListener('mouseleave', this.onCancel)\n  },\n  watch: {\n    modelValue(value: any) {\n      if ((value === null || value === undefined) && this.hasPlaceholder) {\n        this.correction(-1)\n        return\n      }\n\n      const nextInternalIndex = this.internalOptions.findIndex((option) => option.value == value)\n      if (nextInternalIndex === -1) {\n        this.$emit('update:modelValue', this.internalValue)\n        return\n      }\n\n      if (this.internalIndex !== nextInternalIndex) {\n        this.correction(nextInternalIndex)\n      }\n    },\n    options: {\n      handler(options: ScrollPickerOptionable[]) {\n        const internalOptions = this.internalOptions = normalizeOptions(options)\n\n        let internalIndex = internalOptions.findIndex(option => option.value == this.modelValue)\n        if (internalIndex === -1 && !this.hasPlaceholder && this.options.length > 0) {\n          internalIndex = 0\n        }\n        const internalValue = internalOptions[internalIndex]?.value ?? null\n\n        this.$nextTick(() => {\n          this.calculatePivots()\n          this.scroll = this.findScrollByIndex(internalIndex)\n          this.internalIndex = internalIndex\n          if (this.internalValue !== internalValue) {\n            this.$emit('update:modelValue', this.internalValue = internalValue)\n          }\n        })\n      },\n      deep: true,\n    },\n  },\n  computed: {\n    hasPlaceholder(): boolean {\n      return !!(this.placeholder || this.$slots.placeholder)\n    },\n  },\n  methods: {\n    setRefItem(el: HTMLDivElement) {\n      this.refItems.push(el)\n    },\n    resize() {\n      this.$nextTick(() => {\n        this.calculatePivots()\n        this.scroll = this.findScrollByIndex(this.internalIndex)\n      })\n    },\n    calculatePivots() {\n      const $rotator = this.$refs.rotator as HTMLDivElement\n      const $layerSelection = this.$refs.layerSelection as HTMLDivElement\n\n      const rotatorTop = $rotator.getBoundingClientRect().top\n      const pivots = this.pivots = this.refItems.map((item) => getBoundingClientCenterY(item) - rotatorTop).sort((a, b) => a - b)\n      const pivotsMin = this.pivotsMin = Math.min(...pivots)\n      const pivotsMax = this.pivotsMax = Math.max(...pivots)\n\n      const scrollOffsetTop = this.scrollOffsetTop = $layerSelection.offsetTop + $layerSelection.offsetHeight / 2\n\n      this.scrollMin = scrollOffsetTop - pivotsMin\n      this.scrollMax = scrollOffsetTop - pivotsMax\n    },\n    sanitizeInternalIndex(index: number): number {\n      return Math.min(Math.max(index, this.hasPlaceholder ? -1 : 0), this.internalOptions.length - 1)\n    },\n    findIndexFromScroll(scroll: number): number {\n      let prevDiff = null as number | null\n      let pivotIndex = 0\n      this.pivots.forEach((pivot, i) => {\n        const diff = pivot + scroll - this.scrollOffsetTop\n        if (prevDiff === null || Math.abs(prevDiff) > Math.abs(diff)) {\n          pivotIndex = i\n          prevDiff = diff\n        }\n      })\n      if (this.hasPlaceholder || this.options.length === 0) {\n        return pivotIndex - 1\n      }\n      return pivotIndex\n    },\n    findScrollByIndex(index: number): number {\n      let pivotIndex = index\n      if (this.hasPlaceholder || this.options.length === 0) {\n        pivotIndex++\n      }\n      if (index > -1 && pivotIndex in this.pivots) {\n        return this.scrollOffsetTop - this.pivots[pivotIndex]\n      }\n      if (index >= this.pivots.length) {\n        return this.scrollOffsetTop - this.pivotsMax\n      }\n      return this.scrollOffsetTop - this.pivotsMin\n\n    },\n    onWheel(event: MouseWheelEvent) {\n      if (this.scroll! >= this.scrollMin && event.deltaY < 0) { return }\n      if (this.scroll! <= this.scrollMax && event.deltaY > 0) { return }\n      if (this.pivots.length === 1) { return }\n\n      event.preventDefault()\n\n      const nextDirInternalIndex = this.sanitizeInternalIndex(this.internalIndex + (event.deltaY > 0 ? 1 : -1))\n      const deltaMax = event.deltaY > 0\n        ? this.findScrollByIndex(nextDirInternalIndex - 1) - this.findScrollByIndex(nextDirInternalIndex)\n        : this.findScrollByIndex(nextDirInternalIndex) - this.findScrollByIndex(nextDirInternalIndex + 1)\n\n      const deltaY = Math.max(Math.min(event.deltaY, deltaMax), deltaMax * -1)\n\n      this.scroll = Math.min(Math.max(this.scroll! - deltaY * this.scrollSensitivity, this.scrollMax), this.scrollMin)\n\n      const nextInternalIndex = this.sanitizeInternalIndex(this.findIndexFromScroll(this.scroll))\n      const nextInternalValue = this.internalOptions[nextInternalIndex]?.value ?? null\n\n      this.internalIndex = nextInternalIndex\n      if (this.internalValue !== nextInternalValue) {\n        this.$emit('update:modelValue', this.internalValue = nextInternalValue)\n      }\n\n      this.onAfterWheel(() => {\n        this.correction(this.findIndexFromScroll(this.scroll!))\n      })\n    },\n    onAfterWheel: debounce((handler: () => void) => {\n      handler()\n    }, 200),\n    onStart(event: TouchEvent | MouseEvent) {\n      if (event.cancelable) {\n        event.preventDefault()\n      }\n\n      const { clientY } = getEventXY(event)\n      this.start = [this.scroll!, clientY]\n      if (!isTouchEvent(event)) {\n        this.isMouseDown = true\n      }\n      this.isDragging = false\n    },\n    onMove(event: TouchEvent | MouseEvent) {\n      if (event.cancelable) {\n        event.preventDefault()\n      }\n      if (!this.start) {\n        return\n      }\n      const { clientY } = getEventXY(event)\n      const diff = clientY - this.start[1]\n      if (Math.abs(diff) > 1.5) {\n        this.isDragging = true\n      }\n      this.scroll = this.start[0] + diff * (isTouchEvent(event) ? this.touchSensitivity : this.dragSensitivity)\n    },\n    onEnd(event: TouchEvent | MouseEvent) {\n      if (event.cancelable) {\n        event.preventDefault()\n      }\n      if (this.isDragging) {\n        this.correction(this.findIndexFromScroll(this.scroll!))\n      } else if (this.isMouseDown) {\n        this.onClick(event)\n      }\n      this.start = null\n      this.isDragging = false\n      this.isMouseDown = false\n    },\n    onCancel(event: TouchEvent | MouseEvent) {\n      if (event.cancelable) {\n        event.preventDefault()\n      }\n      this.correction(this.findIndexFromScroll(this.scroll!))\n      this.start = null\n      this.isMouseDown = false\n      this.isDragging = false\n    },\n    onClick(event: TouchEvent | MouseEvent) {\n      const $layerTop = this.$refs.layerTop as HTMLDivElement\n      const $layerBottom = this.$refs.layerBottom as HTMLDivElement\n      const touchInfo = getEventXY(event)\n      const x = touchInfo.clientX\n      const y = touchInfo.clientY\n      const topRect = $layerTop.getBoundingClientRect()\n      const bottomRect = $layerBottom.getBoundingClientRect()\n\n      if (topRect.left <= x && x <= topRect.right && topRect.top <= y && y <= topRect.bottom) {\n        this.correction(this.internalIndex - 1)\n      } else if (bottomRect.left <= x && x <= bottomRect.right && bottomRect.top <= y && y <= bottomRect.bottom) {\n        this.correction(this.internalIndex + 1)\n      }\n    },\n    correction(index: number) {\n      const nextInternalIndex = this.sanitizeInternalIndex(index)\n      const nextInternalValue = this.internalOptions[nextInternalIndex]?.value ?? null\n      this.scroll = this.findScrollByIndex(nextInternalIndex)\n\n      this.transitioning = true\n      if (this.transitionTimer) {\n        clearTimeout(this.transitionTimer)\n        this.transitionTimer = null\n      }\n\n      this.transitionTimer = setTimeout(() => {\n        this.transitioning = false\n        this.transitionTimer = null\n\n        this.internalIndex = nextInternalIndex\n        if (this.internalValue !== nextInternalValue) {\n          this.$emit('update:modelValue', this.internalValue = nextInternalValue)\n        }\n      }, 100)\n    },\n  },\n  render() {\n    let nodes = [] as VNode[]\n    if (this.hasPlaceholder) {\n      nodes.push(h('div', {\n        class: [\n          'vue-scroll-picker-item',\n          'vue-scroll-picker-item-placeholder',\n          {\n            'vue-scroll-picker-item-selected': this.internalIndex === -1,\n          },\n        ],\n        ref: (el) => el && this.setRefItem(el as HTMLDivElement),\n      }, renderSlot(this.$slots, 'placeholder', { text: this.placeholder }, () => [\n        this.placeholder,\n      ])))\n    } else if (this.internalOptions.length === 0) {\n      nodes.push(h('div', {\n        class: [\n          'vue-scroll-picker-item',\n          'vue-scroll-picker-item-empty',\n          'vue-scroll-picker-item-selected',\n        ],\n        ref: (el) => el && this.setRefItem(el as HTMLDivElement),\n      }, renderSlot(this.$slots, 'empty', { text: this.empty }, () => [\n        this.empty,\n      ])))\n    }\n\n    nodes = nodes.concat(this.internalOptions.map((option, index) => {\n      return h('div', {\n        class: [\n          'vue-scroll-picker-item',\n          {\n            'vue-scroll-picker-item-selected': this.internalIndex === index,\n          },\n        ],\n        key: option.value,\n        ref: (el) => el && this.setRefItem(el as HTMLDivElement),\n      }, renderSlot(this.$slots, 'default', { option }, () => [\n        option.name,\n      ]))\n    }))\n    return h('div', {\n      class: [\n        'vue-scroll-picker',\n      ],\n    }, [\n      h('div', {\n        ref: 'rotator',\n        class: [\n          'vue-scroll-picker-rotator',\n          {\n            'vue-scroll-picker-rotator-transition': this.transitioning,\n          },\n        ],\n        style: typeof this.scroll === 'number' ? { top: `${this.scroll}px` } : {},\n      }, nodes),\n      h('div', { class: ['vue-scroll-picker-layer'] }, [\n        h('div', { class: ['vue-scroll-picker-layer-top'], ref: 'layerTop' }),\n        h('div', { class: ['vue-scroll-picker-layer-selection'], ref: 'layerSelection' }),\n        h('div', { class: ['vue-scroll-picker-layer-bottom'], ref: 'layerBottom' }),\n      ]),\n    ])\n  },\n})\n","import { App, Plugin } from 'vue'\n\nimport VueScrollPicker from './components/picker'\n\n\nexport function install(app: App) {\n  app.component('VueScrollPicker', VueScrollPicker)\n}\n\nif (typeof window !== 'undefined' && (window as any).Vue) {\n  install((window as any).Vue)\n}\n\nconst plugin: Plugin = {\n  install,\n}\n\nexport default plugin\n\n// re-define: https://github.com/vitejs/vite/issues/2117\nexport interface VueScrollPickerOption {\n  name: string\n  value: any\n}\n\nexport {\n  VueScrollPicker,\n}\n"],"names":["defineComponent","h","renderSlot"],"mappings":"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"}